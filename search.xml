<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android Studio 使用 Setting Repository 同步配置信息</title>
    <url>/index.html//2019/android-studio-setting-repository.html</url>
    <content><![CDATA[<p><code>Setting Repository</code> 是 <code>IntelliJ IDEA（Android Studio）</code> 的一项配置托管服务，我们可以通过在 <code>Github</code> 或者其他 <code>Git</code> 服务上创建一个 <code>Git Repository</code> 的方式统一托管、同步配置信息：</p>
<ul>
<li>在 <code>Github</code> 创建一个代码仓库（例如： <code>android-studio-setting-repository</code>）</li>
<li>在 <code>Github</code> 上创建一个 <code>Personal access tokens</code>（保留 <code>read</code> 和 <code>write</code> 相关权限即可）</li>
<li>将版本库地址填入 <code>Android Studio</code> 的 <code>File/Setting Repository/Upstream URL</code>（尽量使用 <code>https</code> 而不是 <code>ssh</code> 的方式）</li>
<li>点击 <code>Overwrite Remote</code> 完成配置信息的提交</li>
</ul>
<blockquote>
<p><code>Overwrite Remote</code> 是将本地配置信息写入到远程仓库，<code>Overwrite Load</code> 是将远程仓库的信息写入到本地，<code>Merge</code> 则是合并两者之间的差异。</p>
</blockquote>
<p>我的 <code>Android Studio</code> 配置仓库为 <a href="https://github.com/fiissh/android-studio-setting-repository">fiissh/android-studio-setting-repository</a>。</p>
]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
      <tags>
        <tag>Setting Repository</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Studio 插件</title>
    <url>/index.html//2018/android-studio-plugin.html</url>
    <content><![CDATA[<p><code>Android Studio</code> 常用插件记录：</p>
<ul>
<li><code>.ignore</code>: 快速根据项目类型生成 <code>Git</code> 版本库的 <code>.ignore</code> 文件</li>
<li><code>ADB Idea</code>：<code>ADB</code> 常用命令，可以通过 <code>Android Studio</code> 快捷的使用 <code>ADB</code> 命令</li>
<li><code>ECTranslation</code>：翻译插件</li>
<li><code>AndroidSourceViewer</code>：快速浏览不同 <code>API Level</code> 的 <code>Android</code> 源代码</li>
<li><code>Findbugs-IDEA</code>：静态代码分析工具，找出代码中潜在的 <code>BUG</code></li>
<li><code>Android Parcelable code generator</code>：快速生成 <code>Parcelable</code> 接口的内部实现</li>
<li><code>Alibaba Java Coding Guidelines</code>：阿里代码规范检查</li>
<li><code>Markdown</code>：<code>Markdown</code> 支持</li>
<li><code>CodeGlance</code>：代码侧边栏预览</li>
<li><code>Git Commit Template</code>：<code>Git</code> 代码提交时注释的模板插件</li>
<li><code>SQLScout</code> 和 <code>Database Navigator</code>：管理 <code>Android</code> 设备上的 <code>SQLite</code> 数据库（<code>SQLScout</code> 收费）</li>
<li><code>Easy Gradle</code>：格式化 <code>build.gralde</code> 文件、升级 <code>Gradle</code> 插件以及停止 <code>Gradle</code> 进程</li>
<li><code>Gradle View</code>：查看 <code>Gradle</code> 依赖</li>
<li><code>Gradle Dependencies Helper</code>：<code>Gradle</code> 依赖自动提示</li>
</ul>
]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
      <tags>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 线程和线程池简介</title>
    <url>/index.html//2019/android-thread-pool-executor.html</url>
    <content><![CDATA[<p><code>Android</code> 中使用线程有多种不同的方式，其中最根本的是通过 <code>Thread</code> 或 <code>Runnable</code> 派生线程对象。</p>
<p>但是，使用 <code>Thread</code> 或 <code>Runnable</code> 实现多线程的方式，无法有效的在任务结束之后将结果返回。为了解决这一问题，<code>Java</code> 额外提供了 <code>Callable</code> 和 <code>FutureTask</code> 两种创建线程的方式，允许我们在线程执行完成之后得到返回的结果。</p>
<p>另外，基于 <code>Thread</code>、<code>Runnable</code>、<code>Callable</code> 和 <code>FutureTask</code> 的封装，<code>Android</code> 系统中还提供了如下多线程的实现方式：</p>
<ul>
<li><code>AsyncTask</code>：基于线程池和 <code>Handler</code> 的封装，通常用于执行需要更新 <code>UI</code> 的任务</li>
<li><code>HandlerThread</code>：基于 <code>Thread</code> 和 <code>Handler</code> 的封装，接收来自 <code>Handler</code> 的消息，其内部只有一个线程在执行任务</li>
<li><code>IntentService</code>：基于 <code>Service</code> 和 <code>HandlerThread</code> 的封装，线程的优先级更高</li>
</ul>
<p>本文将围绕线程和线程池的使用展开讨论。</p>
<span id="more"></span>

<h2 id="Thread-和-Runable"><a href="#Thread-和-Runable" class="headerlink" title="Thread 和 Runable"></a>Thread 和 Runable</h2><p><code>Thread</code> 和 <code>Runable</code> 是最为常用也是最为根本的开启多线程的方式。</p>
<p><code>Thread</code> 类提供了线程开启、暂停和销毁所必需的上下文环境和方法，其本身就是一个线程对象。通常情况下我们可以通过 <code>new</code> 关键字实例化一个 <code>Thread</code> 对象并 <code>Override</code> 其 <code>run()</code> 方法的方式创建一个线程对象，并最终通过 <code>start()</code> 方法将线程运行起来:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do somethings</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<p>这种方式在实现上较为方便和随意，对于简单的使用场景没有太大的影响。</p>
<p>针对于类级别上的线程对象，例如类 <code>ThreadA extends Thread</code>，在一些继承结构较为复杂的类中，会受限于 <code>Java</code> 的<code>单一继承结构</code>的约束。为了解决这种问题，<code>Java</code> 提供了 <code>Runable</code> 接口作为一个更为纯粹的线程对象，而 <code>Thread</code> 则是线程的管理对象。</p>
<p>虽然 <code>Thread</code> 类看上去不是那么纯粹—-其本身既可以作为线程的管理者，也可以作为线程对象，但是从面向对象的角度来说，<code>Runable</code> 的设计则将 <code>OOP</code> 中 <code>interface</code> 的精髓体现的淋漓尽致：<code>interface</code> 定义了对象能做什么。</p>
<h2 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h2><p>使用 <code>Thread</code> 和 <code>Runable</code> 的方式创建线程，在线程运行结束之后无法直接将结果返回，而 <code>Callable</code> 则提供了一种返回结果的多线程机制。</p>
<p><code>Callable</code> 位于 <code>J.U.C</code> 包下，只有一个泛型方法 <code>call()</code> 用于返回特定的结果类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常情况下，<code>Callable</code> 会跟 <code>ExecutorService</code> 或者 <code>Future</code> 一起使用。</p>
<h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p><code>Future</code> 提供了一系列的接口，对具体的 <code>Runable</code> 或 <code>Callable</code> 任务的执行结果进行管理（查询是否完成、取消和获取结果）。必要时可以通过 <code>get()</code> 方法以阻塞的方式获取执行结果。</p>
<p><code>Future</code> 位于 <code>J.U.C</code> 包下，也是一个支持泛型的接口定义：</p>
<ul>
<li><code>boolean cancel(boolean mayInterruptIfRunning);</code>：取消任务，如果任务取消成功则返回 <code>true</code>，否则返回 <code>false</code>。<code>mayInterruptIfRunning</code> 标识是否取消正在执行却没有执行完毕的任务</li>
<li><code>boolean isCancelled();</code>：查询任务是否被取消，如果在任务正常完成前被取消成功，则返回 <code>true</code></li>
<li><code>boolean isDone();</code>：查询任务是否已经完成，如果任务完成，则返回 <code>true</code></li>
<li><code>V get();</code>：以阻塞的形式等待返回结果</li>
<li><code>V get(long timeout, TimeUnit unit);</code>： 以阻塞 <code>timeout</code> 时长的形式等待返回结果，超时之后如果还没有返回结果，则直接返回 <code>null</code></li>
</ul>
<h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h2><p><code>ExecutorService</code> 位于 <code>J.U.C</code> 包下，定义了线程池的标准接口：</p>
<ul>
<li><code>shutdown</code>：<code>shutdown()</code> 和 <code>shutdownNow()</code> 都是关闭当前的线程池，释放所有资源</li>
<li><code>submit</code>：向线程池中提交任务</li>
<li><code>invoke</code>：集合任务，其中 <code>invokeAll</code> 数以同步的方式集合所有任务，当所有任务都集合完成之后就会返回，<code>invokeAny</code> 则是任何一个任务完成就返回</li>
<li><code>awaitTermination</code>：等待一定时间直到任务全部结束，如果超时就返回 <code>false</code></li>
</ul>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="ThreadPoolExecutor-类型的线程池"><a href="#ThreadPoolExecutor-类型的线程池" class="headerlink" title="ThreadPoolExecutor 类型的线程池"></a>ThreadPoolExecutor 类型的线程池</h3><p><code>ThreadPoolExecutor</code> 是 <code>Java</code> 中线程池的最终实现，<code>J.U.C</code> 包下提供的多种不同的线程池实现是基于 <code>ThreadPoolExecutor</code> 的：</p>
<ul>
<li><code>FixedThreadPool</code>：通过 <code>Executors.newFixedThreadPool(int nThreads)</code> 创建的线程池大小为 <code>nThreads</code> 的且全部为核心线程的线程池：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>nThreads</code> 为线程池的核心线程数（最大线程数）。</p>
<p>上述过程会创建一个核心线程数和最大线程数为 <code>nThreads</code>（这也就意味着 <code>FixedThreadPool</code> 中的所有线程都是核心线程）。如果当前所有线程都处于活动状态，那么新提交的任务将会被添加到 <code>LinkedBlockingQueue</code> 队列（无限制大小）中进行等待。而且由于其超时时间（<code>keepAliveTime</code>）为0，则意味着该线程池没有超时机制，所有的线程（全部为核心线程）都不会在空闲时被回收。</p>
<p><code>FixedThreadPool</code> 适用于紧急的、需要快速响应而且任务不能被回收的业务场景。</p>
<ul>
<li><code>SingleThreadExecutor</code>：通过 <code>Executors.newSingleThreadExecutor()</code> 创建的线程池大小（全部为核心线程）为1的线程池：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService(<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AbstractExecutorService</code> 和 <code>ThreadPoolExecutor</code> 在抽象层级上位于同一高度。从具体实现来说，<code>AbstractExecutorService</code> 接收一个 <code>ThreadPoolExecutor</code> 对象作为参数，再具体实现上，与直接使用下列代码并没有本质的区别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从实现的角度来说，<code>SingleThreadExecutor</code> 和 <code>FixedThreadPool</code> 除了核心线程的数量区别外，并没有本质的区别。这也就是说，使用 <code>Executors.newFixedThreadPool(int nThreads)</code> 创建线程池时，如果 <code>nThreads = 1</code>，那么将会创建一个 <code>SingleThreadExecutor</code> 的线程池。</p>
<p><code>SingleThreadExecutor</code> 适用于非紧急的但是任务不能被回收的业务场景。</p>
<ul>
<li><code>CachedThreadPool</code>：通过 <code>Executors.newCachedThreadPool()</code> 创建的核心线程数为0，线程总数为 <code>Integer.MAX_VALUE</code> 的线程池：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CachedThreadPool</code> 是一个核心线程数为0，最大线程数为 <code>Integer.MAX_VALUE</code>，超时时间为60秒的线程池。当有新的任务进入时，如果没有空闲的线程，那么将会直接创建新的线程来执行任务（并不会进入任务队列）。而且，在线程空闲超过60秒之后，线程将会被回收。</p>
<p><code>CachedThreadPool</code> 适用于执行大量低耗时的任务。</p>
<ul>
<li><code>ScheduledThreadPool</code>：通过 <code>Executors.newScheduledThreadPool(int corePoolSize)</code> 创建的核心线程数为 <code>corePoolSize</code> 的执行周期性任务的线程池：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ScheduledThreadPoolExecutor</code> 是实现了 <code>ScheduledExecutorService</code> 接口的 <code>ThreadPoolExecutor</code> 子类，其在拥有线程池的属性之外，还增加了周期性执行任务的功能。上述代码中，<code>ScheduledThreadPoolExecutor</code> 构造方法的具体实现为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述过程会创建一个核心线程数为1，线程总数为 <code>Integer.MAX_VALUE</code> 的线程池，其超时时间为10毫秒，这也就意味着，任务执行完毕，线程会在极短的时间内（10毫秒）被回收。</p>
<p><code>ScheduledThreadPool</code> 适用于执行定时任务和周期性执行的任务。</p>
<ul>
<li><code>SingleThreadScheduledExecutor</code>：通过 <code>Executors.newSingleThreadScheduledExecutor()</code> 创建的核心线程数为1的执行周期性任务的线程池：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService(<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 <code>ScheduledThreadPool</code> 一样的，<code>SingleThreadScheduledExecutor</code> 实际上是创建了一个核心线程数为1的 <code>SingleThreadScheduledExecutor</code> 对象。</p>
<h3 id="ThreadPoolExecutor-构造方法"><a href="#ThreadPoolExecutor-构造方法" class="headerlink" title="ThreadPoolExecutor 构造方法"></a>ThreadPoolExecutor 构造方法</h3><p>从上文中我们可以看出，各种类型的线程池实际上是对 <code>ThreadPoolExecutor</code> 初始化参数的不同调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> || maximumPoolSize &lt;= <span class="number">0</span> || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>corePoolSize</code>：线程池中核心线程的数量。线程池创建之后，并不会立刻创建所有的核心线程（调用 <code>ThreadPoolExecutor</code> 的 <code>prestartAllCoreThreads</code> 或 <code>prestartCoreThread</code> 方法会立刻创建核心线程），而是有新的任务进入之后，如果线程数小于 <code>corePoolSize</code>，那么就创建一个新的线程，否则按照线程池的策略进行处理。</li>
</ul>
<p>通常情况，核心线程并不会被回收，但是如果创建线程池时调用 <code>allowCoreThreadTimeOut(true)</code>，那么核心线程也会被超时回收。</p>
<ul>
<li><code>maximumPoolSize</code>：线程池中最大的线程数量。在某些类型的线程池策略中（比如 <code>FixedThreadPool</code>），如果当前线程数量已经超过 <code>maximumPoolSize</code> 的值，按照特定的策略，新的任务将会放入任务队列中等待。</li>
</ul>
<p>当有新的任务进入时，如果当前 <code>maximumPoolSize</code> 小于 <code>corePoolSize</code>，那么即便是其他非核心线程处于空闲状态，也会创建一个新的核心线程来执行任务。如果有大于 <code>corePoolSize</code> 但小于 <code>maximumPoolSize</code> 的线程正在执行，那么只有当任务队列达到上限时才会创建新的线程。但是线程总数不会超过 <code>maximumPoolSize</code>。</p>
<ul>
<li><code>keepAliveTime</code> 和 <code>unit</code>：<code>keepAliveTime</code> 是线程在执行完任务之后空闲的时间，<code>unit</code> 是单位。如果超过 <code>keepAliveTime</code> 空闲时间，那么线程会被回收。</li>
</ul>
<p>通常情况下，<code>keepAliveTime</code> 仅适用于存在超过 <code>corePoolSize</code> 数量的线程的情况。这也就是说，核心线程并不会被回收。但是如果 <code>keepAliveTime</code> 值不为0，那么如果调用 <code>allowCoreThreadTimeOut(true)</code> 方法也会造成核心线程的回收。</p>
<ul>
<li><p><code>workQueue</code>：任务队列 <code>BlockingQueue</code> 用于存放进入线程池的任务。队列的实际容量与线程池的大小关联：</p>
<ul>
<li>如果当前线程池的任务数量小于核心线程池的数量，执行器会优先创建一个线程而不是从线程队列中获取一个空闲线程</li>
<li>如果当前线程池的任务数量大于核心线程池的数量，如果此时线程队列中有空闲线程，那么执行器会读取一个空闲线程用于执行任务，否则会创建一个线程执行任务，直到线程总数超过 <code>maximumPoolSize</code>，新添加的任务将会触发线程池的饱和策略</li>
</ul>
</li>
</ul>
<p><code>Java</code> 中提供了如下四种任务队列：</p>
<ul>
<li><p><code>ArrayBlockingQueue</code>：基于数组的有界阻塞队列，按照 <code>FIFO</code> 排序任务</p>
</li>
<li><p><code>LinkedBlockingQuene</code>：基于链表结构的阻塞队列，按照 <code>FIFO</code> 排序任务，吞吐量通常要高于 <code>ArrayBlockingQueue</code></p>
</li>
<li><p><code>SynchronousQuene</code>：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 <code>LinkedBlockingQuene</code></p>
</li>
<li><p><code>PriorityBlockingQuene</code>：具有优先级的无界阻塞队列</p>
</li>
<li><p><code>handler</code>：线程池的饱和策略。如果线程池的任务队列已经饱和，而且没有空闲的线程用于处理任务，如果继续向该线程池提交任务，必须采取一种策略处理该任务。线程池提供了四种策略：</p>
<ul>
<li><code>AbortPolicy</code>：默认策略，抛出 <code>RejectedExecutionException</code> 运行时异常</li>
<li><code>CallerRunsPolicy</code>：提供了一个简单的反馈控制机制，可以减慢提交新任务的速度</li>
<li><code>DiscardPolicy</code>：直接丢弃新提交的任务</li>
<li><code>DiscardOldestPolicy</code>：如果执行器没有关闭，队列头的任务将会被丢弃，然后执行器重新尝试执行任务，如果失败，则重复这一过程</li>
</ul>
</li>
</ul>
<h2 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h2><p><code>ForkJoinPool</code> 是对 <code>Fork/Join</code> 并行框架的线程池封装。<code>ForkJoinPool</code> 的核心思想是将大的任务拆分成多个小的任务（即 <code>Fork</code>），然后将多个小任务处理汇总到一个结果上面（即 <code>Join</code>）。与 <code>ThreadPoolExecutor</code> 一样的，<code>ForkJoinPool</code> 提供基本的线程池功能。而且 <code>ForkJoinPool</code> 引入了<code>任务窃取</code>机制，在多 <code>CPU</code> 的设备上有更好的性能表现。</p>
<blockquote>
<p>关于 <code>Fork/Join</code> 框架，可以参考 <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html">The Java™ Tutorials Fork/Join</a>。</p>
</blockquote>
<p>通过 <code>Executors.newWorkStealingPool(int parallelism)</code> 可以创建一个基于 <code>ForkJoinPool</code> 线程池的 <code>ExecutorService</code> 对象。其中，<code>parallelism</code> 表示并行级别，通常情况下使用 <code>CPU</code> 的核心数即可。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ThreadPoolExecutor</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter 开发（01）：Dart 语言常用库索引</title>
    <url>/index.html//2019/dart-language-libraries.html</url>
    <content><![CDATA[<p>本文主要介绍 <code>Dart</code> 语言中常用的库，并不做详细介绍，只作为索引的目的。</p>
<p>本文中介绍的 <code>Dart</code> 语言特性是基于 <code>Dart 2.1.0</code>。</p>
<p><code>Dart</code> 中的库可以分为如下三种类型：</p>
<ul>
<li>核心库<ul>
<li><code>dart:dart:async</code>：支持异步编程的库，包含 <code>Future</code> 和 <code>Stream</code> 等类</li>
<li><code>dart:collection</code>：用于补充 <code>dart:core</code> 中各类集合框架的库</li>
<li><code>dart:convert</code>：支持数据类型转换、编码格式转换的库</li>
<li><code>dart:core</code>：<code>Dart</code> 内置库，包括常用的数据类型以及核心的定义</li>
<li><code>dart:developer</code>：支持开发调试的库，包含调试程序和检测程序</li>
<li><code>dart:math</code>：支持数学运算的库，包含数学常数、运算以及随机数生成器</li>
<li><code>dart:typed_data</code>：用于处理固定大小的数据（例如无符号8字节整数）和 <code>SIND</code> 类型的数据</li>
</ul>
</li>
<li><code>Web</code> 相关的库<ul>
<li><code>dart:html</code>：用于处理浏览器和 <code>DOM</code> 交互的库</li>
<li><code>dart:indexed_db</code>：支持基于的索引的 <code>k-v</code> 的数据库</li>
<li><code>dart:js</code>：用于支持 <code>JavaScript</code> 的库</li>
<li><code>dart:js_util</code>：支持 <code>JavaScript</code> 工具库</li>
<li><code>dart:svg</code>：支持 <code>SVG</code> 渲染的库</li>
<li><code>dart:web_audio</code>：支持音频开发的库</li>
<li><code>dart:web_gl</code>：支持 <code>Web GL</code> 渲染的库</li>
<li><code>dart:web_sql</code>：支持用于在浏览器存储可以使用 <code>SQL</code> 查询的数据的 API</li>
</ul>
</li>
<li>虚拟机相关的库<ul>
<li><code>dart:cli</code>：用于暂停堆栈、运行微服务、处理传入时间的库</li>
<li><code>dart:io</code>：用于在非 <code>Web</code> 应用中支持文件、<code>Socket</code>、<code>Http</code> 以及其他 <code>I/O</code> 的库</li>
<li><code>dart:isolate</code>：用于支持协程的库</li>
<li><code>dart:mirrors</code>：用于支持反射的库</li>
</ul>
</li>
</ul>
<p>本人中只对核心库和虚拟机相关的库做简单介绍。</p>
<span id="more"></span>

<h2 id="核心库"><a href="#核心库" class="headerlink" title="核心库"></a>核心库</h2><h3 id="dart-async"><a href="#dart-async" class="headerlink" title="dart:async"></a>dart:async</h3><p><img src="/images/dart_async_library.png" alt="dart_async_library.png"></p>
<h3 id="dart-collection"><a href="#dart-collection" class="headerlink" title="dart:collection"></a>dart:collection</h3><p><img src="/images/dart_collection_library.png" alt="dart_collection_library.png"></p>
<h3 id="dart-convert"><a href="#dart-convert" class="headerlink" title="dart:convert"></a>dart:convert</h3><p><img src="/images/dart_convert_library.png" alt="dart_convert_library.png"></p>
<h3 id="dart-core"><a href="#dart-core" class="headerlink" title="dart:core"></a>dart:core</h3><p><img src="/images/dart_core_library.png" alt="dart_core_library.png"></p>
<h3 id="dart-developer"><a href="#dart-developer" class="headerlink" title="dart:developer"></a>dart:developer</h3><p><img src="/images/dart_developer_library.png" alt="dart_developer_library.png"></p>
<h3 id="dart-math"><a href="#dart-math" class="headerlink" title="dart:math"></a>dart:math</h3><p><img src="/images/dart_math_library.png" alt="dart_math_library.png"></p>
<h3 id="dart-typed-data"><a href="#dart-typed-data" class="headerlink" title="dart:typed_data"></a>dart:typed_data</h3><p><img src="/images/dart_typed_data_library.png" alt="dart_typed_data_library.png"></p>
<h2 id="虚拟机相关的库"><a href="#虚拟机相关的库" class="headerlink" title="虚拟机相关的库"></a>虚拟机相关的库</h2><h3 id="dart-cli"><a href="#dart-cli" class="headerlink" title="dart:cli"></a>dart:cli</h3><p><img src="/images/dart_cli_library.png" alt="dart_cli_library.png"></p>
<h3 id="dart-io"><a href="#dart-io" class="headerlink" title="dart:io"></a>dart:io</h3><p><img src="/images/dart_io_library.png" alt="dart_io_library.png"></p>
<h3 id="dart-isolate"><a href="#dart-isolate" class="headerlink" title="dart:isolate"></a>dart:isolate</h3><p><img src="/images/dart_isolate_library.png" alt="dart_isolate_library.png"></p>
<h3 id="dart-mirrors"><a href="#dart-mirrors" class="headerlink" title="dart:mirrors"></a>dart:mirrors</h3><p><img src="/images/dart_mirrors_library.png" alt="dart_mirrors_library.png"></p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Dart 常用库索引</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter 开发（03）：Http 请求</title>
    <url>/index.html//2019/flutter-http-request.html</url>
    <content><![CDATA[<p>本文主要介绍 <code>Flutter</code> 项目中的 <code>Http</code> 网络请求。本文介绍的重点是，<code>Flutter</code> 对 <code>dart:io</code> 库中的 <code>HttpClient</code> 的使用，以及开源 <code>Flutter</code> 网络请求库 <a href="https://github.com/dart-lang/http">package:http/http.dart</a> 的使用。</p>
<p>本文介绍的所有特性是基于 <code>Flutter V1.0.0</code> 以及 <code>Dart V2.1.0</code>。</p>
<p>由于 <code>dart:io</code> 库对于 <code>POST</code> 请求支持不好，本文中只简单介绍了使用 <code>dart:io</code> 库发起 <code>GET</code> 请求的情况。<code>http/http.dart</code> 库我们也只介绍 <code>GET</code> 请求和 <code>POST</code> 请求的使用，对于其他类型的情况，可参考官方文档。</p>
<p><code>dio/dio.dart</code> 库也是非常优秀的 <code>Http</code> 请求库，如果对其感兴趣，请移步项目地址：<a href="https://github.com/flutterchina/dio">dio/dio.dart</a>。</p>
<span id="more"></span>
<h2 id="dart-io"><a href="#dart-io" class="headerlink" title="dart:io"></a>dart:io</h2><p>如果使用 <code>HttpClient</code>，需要我们导入 <code>dart:io</code> 库：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:io&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>导入 <code>dart:io</code> 库之后，我们可以使用 <code>new</code> 关键字创建 <code>HttpClient</code> 的实例对象：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient();</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>HttpClient</code> 的构造函数支持一个可选的 <code>SecurityContext</code> 参数。</p>
</blockquote>
<p>使用 <code>HttpClient</code> 发送请求之前，需要先使用 <code>Uri</code> 构建请求的 <code>Uri</code> 对象。以 <code>http://tj.nineton.cn/Heart/index/all?city=CHSH000000&amp;language=zh-chs</code> 请求接口为例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Uri</span> uri = <span class="keyword">new</span> <span class="built_in">Uri</span>.http(<span class="string">&#x27;tj.nineton.cn&#x27;</span>, <span class="string">&#x27;/Heart/index/all&#x27;</span>, &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;CHSH000000&#x27;</span>, <span class="string">&#x27;language&#x27;</span>: <span class="string">&#x27;zh-chs&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>最终，使用 <code>HttpClient</code> 发起请求的完整示例如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">httpRequestGet() <span class="keyword">async</span> &#123;</span><br><span class="line">  HttpClient client = <span class="keyword">new</span> HttpClient();</span><br><span class="line">  <span class="keyword">var</span> authority = <span class="string">&#x27;tj.nineton.cn&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> unencodedPath = <span class="string">&#x27;/Heart/index/all&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> params = &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;CHSH000000&#x27;</span>, <span class="string">&#x27;language&#x27;</span>: <span class="string">&#x27;zh-chs&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Uri</span> uri = <span class="keyword">new</span> <span class="built_in">Uri</span>.http(authority, unencodedPath, params);</span><br><span class="line">  <span class="keyword">var</span> request = <span class="keyword">await</span> client.getUrl(uri);</span><br><span class="line">  <span class="keyword">var</span> response = <span class="keyword">await</span> request.close();</span><br><span class="line">  <span class="keyword">if</span> (response.statusCode == HttpStatus.ok) &#123;</span><br><span class="line">    <span class="keyword">var</span> responseMessage = <span class="keyword">await</span> response.transform(Utf8Decoder()).join();</span><br><span class="line">    <span class="built_in">print</span>(responseMessage);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(response.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于使用了 <code>response.transform(Utf8Decoder())</code> 方法，需要导入 <code>dart:convert</code> 库。</p>
</blockquote>
<h2 id="http-http-dart"><a href="#http-http-dart" class="headerlink" title="http/http.dart"></a>http/http.dart</h2><p><a href="https://github.com/dart-lang/http">package:http/http.dart</a> 是一个开源的基于 <code>Flutter</code> 的网络请求框架。</p>
<p>使用 <code>http/http.dart</code> 库之前，我们需要先在 <code>pubspec.yaml</code> 文件中添加改库的依赖：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">http:</span> <span class="string">^0.12.0+1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>目前最新版为 <code>0.12.0+1</code>。更多信息请参考项目主页。</p>
</blockquote>
<p>然后在项目的根目录使用如下命令安装该库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flutter packages get</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果使用 <code>pub</code> 工具，可以使用 <code>pub get</code> 命令。</p>
</blockquote>
<p>最后，在项目中需要使用的地方引入该库：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:http/http.dart&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>或者使用别名的引用方式：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:http/http.dart&#x27;</span> <span class="keyword">as</span> http;</span><br></pre></td></tr></table></figure>

<p>个人建议使用第二种方式进行引入（该章节的示例程序都默认使用了第二种引入方式）。</p>
<h3 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h3><p>以 <code>http://tj.nineton.cn/Heart/index/all?city=CHSH000000&amp;language=zh-chs</code> 为例，使用 <code>http/http.dart</code> 发送 <code>GET</code> 请求的实例代码如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">httpRequestGet() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> url = <span class="string">&#x27;http://tj.nineton.cn/Heart/index/all?city=CHSH000000&amp;language=zh-chs&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> client = http.Client();</span><br><span class="line">  http.Response response = <span class="keyword">await</span> client.<span class="keyword">get</span>(url);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (response.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> responseMessage = response.body;</span><br><span class="line">    <span class="built_in">print</span>(responseMessage);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者使用如下方式：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">httpRequestGet() &#123;</span><br><span class="line">  <span class="keyword">var</span> url = <span class="string">&#x27;http://tj.nineton.cn/Heart/index/all?city=CHSH000000&amp;language=zh-chs&#x27;</span>;</span><br><span class="line">  http.Client().<span class="keyword">get</span>(url).then((http.Response response) &#123;</span><br><span class="line">    <span class="keyword">if</span> (response.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> responseMessage = response.body;</span><br><span class="line">      <span class="built_in">print</span>(responseMessage);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h3><p>与 <code>GET</code> 请求不同的是，<code>POST</code> 请求需要将数据写入到 <code>body</code> 里面：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">httpRequestPost() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> url = <span class="string">&quot;request_url&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> params = <span class="keyword">new</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;();</span><br><span class="line">  params[<span class="string">&#x27;param_1&#x27;</span>] = <span class="string">&quot;value_1&quot;</span>;</span><br><span class="line">  params[<span class="string">&#x27;param_2&#x27;</span>] = <span class="string">&quot;value_2&quot;</span>;</span><br><span class="line">  params[<span class="string">&#x27;param_3&#x27;</span>] = <span class="string">&quot;value_3&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> client = http.Client();</span><br><span class="line">  http.Response response = <span class="keyword">await</span> client.post(url, body: params);</span><br><span class="line">  <span class="keyword">if</span> (response.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> responseMessage = response.body;</span><br><span class="line">    <span class="built_in">print</span>(responseMessage);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，上述请求也可以使用如下代码实现：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">httpRequestPost() &#123;</span><br><span class="line">   <span class="keyword">var</span> url = <span class="string">&quot;request_url&quot;</span>;</span><br><span class="line">   <span class="keyword">var</span> params = <span class="keyword">new</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;();</span><br><span class="line">   params[<span class="string">&#x27;param_1&#x27;</span>] = <span class="string">&quot;value_1&quot;</span>;</span><br><span class="line">   params[<span class="string">&#x27;param_2&#x27;</span>] = <span class="string">&quot;value_2&quot;</span>;</span><br><span class="line">   params[<span class="string">&#x27;param_3&#x27;</span>] = <span class="string">&quot;value_3&quot;</span>;</span><br><span class="line">   http.Client().post(url, body: params).then((http.Response response) &#123;</span><br><span class="line">     <span class="keyword">if</span> (response.statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">       <span class="keyword">var</span> responseMessage = response.body;</span><br><span class="line">       <span class="built_in">print</span>(responseMessage);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter Http</tag>
        <tag>http.dart</tag>
        <tag>dart:io</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter 开发（02）：Flutter 开发环境的搭建（macOS）</title>
    <url>/index.html//2019/fluuter-macos-environemnt-setup.html</url>
    <content><![CDATA[<p>本文主要介绍 <code>macOS</code> 下 <code>Flutter</code> 开发环境的搭建。由于肥肥主要从事 <code>Android SDK</code> 开发，故本文中一些内容仅围绕 <code>Android</code> 展开。</p>
<p><code>Android</code> 和 <code>iOS</code> 开发环境的搭建不在本文的讨论范围。</p>
<p>本文基于 <code>Flutter V1.0.0</code> 展开讨论。</p>
<span id="more"></span>
<h2 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h2><p>如果需要安装运行 <code>Flutter</code>，那么您的设备应该满足如下最低要求：</p>
<ul>
<li><code>64-bit</code> 的 <code>macOS</code></li>
<li>不少于 <code>700M</code> 的磁盘可用空间</li>
<li>已经正常安装 <code>AndroidStudio</code> 或 <code>IntelliJ IDEA</code> 和 <code>XCode</code></li>
<li>已经正常安装如下命令行工具：<ul>
<li><code>bash</code></li>
<li><code>mkdir</code></li>
<li><code>rm</code></li>
<li><code>git</code></li>
<li><code>curl</code></li>
<li><code>unzip</code></li>
<li><code>which</code></li>
<li>可能会需要使用 <code>brew</code></li>
</ul>
</li>
</ul>
<p>需要注意的是，畅通的网络环境是 <code>Flutter</code> 开发必不可少的。</p>
<h2 id="获取并安装-Flutter-SDK"><a href="#获取并安装-Flutter-SDK" class="headerlink" title="获取并安装 Flutter SDK"></a>获取并安装 Flutter SDK</h2><h3 id="下载-Flutter-SDK"><a href="#下载-Flutter-SDK" class="headerlink" title="下载 Flutter SDK"></a>下载 Flutter SDK</h3><p>我们可以在 <code>Flutter</code> 官网的 <a href="https://flutter.dev/docs/development/tools/sdk/archive?tab=macos#macos">Flutter SDK archive</a> 获取最新的 <code>Flutter SDK</code>。</p>
<p>目前最新的 <code>Flutter SDK</code> 为 <code>V1.0.0</code> 版本。您可以直接点击 <a href="https://storage.googleapis.com/flutter_infra/releases/stable/macos/flutter_macos_v1.0.0-stable.zip">下载 Flutter SDK V1.0.0 Stable for macOS</a> 来下载官方的 <code>Flutter SDK</code> 版本，也可以通过点击 <a href="https://pan.baidu.com/s/1f7es65Kyg2RMb2aVEHErFw">下载 Flutter SDK V1.0.0 Stable for macOS</a> 从百度网盘进行下载。</p>
<p><code>Github</code> 上也托管了 <code>Flutter SDK</code>，我们也可以在 <a href="https://github.com/flutter/flutter/releases">flutter/flutter release</a> 上下载对应的安装包。</p>
<p>如果上述官方下载地址均无法访问，请使用 <code>Google</code> 为国内用户部署的镜像服务下载。<a href="https://https//flutter-io.cn/flutter_infra/releases/stable/macos/flutter_macos_v1.0.0-stable.zip">点击使用国内镜像下载 Flutter SDK V1.0.0 Stable for macOS</a>。</p>
<p><code>Flutter</code> 国内镜像的地址为 <a href="https://flutter-io.cn/">https://flutter-io.cn</a>。</p>
<p>如果在后续使用 <code>Flutter</code> 的过程中由于网络而造成的问题，比如执行 <code>flutter doctor</code> 时无法访问网络，或者创建 <code>Flutter</code> 项目时一直处于 <code>create flutter project</code> 过程中，那么请尝试使用代理或者在 <code>.bash_profile</code> 文件中做如下配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PUB_HOSTED_URL=https://pub.flutter-io.cn</span><br><span class="line">export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</span><br></pre></td></tr></table></figure>

<h3 id="解压缩-Flutter-SDK"><a href="#解压缩-Flutter-SDK" class="headerlink" title="解压缩 Flutter SDK"></a>解压缩 Flutter SDK</h3><p>在下载好 <code>Flutter SDK</code> 之后，我们需要将 <code>Flutter SDK</code> 解压缩：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unzip flutter_macos_v1.0.0-stable.zip</span><br></pre></td></tr></table></figure>

<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>第一步，打开 <code>.bash_profile</code> 文件（路径通常是 <code>~/.bash_profile</code>）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure>

<p>第二步，在 <code>.bash_profile</code> 文件的末尾添加如下字段：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=PATH_TO_FLUTTER_GIT_DIRECTORY/flutter/bin:$PATH</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">其中，`PATH_TO_FLUTTER_GIT_DIRECTORY` 为你的 `Flutter SDK` 安装路径。</span><br><span class="line"></span><br><span class="line">保存并退出编辑器。</span><br><span class="line"></span><br><span class="line">第三步，执行如下命令刷新环境变量：</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果使用 <code>zsh</code> 终端，请在 <code>~/.zshrc</code> 文件的末尾添加 <code>source ~/.bash_profile</code>。</p>
</blockquote>
<h3 id="运行-flutter-doctor"><a href="#运行-flutter-doctor" class="headerlink" title="运行 flutter doctor"></a>运行 flutter doctor</h3><p>运行如下命令查看是否需要安装其他依赖项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flutter doctor</span><br></pre></td></tr></table></figure>

<p>该命令会对设备的环境进行检测并最终显示一份检测结果。请仔细阅读错误提示并按照要求进行安装。下图显示了检测通过之后的最终输出：</p>
<p><img src="/images/flutter-doctor-result.jpg" alt="flutter-doctor-result.jpg"></p>
<blockquote>
<p>由于肥肥使用 <code>IntelliJ IDEA</code> 进行 <code>Android</code> 开发，故而忽略 <code>Android Studio</code> 未安装的提示。</p>
</blockquote>
<h3 id="安装插件（Android-环境）"><a href="#安装插件（Android-环境）" class="headerlink" title="安装插件（Android 环境）"></a>安装插件（Android 环境）</h3><p>无论使用 <code>Android Studio</code> 还是 <code>IntelliJ IDEA</code>，都需要安装 <code>Dart</code> 插件和 <code>Flutter</code> 插件。</p>
<p><code>Dart</code> 插件的作用是提供对 <code>Dart</code> 语言的基础支持，<code>Flutter</code> 插件则提供对 <code>Flutter</code> 开发的支持。</p>
<p>安装插件的具体方案请参考 <code>Android Studio</code> 或 <code>IntelliJ IDEA</code> 对安装插件的介绍。</p>
<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>选择 <code>File &gt; New Flutter Project &gt; Flutter application </code>，输入项目名称（比如 <code>flutter_sample</code>），最终可以创建一个 <code>Flutter</code> 项目:</p>
<p><img src="/images/flutter-sample-project.jpg" alt="flutter-sample-project.jpg"></p>
<p>其中，<code>android</code> 目录是是配到 <code>Android</code> 设备的项目，<code>ios</code> 目录是是配到 <code>iOS</code> 设备的项目，<code>lib</code> 目录是我们编写的 <code>Dart</code> 代码的目录。</p>
<blockquote>
<p>与纯粹的 <code>Android</code> 开发不同的是，在 <code>Android Studio</code> 中也可以将项目部署到 <code>iOS</code>。</p>
</blockquote>
<p>此时，点击 <code>Run</code> 运行项目，编译部署之后，我们可以看到默认的 <code>Flutter</code> 项目的界面。</p>
<h3 id="Flutter-项目的热重载"><a href="#Flutter-项目的热重载" class="headerlink" title="Flutter 项目的热重载"></a>Flutter 项目的热重载</h3><p><code>Flutter</code> 可以通过热重载实现快速的开发周期，热重载的目的是无需重启应用程序就能实时加载修改后的代码，并且不会丢失状态：</p>
<ul>
<li>在应用运行之后，不要点击 <code>Stop</code> 结束运行</li>
<li>修改相应的代码</li>
<li>调用 <code>Sava All</code>（保存）或者点击热重载按钮（⚡️）</li>
</ul>
<p>之后，应用程序会立刻更新为我们修改完之后的状态。</p>
<p>热重载技术是通过将最新的源代码文件注入到正在运行的 <code>Dart VM</code> 中来实现的。这个过程不仅仅支持修改字符串内容，还支持添加新的类、新的方法和字段以及更新现有的方法。但是需要注意的是，如下几种类型的更改无法通过热更新的方式实现：</p>
<ul>
<li>全局变量的初始化</li>
<li>静态字段的初始化</li>
<li><code>main()</code> 应用程序的方法</li>
</ul>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter 环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter 开发（04）：Flutter 中使用文件（dart:io）</title>
    <url>/index.html//2019/flutter-use-file-by-dart-io.html</url>
    <content><![CDATA[<p>本文主要介绍 <code>Flutter</code> 中针对文件的操作，主要目的是掌握使用 <code>dart:io</code> 库相关方法操作文件。</p>
<p>本文是基于 <code>Dart V2.1.0</code> 和 <code>Flutter V1.0.0</code> 版本进行的介绍。</p>
<p><code>Flutter</code> 操作文件的类主要涉及到：</p>
<ul>
<li><code>Directory</code>：用于操作文件目录</li>
<li><code>File</code>： 用于操作文件</li>
<li><code>Stream</code>：用于接收数据流（<code>dart:async</code> 库）</li>
</ul>
<p>如果要使用 <code>dart:io</code> 库，我们需要在使用的位置导入：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:io&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果需要使用到 <code>Stream</code>，那么还需要导入：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:async&#x27;</span>;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><code>Flutter</code> 中使用 <code>Directory</code> 类表示文件目录。</p>
<p>我们可以通过如下代码创建一个 <code>Directory</code> 对象：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> directory = <span class="keyword">new</span> Directory(<span class="string">&quot;test_directory&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>需要注意的是，我们必须指定一个确切的路径参数给 <code>Directory</code>。</p>
<p>我们可以通过使用 <code>directory.exists()</code> 来判断该目录是否存在。<code>directory.exists()</code> 是一个异步方法，需要使用 <code>await</code> 修饰。</p>
<h3 id="创建和删除目录"><a href="#创建和删除目录" class="headerlink" title="创建和删除目录"></a>创建和删除目录</h3><p>如果目录不存在，我们可以使用如下方法创建目录：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> directory.create();</span><br></pre></td></tr></table></figure>

<p><code>create</code> 方法有一个可选的 <code>recursive</code> 参数。其作用是，如果 <code>recursive</code> 为 <code>false</code>，那么只创建目录中最后一个文件夹，如果为 <code>true</code>，则会创建整个目录中所有不存在的文件夹。</p>
<p>我们也可以使用如下方式创建目录，从而省略 <code>await</code> 关键字：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">directory.createSync();</span><br></pre></td></tr></table></figure>

<p>如果我们需要删除某个目录，可以使用 <code>delete</code> 方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> directory.delete();</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">directory.deleteSync();</span><br></pre></td></tr></table></figure>

<p>与 <code>create</code> 方法一样，<code>delete</code> 方法也有一个可选的 <code>recursive</code>（默认 <code>false</code>） 参数。其作用是，如果 <code>recursive</code> 为 <code>true</code>，即使 <code>FileSystemEntity</code> 不匹配也会删除。</p>
<h3 id="重命名目录"><a href="#重命名目录" class="headerlink" title="重命名目录"></a>重命名目录</h3><p>可以使用 <code>rename</code> 方法对目录进行重命名：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> directory.rename(<span class="string">&quot;new_directory_name&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">directory.renameSync(<span class="string">&quot;new_directory_name&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="获取目录文件列表"><a href="#获取目录文件列表" class="headerlink" title="获取目录文件列表"></a>获取目录文件列表</h3><p>使用 <code>list</code> 可以列出该目录下的所有文件：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> directory.list();</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">directory.listSync();</span><br></pre></td></tr></table></figure>

<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p><code>Flutter</code> 中使用 <code>File</code> 类表示文件。我们可以使用如下代码创建一个 <code>File</code> 对象：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> file = <span class="keyword">new</span> File(<span class="string">&quot;file_name&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>同样的，我们可以通过 <code>exists</code> 方法判断文件是否存在：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> file.exists();</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">file.existsSync();</span><br></pre></td></tr></table></figure>

<h3 id="创建和删除文件"><a href="#创建和删除文件" class="headerlink" title="创建和删除文件"></a>创建和删除文件</h3><p>如果文件不存在，我们可以使用如下方法创建文件：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> file.create();</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">file.createSync();</span><br></pre></td></tr></table></figure>

<p>与 <code>Directory</code> 相同的，<code>File</code> 的 <code>create</code> 方法也支持一个名为 <code>recursive</code> 可选参数。该参数如果为 <code>false</code>，则只创建文件，如果为 <code>true</code>，则会把不存在的文件夹也一起创建。</p>
<p>我们可以使用 <code>delete</code> 方法删除文件：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> file.delete();</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">file.deleteSync();</span><br></pre></td></tr></table></figure>

<h3 id="读取和写入文件"><a href="#读取和写入文件" class="headerlink" title="读取和写入文件"></a>读取和写入文件</h3><p>相较于 <code>Java</code>，<code>Flutter</code> 中读写文件相对容易。</p>
<p>通过 <code>writeAsString</code> 方法实现 <code>String</code> 对象的写入：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> file.writeAsString(<span class="string">&quot;hello word!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>同样的，可以通过 <code>readAsStringSync</code> 方法将文件内容读取为 <code>String</code> 对象：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fileMessage = <span class="keyword">await</span> file.readAsString();</span><br></pre></td></tr></table></figure>

<h3 id="文件的复制"><a href="#文件的复制" class="headerlink" title="文件的复制"></a>文件的复制</h3><p><code>File</code> 类中提供了 <code>copy</code> 方法用于文件的复制操作：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> file.copy(<span class="string">&quot;new_file_path&quot;</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter 文件</tag>
        <tag>path_provider/path_provider.dart</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter 开发（05）：Flutter 中使用文件（path_provider.dart）</title>
    <url>/index.html//2019/flutter-use-file-by-pathprovider.html</url>
    <content><![CDATA[<p>本文主要介绍 <code>Flutter</code> 中 <code>Android</code> 和 <code>iOS</code> 两个平台下文件存储位置，主要目的是掌握 <code>Flutter</code> 官方开源项目 <a href="https://github.com/flutter/plugins/tree/master/packages/path_provider">path_provider/path_provider.dart</a> 的使用。</p>
<p>使用 <code>path_provider.dart</code> 库之前，需要先在 <code>pubspec.yaml</code> 文件的 <code>dependencies:</code> 中添加如下依赖：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">path_provider: ^<span class="number">0.5</span><span class="number">.0</span>+<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>然后在项目的根目录中使用如下命令更新依赖：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">flutter packages <span class="keyword">get</span></span><br></pre></td></tr></table></figure>

<p>最后，在项目中需要使用的地方引入该库：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:path_provider/path_provider.dart&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="使用-path-provider-dart"><a href="#使用-path-provider-dart" class="headerlink" title="使用 path_provider.dart"></a>使用 path_provider.dart</h2><p><code>path_provider.dart</code> 库屏蔽了 <code>Android</code> 和 <code>iOS</code> 两个平台上文件存储路径的差异。<code>path_provider.dart</code> 库主要提供了如下几个方法用于获取存储路径：</p>
<ul>
<li><code>getTemporaryDirectory()</code>：获取临时文件夹，针对于 <code>Android</code> 设备 <code>getCacheDir()</code> 和 <code>iOS</code> 设备 <code>NSTemporaryDirectory()</code> 返回的值</li>
<li><code>getApplicationDocumentsDirectory()</code>：获取 <code>Document</code> 文件夹，针对 <code>Android</code> 设备的 <code>AppDate</code> 目录，<code>iOS</code> 设备的 <code>NSDocumentDirectory</code> 目录</li>
<li><code>getExternalStorageDirectory()</code>： 获取存储卡目录，只有 <code>Android</code> 设备可用</li>
</ul>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter 文件</tag>
        <tag>path_provider</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter 开发（06）：Flutter 中 SharedPreference</title>
    <url>/index.html//2019/flutter-sharedpreference-by-shared-preference.html</url>
    <content><![CDATA[<p>本文主要介绍 <code>Flutter</code> 上 <code>SharedPreference</code> 的使用，其目的是介绍 <code>shared_preferences.dart</code> 库的使用。<a href="https://github.com/flutter/plugins/tree/master/packages/shared_preferences">shared_preferences.dart</a> 官方开源的轻量级数据存储库，并且屏蔽了 <code>Android</code> 和 <code>iOS</code> 平台上使用 <code>K-V</code> 型数据的差异。</p>
<p>使用 <code>shared_preferences.dart</code> 前需要添加配置并更新依赖：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">shared_preferences: ^<span class="number">0.5</span><span class="number">.1</span>+<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>然后，在需要使用该库的地方引入该库：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:shared_preferences/shared_preferences.dart&#x27;</span>;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="初始化-SharedPreferences"><a href="#初始化-SharedPreferences" class="headerlink" title="初始化 SharedPreferences"></a>初始化 SharedPreferences</h2><p>使用如下代码可以初始化 <code>SharedPreferences</code> 对象：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">SharedPreferences sharedPreferences = <span class="keyword">await</span> SharedPreferences.getInstance();</span><br></pre></td></tr></table></figure>

<h2 id="读写数据"><a href="#读写数据" class="headerlink" title="读写数据"></a>读写数据</h2><p>获取到 <code>SharedPreferences</code> 对象之后，我们可以通过一系列的 <code>get</code> 和 <code>set</code> 方法读写数据。目前 <code>shared_preferences.dart</code> 库支持的数据类型有：</p>
<ul>
<li><code>bool</code>：布尔型数据，对应 <code>getBool</code> 和 <code>setBool</code> 两个方法</li>
<li><code>int</code>：<code>int</code> 型数据，对应 <code>getInt</code> 和 <code>setInt</code> 两个方法</li>
<li><code>double</code>：<code>double</code> 型数据，对应 <code>getDouble</code> 和 <code>setDouble</code> 两个方法</li>
<li><code>String</code>：<code>String</code> 型数据，对应 <code>getString</code> 和 <code>setString</code> 两个方法</li>
<li><code>List&lt;String&gt;</code>：<code>List&lt;String&gt;</code> 型数据，对用 <code>getStringList</code> 和 <code>setStringList</code> 两个方法</li>
</ul>
<p>下面是写入数据的示例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="keyword">await</span> sharedPreferences.setString(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>下面是读取数据的示例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> result = sharedPreferences.getString(<span class="string">&quot;key&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>需要注意的是，读取操作并不需要使用 <code>await</code>。</p>
<h2 id="清空数据"><a href="#清空数据" class="headerlink" title="清空数据"></a>清空数据</h2><p><code>SharedPreferences</code> 中提供了 <code>remove</code> 方法用来删除特定 <code>key</code> 的数据，以及 <code>clear</code> 方法用于删除所有的数据:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> sharedPreferences.remove(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"><span class="keyword">await</span> sharedPreferences.clear();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter SharedPreference</tag>
        <tag>shared_preferences.dart</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter 开发（10）：Flutter 的运行模式</title>
    <url>/index.html//2019/flutter-running-mode.html</url>
    <content><![CDATA[<p>本文主要是对 <code>Flutter</code> 的基本框架进行介绍。本文主要参考了 <a href="https://tech.meituan.com/2018/08/09/waimai-flutter-practice.html">美团技术团队-Flutter 原理与实践</a> 一文。<a href="https://tech.meituan.com/2018/08/09/waimai-flutter-practice.html">美团技术团队-Flutter 原理与实践</a> 是一篇非常优秀的介绍 <code>Flutter</code> 原理的文章。</p>
<p><code>Flutter</code> 的设计目标是高性能的跨平台的（<code>Android</code> 和 <code>iOS</code>）<code>UI</code> 框架。与传统的基于 <code>WebView</code> 的（例如 <code>Cordova</code> 或者 <code>AppCan</code> 等框架）或者基于原生控件系统的（例如 <code>React Native</code>）跨平台开发框架所不同的是，<code>Flutter</code> 是基于跨平台的渲染引擎 <code>Skia</code> 来实现的全新的跨平台的开发框架。这也就是说，<code>Flutter</code> 对于设备平台的依赖只有图形渲染相关的部分，这在一定程度上保证了不同平台、不同设备上的一致的用户体验。从执行效率的角度来说，<code>Flutter</code> 使用的 <code>Dart</code> 语言相较于其他大多数跨平台开发框架使用的 <code>JavaScript</code> 语言在执行效率上高效很多。</p>
<span id="more"></span>
<h2 id="Flutter-架构"><a href="#Flutter-架构" class="headerlink" title="Flutter 架构"></a>Flutter 架构</h2><p><code>Flutter</code> 的架构主要由三部分组成：</p>
<ul>
<li><code>Framework</code> 层</li>
<li><code>Engine</code> 层</li>
<li><code>Embedder</code> 层</li>
</ul>
<p><img src="http://www.techug.com/wordpress/wp-content/uploads/2018/07/66372-20180706175503147-184515056.jpg" alt="Flutter 架构"></p>
<h3 id="Framework-层"><a href="#Framework-层" class="headerlink" title="Framework 层"></a>Framework 层</h3><p><code>Flutter</code> 的 <code>Framework</code> 层使用 <code>Dart</code> 语言实现，包括了 <code>Material Design</code> （针对于 <code>Android</code> 平台）和 <code>Cupertino</code> （对于 <code>iOS</code> 平台）两种风格的文本、图片、按钮等基础 <code>Widget</code>、以及动画、手势处理和渲染引擎等模块。这一部分的源代码对应的是 <code>Flutter</code> 仓库下的 <a href="https://github.com/flutter/flutter/tree/master/packages">flutter/packages/</a> <code>Flutter</code> 包以及 <a href="https://github.com/flutter/engine/tree/master/sky/packages/sky_engine">engine/sky/packages/sky_engine/</a> 仓库下的 <code>io</code>、<code>async</code> 和 <code>ui</code> 等 <code>package</code>。</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/9924fbed.png"></p>
<p><code>Flutter</code> 提供了非常丰富的控件，通过对不同类型的控件的嵌套和组合，我们可以方便的构建出任意功能、任意复杂度的界面。与其他将控件、控制器、布局以及其他属性分离开的框架不同的是，<code>Flutter</code> 提供了统一的对象模型：<code>Widget</code>。</p>
<p><code>Widget</code> 本身由许多更小的、功能单一的 <code>Widget</code> 组成。</p>
<h3 id="Engine-层"><a href="#Engine-层" class="headerlink" title="Engine 层"></a>Engine 层</h3><p><code>Flutter</code> 的 <code>Engine</code> 层主要包含 <code>Skia</code>、<code>Dart</code> 和 <code>Text</code> 三部分。<code>Engine</code> 主要使用 <code>C/C++</code> 开发。</p>
<p><code>Skia</code> 是开源的二维图形渲染库，提供了适用于多种平台的通用 <code>API</code>。</p>
<p><code>Dart</code> 主要包括 <code>Dart Runtime</code>、<code>Garbage Collection</code>，如果是 <code>Debug</code> 模式的话，该部分还提供了对 <code>JIT</code>（<code>Just In Time</code>）的支持。<code>Release</code> 和 <code>Profile</code> 模式下，是通过 <code>AOT</code>（<code>Ahead of Time</code>）编译成了原生代码，并不包含 <code>JIT</code> 部分。</p>
<p><code>Text</code> 是文本渲染库。<code>Android</code> 上使用 <code>FreeType</code> 渲染，<code>iOS</code>上使用 <code>CoreGraphics</code> 进行渲染。</p>
<h3 id="Embedder-层"><a href="#Embedder-层" class="headerlink" title="Embedder 层"></a>Embedder 层</h3><p><code>Embedder</code> 层主要包含 <code>Surface</code>、线程以及插件等，是 <code>Flutter</code> 的嵌入层，主要负责把 <code>Flutter</code> 嵌入到各个平台上。</p>
<h2 id="Flutter-的运行模式"><a href="#Flutter-的运行模式" class="headerlink" title="Flutter 的运行模式"></a>Flutter 的运行模式</h2><p><code>Flutter</code> 提供了四种运行模式：</p>
<ul>
<li><code>Debug</code> 模式</li>
<li><code>Release</code> 模式</li>
<li><code>Profile</code> 模式</li>
<li><code>Test</code> 模式</li>
</ul>
<p>上述四种模式在 <code>Flutter</code> 编译时是完全独立的。</p>
<h3 id="Debug-模式"><a href="#Debug-模式" class="headerlink" title="Debug 模式"></a>Debug 模式</h3><p><code>Debug</code> 模式可以在真机和模拟器上运行。该模式会打开所有的断言（包括 <code>debugging</code> 信息、<code>debugger aida</code> 和服务扩展），优化了快速 <code>develop/run</code> 循环，但是没有优化执行速度、二进制文件和部署。<code>Android Studio</code> 的 <code>run</code> 命令或者 <code>flutter run</code> 命名都是以该模式运行应用程序的。对应的编译命令为 <code>sky/tools/gn --android</code> 或者  <code>sky/tools/gn --ios</code>。</p>
<h3 id="Release-模式"><a href="#Release-模式" class="headerlink" title="Release 模式"></a>Release 模式</h3><p><code>Release</code> 模式只能在真机中运行，不能在模拟器中运行。该模式会关闭所有的断言（包括 <code>debugging</code> 信息、<code>debugger aida</code> 和服务扩展），优化启动速度并减少包体积。该模式是为了部署应用程序给最终的用户使用的。使用 <code>flutter run --release</code> 命令可以让应用程序在该模式下运行。对应的编译命令为 <code>sky/tools/gn --android --runtime-mode=release</code> 或者 <code>sky/tools/gn --ios --runtime-mode=release</code>。</p>
<h3 id="Profile-模式"><a href="#Profile-模式" class="headerlink" title="Profile 模式"></a>Profile 模式</h3><p><code>Profile</code> 模式只能在真机上运行，不能在模拟器中运行。该模式除了启用了服务扩展和 <code>tracing</code>（包含一些最低限度支持 <code>tracing</code> 运行的功能），其他方面和 <code>Release</code> 模式是一样的。使用 <code>flutter run --profile</code> 命令可以应用程序在该模式下运行。对应的编译命令为 <code>sky/tools/gn --android --runtime-mode=profile</code> 或者 <code>sky/tools/gn --ios --runtime-mode=profile</code>。</p>
<h3 id="Test-模式"><a href="#Test-模式" class="headerlink" title="Test 模式"></a>Test 模式</h3><p><code>Test</code> 模式只能在桌面上运行，与 <code>Debug</code> 模式基本上一样。</p>
<h2 id="Flutter-应用程序运行机制"><a href="#Flutter-应用程序运行机制" class="headerlink" title="Flutter 应用程序运行机制"></a>Flutter 应用程序运行机制</h2><p>在 <code>Android</code> 系统上，<code>Flutter</code> 构建出的 <code>APK</code> 在运行时会将所有 <code>assets</code> 目录下的资源文件解压到应用程序私有文件目录中的 <code>flutter</code> 目录下，主要包括处理字符编码的 <code>icudtl.dat</code>，以及 <code>Debug</code> 模式的 <code>kernel_blob.bin</code>、<code>platform.dill</code> 和 <code>Release</code> 模式下的4个 <code>snapshot</code> 文件。</p>
<p>默认情况下，<code>Flutter</code> 在 <code>Application</code> 的 <code>onCreate</code> 时调用 <code>FlutterMain</code> 的 <code>startInitialization</code> 方法来启动解压任务，然后在 <code>FlutterActivityDelegate</code> 的 <code>onCreate</code> 中调用 <code>FlutterMain</code> 的 <code>ensureInitializationComplete</code> 等待解压任务结束。</p>
<p><code>Flutter</code> 在 <code>Debug</code> 模式下使用 <code>JIT</code> 编译方式，主要是为了支持热加载功能：</p>
<p><img src="https://p1.meituan.net/travelcube/89aa7ce412124d5618877589b07f115426247.png"></p>
<p>触发热加载时 <code>Flutter</code> 会检测发生改变的 <code>Dart</code> 文件，将其同步到应用程序私有缓存目录下，<code>Dart VM</code> 加载并且修改对应的类或者方法，重建控件树后立即就可以在设备上看到效果。</p>
<p>在 <code>Release</code> 模式下，<code>Flutter</code> 会直接将 <code>snapshot</code> 文件映射到内存中执行其中的指令：</p>
<p><img src="https://p0.meituan.net/travelcube/ef7a282f280957a1a67020a2aa7922f524600.png"></p>
<p>在 <code>Release</code> 模式下，<code>FlutterActivityDelegate</code> 的 <code>onCreate</code> 中调用 <code>FlutterMain</code> 的 <code>ensureInitializationComplete</code> 方法时会将 <code>AndroidManifest</code> 中设置的 <code>snapshot</code> 文件名等运行参数设置到对应的 <code>C/C++</code> 同名类对象中，构造 <code>FlutterNativeView</code> 实例时调用 <code>nativeAttach</code> 来初始化 <code>Dart VM</code>，最后运行编译好的 <code>Dart</code> 代码。</p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter 运行模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter 开发（11）：Flutter 层异常捕获</title>
    <url>/index.html//2019/flutter-exception-handler.html</url>
    <content><![CDATA[<p><code>Flutter</code> 中的异常可以分为同步异常和异步异常。通常情况下我们可以使用 <code>try-catch</code> 捕获同步异常，而异步异常则需要使用 <code>Flutter</code> 提供的其他 <code>API</code>。</p>
<span id="more"></span>
<h2 id="使用-try-catch-捕获异常"><a href="#使用-try-catch-捕获异常" class="headerlink" title="使用 try-catch 捕获异常"></a>使用 try-catch 捕获异常</h2><p>与 <code>Java</code> 语言类似的，<code>Dart</code> 中提供了 <code>try-catch</code> 代码块用于对同步异常的捕获：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;Result&gt; _getDirectory(<span class="built_in">String</span> methodName, [<span class="built_in">String</span> extra]) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="built_in">String</span> path;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    path = <span class="keyword">await</span> _channel.invokeMethod(methodName, extra);</span><br><span class="line">    <span class="keyword">return</span> Result(Result.ERROR_CODE_SUCCESS, <span class="string">&#x27;success&#x27;</span>, Directory(<span class="string">&#x27;<span class="subst">$path</span>/&#x27;</span>));</span><br><span class="line">  &#125; <span class="keyword">on</span> PlatformException <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> Result(<span class="built_in">num</span>.parse(e.code), e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Flutter-框架层的异常捕获"><a href="#Flutter-框架层的异常捕获" class="headerlink" title="Flutter 框架层的异常捕获"></a>Flutter 框架层的异常捕获</h3><p><code>Flutter</code> 框架在很多关键位置自动进行了异常处理。例如，如果我们的 <code>Flutter</code> 页面出现错误，会自动弹出一个错误页面：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/1/16/1685691a02afb4b6?imageView2/0/w/1280/h/960/ignore-error/1"></p>
<p>这是由于系统在调用 <code>build()</code> 方法构建页面时进行了 <code>try-catch</code> 的处理，并提供一个 <code>ErrorWidget</code> 用于出现异常信息时调用的页面：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> performRebuild() &#123;</span><br><span class="line"> ...</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//执行build方法  </span></span><br><span class="line">    built = build();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">    <span class="comment">// 有异常时则弹出错误提示  </span></span><br><span class="line">    built = ErrorWidget.builder(_debugReportException(<span class="string">&#x27;building <span class="subst">$this</span>&#x27;</span>, e, stack));</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_debugReportException</code> 方法中最终通过 <code>FlutterError.reportError</code> 将错误信息进行上报：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">FlutterErrorDetails _debugReportException(</span><br><span class="line">  <span class="built_in">String</span> context,</span><br><span class="line">  <span class="built_in">dynamic</span> exception,</span><br><span class="line">  StackTrace stack, &#123;</span><br><span class="line">  InformationCollector informationCollector</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  <span class="comment">//构建错误详情对象  </span></span><br><span class="line">  <span class="keyword">final</span> FlutterErrorDetails details = FlutterErrorDetails(</span><br><span class="line">    exception: exception,</span><br><span class="line">    stack: stack,</span><br><span class="line">    <span class="keyword">library</span>: <span class="string">&#x27;widgets library&#x27;</span>,</span><br><span class="line">    context: context,</span><br><span class="line">    informationCollector: informationCollector,</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">//报告错误</span></span><br><span class="line">  FlutterError.reportError(details);</span><br><span class="line">  <span class="keyword">return</span> details;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>reportError</code> 方法中最终通过 <code>onError</code> 属性处理错误信息（实际上 <code>onError</code> 有默认实现 <code>dumpErrorToConsole</code>）。我们可以通过重写 <code>onError</code> 属性拦截上报信息（<code>reportError</code> 方法）：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  FlutterError.onError = (FlutterErrorDetails details) &#123;</span><br><span class="line">    reportError(details);</span><br><span class="line">  &#125;;</span><br><span class="line">  runApp(FilePathProviderApplication());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们需要自定义错误页面，则需要重写 <code>ErrorWidget.builder</code>：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  ErrorWidget.builder = (FlutterErrorDetails flutterErrorDetails) &#123;</span><br><span class="line">    <span class="built_in">print</span>(flutterErrorDetails.toString());</span><br><span class="line">    <span class="keyword">return</span> Center(</span><br><span class="line">      child: Text(<span class="string">&quot;Flutter 崩溃了&quot;</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">  runApp(FilePathProviderApplication());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用-Future-API-捕获异常"><a href="#使用-Future-API-捕获异常" class="headerlink" title="使用 Future API 捕获异常"></a>使用 Future API 捕获异常</h2><p><code>Future API</code> 提供了 <code>catchError</code> 方法用于捕获使用 <code>Future</code> 时抛出的异步异常：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">filePathProvide.getExternalStorageApplicationDirectory().then((value) &#123;</span><br><span class="line">  doSomething(value);</span><br><span class="line">  <span class="keyword">throw</span> (<span class="string">&quot;exception message&quot;</span>);</span><br><span class="line">&#125;).catchError(_handlerError);</span><br><span class="line"></span><br><span class="line">_handlerError() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用-Zone-捕获未处理的异常"><a href="#使用-Zone-捕获未处理的异常" class="headerlink" title="使用 Zone 捕获未处理的异常"></a>使用 Zone 捕获未处理的异常</h2><p><code>Flutter</code> 提供了 <code>Zone.runZoned</code> 方法(<code>dart:async</code> 包)用于捕获所有未处理的异常信息：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">R runZoned&lt;R&gt;(R body(),&#123;<span class="built_in">Map</span> zoneValues, ZoneSpecification zoneSpecification, <span class="built_in">Function</span> onError&#125;)</span><br></pre></td></tr></table></figure>

<p>其中，<code>zoneValues</code> 是 <code>Zone</code> 的私有属性，<code>zoneSpecification</code> 是 <code>Zone</code> 的一些配置信息，可以自定义一些代码行为，<code>onError</code> 是 <code>Zone</code> 中未捕获异常的回调方法。</p>
<p>如果开发者提供了 <code>onError</code> 回调方法或者通过 <code>ZoneSpecification.handleUncaughtError</code> 指定了错误处理的回调方法，那么这个 <code>Zone</code> 将会变为一个 <code>error zone</code>，无论是同步环境还是异步环境，该 <code>error zone</code> 都会在出现未捕获的异常信息时调用：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runZoned(() =&gt; runApp(FilePathProviderApplication()), onError: (<span class="built_in">Object</span> obj, StackTrace stack) &#123;</span><br><span class="line">    uploadException(<span class="string">&quot;<span class="subst">$obj</span>\n<span class="subst">$stack</span>&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>runZoned</code> 可以捕获 <code>Flutter</code> 层全局的未处理异常信息。我们可以结合 <code>FlutterError</code>，在非生产环境下将 <code>Flutter UI</code> 层的异常信息使用 <code>FlutterError</code> 进行处理，而生产环境下使用 <code>runZoned</code>进行处理：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">bool</span> inProduction = <span class="keyword">const</span> <span class="built_in">bool</span>.fromEnvironment(<span class="string">&quot;dart.vm.product&quot;</span>);</span><br><span class="line"></span><br><span class="line">FlutterError.onError = (FlutterErrorDetails details) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (inProduction) &#123;</span><br><span class="line">    Zone.current.handleUncaughtError(details.exception, details.stack);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    FlutterError.dumpErrorToConsole(details);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">runApp(FilePathProviderApplication());</span><br></pre></td></tr></table></figure>

<h2 id="Flutter-端异常捕获最佳实践"><a href="#Flutter-端异常捕获最佳实践" class="headerlink" title="Flutter 端异常捕获最佳实践"></a>Flutter 端异常捕获最佳实践</h2><p>对于 <code>Flutter</code> 端的异常信息，除了能够使用 <code>try-catch</code> 捕获的同步异常之外，大多是情况下异常信息集中在 <code>Flutter</code> 端的页面渲染方面，所以我们需要重写 <code>FlutterError.onError</code> 用于处理框架层自动添加的异常捕获：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">bool</span> inProduction = <span class="keyword">const</span> <span class="built_in">bool</span>.fromEnvironment(<span class="string">&quot;dart.vm.product&quot;</span>);</span><br><span class="line"></span><br><span class="line">FlutterError.onError = (FlutterErrorDetails details) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (inProduction) &#123;</span><br><span class="line">    Zone.current.handleUncaughtError(details.exception, details.stack);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    FlutterError.dumpErrorToConsole(details);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在非生产环境下，异常信息通过 <code>FlutterError.dumpErrorToConsole(details)</code> 交由控制台进行输出，生产环境则通过 <code>Zone.current.handleUncaughtError(details.exception, details.stack)</code> 将异常信息交付给 <code>Flutter</code> 层的全局异常捕获进行处理。</p>
<p>然后，我们再为整个应用程序的 <code>Flutter</code> 层添加全局异常捕获：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">runZoned&lt;Future&lt;<span class="built_in">Null</span>&gt;&gt;(() <span class="keyword">async</span> &#123;</span><br><span class="line">    runApp(<span class="keyword">new</span> HomeApp());</span><br><span class="line">  &#125;, onError: (error, stackTrace) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> _reportError(error, stackTrace);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter 异常捕获</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter 开发（12）：MethodChannel 的使用</title>
    <url>/index.html//2019/flutter-method-channel.html</url>
    <content><![CDATA[<p>在 <code>Flutter</code> 中，<code>MethodChannel</code> 允许我们发送与方法调用相关的消息。<code>MethodChannel</code> 适用于 <code>Flutter</code> 端和设备平台端进行直接的方法调用，这种方法调用是双向的，即既可以通过 <code>MethodChannel</code> 从 <code>Flutter</code> 调用设备平台上的方法，也可以从设备平台上调用 <code>Flutter</code> 层的代码。</p>
<span id="more"></span>

<h2 id="MethodChannel-实现方法调用的步骤"><a href="#MethodChannel-实现方法调用的步骤" class="headerlink" title="MethodChannel 实现方法调用的步骤"></a>MethodChannel 实现方法调用的步骤</h2><p>在 <code>Flutter</code> 层，我们需要通过 <code>MethodChannel</code> 的构造方法创建其对象，然后通过 <code>invokeMethod</code>、<code>invokeListMethod</code> 或者 <code>invokeMapMethod</code> 方法将需要在设备平台响应的方法名称和参数，通过 <code>BinaryMessages</code> 传递给设备平台对应的响应对象（<code>Android</code> 平台为 <code>MethodChannel</code>，<code>iOS</code> 平台为 <code>FlutterMethodChannel</code>），设备平台响应完成之后将结果传递回 <code>Flutter</code>。相应的，从设备平台调用 <code>Flutter</code> 层的方法也是一样的：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4313776-f4f8d3493b076946.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/580"></p>
<ul>
<li>首先，<code>MethodChannel</code> 收到方法调用的请求之后，先通过 <code>MethodCodec</code> 的 <code>encodeMethodCall</code> 方法将需要调用的方法名称和参数信息进行编码</li>
<li>然后，通过 <code>BinaryMessages.send</code> 方法将编码之后的数据传递给对应的设备平台，并接收其返回值</li>
<li>最后，根据返回结果的值进行处理：<ul>
<li>如果返回值为 <code>null</code>，抛出 <code>MissingPluginException</code></li>
<li>如果返回值不为 <code>null</code>，通过 <code>MethodCodec</code> 的 <code>decodeEnvelope</code> 将返回值解码为具体的类型</li>
</ul>
</li>
</ul>
<h2 id="Flutter-层的-MethodChannel"><a href="#Flutter-层的-MethodChannel" class="headerlink" title="Flutter 层的 MethodChannel"></a>Flutter 层的 MethodChannel</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p><code>MethodChannel</code> 的构造方法接收一个 <code>name</code> 和一个可选的 <code>codec</code> 变量：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MethodChannel(<span class="keyword">this</span>.name, [<span class="keyword">this</span>.codec = <span class="keyword">const</span> StandardMethodCodec()]);</span><br></pre></td></tr></table></figure>

<p>其中，<code>name</code> 是 <code>String</code> 类型，作用是为每一个 <code>MethodChannel</code> 设置一个唯一的 <code>ID</code>，<code>codec</code> 是 <code>MethodCodec</code> 类型，默认值是 <code>StandardMethodCodec</code>，作用是对方法调用和返回值进行编解码：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">String</span> _METHOD_CHANNEL_NAME = <span class="string">&#x27;fiissh.flutter.plugin/flutter_file_path_provide&#x27;</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> MethodChannel _channel = <span class="keyword">const</span> MethodChannel(_METHOD_CHANNEL_NAME);</span><br></pre></td></tr></table></figure>

<p>通常情况下，我们使用默认的 <code>MethodCodec</code> 对象即可。自定义 <code>MethodCodec</code> 的方式我们会在后文中介绍。</p>
<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p><code>MethodChannel</code> 提供了下列三种方法用于方法调用：</p>
<ul>
<li><code>Future&lt;T&gt; invokeMethod&lt;T&gt;(String method, [dynamic arguments])</code>：普通方法调用</li>
<li><code>Future&lt;List&lt;T&gt;&gt; invokeListMethod&lt;T&gt;(String method, [dynamic arguments])</code>：返回值是数组的方法调用</li>
<li><code>Future&lt;Map&lt;K, V&gt;&gt; invokeMapMethod&lt;K, V&gt;(String method, [dynamic arguments])</code>：返回值是 <code>Map</code> 的方法调用</li>
</ul>
<p>我们以 <code>invokeMethod</code> 方法为例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;T&gt; invokeMethod&lt;T&gt;(<span class="built_in">String</span> method, [<span class="built_in">dynamic</span> arguments]) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">assert</span>(method != <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">final</span> ByteData result = <span class="keyword">await</span> BinaryMessages.send(</span><br><span class="line">    name,</span><br><span class="line">    codec.encodeMethodCall(MethodCall(method, arguments)),</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> MissingPluginException(<span class="string">&#x27;No implementation found for method <span class="subst">$method</span> on channel <span class="subst">$name</span>&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> T typedResult = codec.decodeEnvelope(result);</span><br><span class="line">  <span class="keyword">return</span> typedResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在接收到方法调用的参数之后，首先会通过 <code>codec.encodeMethodCall(MethodCall(method, arguments))</code> 将方法名称和参数进行编码，然后再通过 <code>BinaryMessages.send</code> 将 <code>MethodChannel</code> 的 <code>name</code> 和编码之后的数据发送到对应的设备平台，并接收 <code>ByteData</code> 类型的返回值。</p>
<p>在接收到 <code>ByteData</code> 类型的返回值之后，如果返回值为 <code>null</code>，则抛出 <code>MissingPluginException</code>，视为设备平台上没有对应的方法。否则通过 <code>codec.decodeEnvelope(result)</code> 将返回值解码为具体的数据类型。我们以 <a href="https://github.com/flutter/plugins/tree/master/packages/path_provider">path_provider/path_provider.dart</a> 项目代码为例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;Result&gt; _getDirectory(<span class="built_in">String</span> methodName, [<span class="built_in">String</span> extra]) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="built_in">String</span> path;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    path = <span class="keyword">await</span> _channel.invokeMethod(methodName, extra);</span><br><span class="line">    <span class="keyword">return</span> Result(Result.ERROR_CODE_SUCCESS, <span class="string">&#x27;success&#x27;</span>, Directory(<span class="string">&#x27;<span class="subst">$path</span>/&#x27;</span>));</span><br><span class="line">  &#125; <span class="keyword">on</span> PlatformException <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> Result(<span class="built_in">num</span>.parse(e.code), e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终，我们通过如下代码完成一次 <code>Flutter</code> 层到设备平台的方法调用：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">String</span> _EXTERNAL_STORAGE_DIRECTORY_METHOD_NAME = <span class="string">&quot;getExternalStorageDirectory&quot;</span>;</span><br><span class="line">Future&lt;Result&gt; getExternalStorageDirectory() <span class="keyword">async</span></span><br><span class="line">  <span class="keyword">return</span> _getDirectory(_EXTERNAL_STORAGE_DIRECTORY_METHOD_NAME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="响应来自设备平台的方法调用-setMethodCallHandler"><a href="#响应来自设备平台的方法调用-setMethodCallHandler" class="headerlink" title="响应来自设备平台的方法调用 setMethodCallHandler"></a>响应来自设备平台的方法调用 setMethodCallHandler</h3><p><code>setMethodCallHandler</code> 方法通过一个方法回调用来接收设备平台通过 <code>MethodChannel</code> 调用 <code>Flutter</code> 代码时的响应信息：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> setMethodCallHandler(Future&lt;<span class="built_in">dynamic</span>&gt; handler(MethodCall call)) &#123;</span><br><span class="line">  BinaryMessages.setMessageHandler(</span><br><span class="line">    name,</span><br><span class="line">    handler == <span class="keyword">null</span> ? <span class="keyword">null</span> : (ByteData message) =&gt; _handleAsMethodCall(message, handler),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法最终是通过 <code>BinaryMessages.setMessageHandler</code> 将 <code>MethodChannel</code> 的 <code>name</code> 属性和 <code>Future&lt;ByteData&gt; handler(ByteData message)</code> 回调方法赋值给了 <code>BinaryMessages</code> 对象中的 <code>_handlers</code>。</p>
<p><code>_handleAsMethodCall</code> 方法则是对返回的结果进行处理：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;ByteData&gt; _handleAsMethodCall(ByteData message, Future&lt;<span class="built_in">dynamic</span>&gt; handler(MethodCall call)) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> MethodCall call = codec.decodeMethodCall(message);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> codec.encodeSuccessEnvelope(<span class="keyword">await</span> handler(call));</span><br><span class="line">  &#125; <span class="keyword">on</span> PlatformException <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> codec.encodeErrorEnvelope(</span><br><span class="line">      code: e.code,</span><br><span class="line">      message: e.message,</span><br><span class="line">      details: e.details,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">on</span> MissingPluginException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> codec.encodeErrorEnvelope(code: <span class="string">&#x27;error&#x27;</span>, message: e.toString(), details: <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果方法调用成功，则通过 <code>MethodCodec</code> 的 <code>encodeSuccessEnvelope</code> 方法将结果编码为 <code>ByteData</code>，如果调用失败，则通过 <code>MethodCodec</code> 的 <code>encodeErrorEnvelope</code> 将错误码、错误信息和详情进行编码。我们以响应来自设备平台的一个方法调用（名称为 <code>a_method</code>）为例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">_channel.setMethodCallHandler(_handler);</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="built_in">dynamic</span>&gt; _handler(MethodCall methodCall) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;a_method&quot;</span> == methodCall.method) &#123;</span><br><span class="line">    <span class="built_in">print</span>(methodCall.method);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Future.value(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>setMethodCallHandler</code> 设置方法调用的监听之后，我们可以根据 <code>methodCall.method</code> 判断具体的方法调用。</p>
<h2 id="Android-层的-MethodChannel"><a href="#Android-层的-MethodChannel" class="headerlink" title="Android 层的 MethodChannel"></a>Android 层的 MethodChannel</h2><p><code>Android</code> 平台上响应 <code>Flutter</code> 层的方法调用是通过 <code>MethodCallHandler</code> 实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodCallHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMethodCall</span><span class="params">(MethodCall methodCall, MethodChannel.Result result)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设备平台端（<code>Android</code> 为例）响应 <code>Flutter</code> 层发送的方法调用的请求，需要实现 <code>MethodCallHandler</code> 接口用于接收方法调用的详细信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlutterFilePathProvidePlugin</span> <span class="keyword">implements</span> <span class="title">MethodCallHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMethodCall</span><span class="params">(MethodCall call, Result result)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>onMethodCall</code> 方法回调时会传入 <code>methodCall</code> 和 <code>result</code> 两个对象。其中，<code>methodCall</code> 包含了方法调用的基本信息（方法名称和参数）以及用于处理参数的几个接口。<code>result</code> 参数则用于在方法响应完毕之后，将返回值或者错误信息传递到 <code>Flutter</code> 层。上文中我们通过 <code>MethodChannel</code> 向设备平台发送了一个名称为 <code>getExternalStorageDirectory</code> 的方法调用，那么在 <code>Android</code> 平台上的具体响应代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String _EXTERNAL_STORAGE_DIRECTORY_METHOD_NAME = <span class="string">&quot;getExternalStorageDirectory&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMethodCall</span><span class="params">(MethodCall call, Result result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.equals(call.method, _EXTERNAL_STORAGE_DIRECTORY_METHOD_NAME)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String path = getExternalStorageDirectory();</span><br><span class="line">            <span class="keyword">if</span> (TextUtils.isEmpty(path)) &#123;</span><br><span class="line">                result.error(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;path is null&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.success(path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            result.error(<span class="string">&quot;2&quot;</span>, e.getMessage(), <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getExternalStorageDirectory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Environment.getExternalStorageDirectory().getAbsolutePath();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，根据 <code>Flutter</code> 端传递过来的 <code>name</code> 属性，完成对应方法的调用，并通过 <code>result</code> 对象将结果回写回 <code>Flutter</code> 层：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">success</span><span class="params">(<span class="meta">@Nullable</span> Object var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(String var1, <span class="meta">@Nullable</span> String var2, <span class="meta">@Nullable</span> Object var3)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notImplemented</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 <code>Flutter</code> 层相对应的，<code>Android</code> 端也需要初始化一个 <code>MethodChannel</code> 对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerWith</span><span class="params">(Registrar registrar)</span> </span>&#123;</span><br><span class="line">    FlutterFilePathProvidePlugin.registrar = registrar;</span><br><span class="line">    <span class="keyword">final</span> MethodChannel channel = <span class="keyword">new</span> MethodChannel(registrar.messenger(), _METHOD_CHANNEL_NAME);</span><br><span class="line">    channel.setMethodCallHandler(<span class="keyword">new</span> FlutterFilePathProvidePlugin());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p><code>Android</code> 端的 <code>MethodChannel</code> 提供了两个构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MethodChannel</span><span class="params">(BinaryMessenger messenger, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(messenger, name, StandardMethodCodec.INSTANCE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MethodChannel</span><span class="params">(BinaryMessenger messenger, String name, MethodCodec codec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> messenger != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> name != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> codec != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.messenger = messenger;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.codec = codec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 <code>Flutter</code> 端相对应的，<code>Android</code> 端的 <code>MethodChannel</code> 也需要 <code>BinaryMessenger</code>、<code>name</code> 和 <code>MethodCodec</code> 三个对象。其中，<code>name</code> 属性需要与 <code>Flutter</code> 端初始化 <code>MethodChannel</code> 时传入的 <code>name</code> 保持一致。</p>
<h3 id="方法调用-1"><a href="#方法调用-1" class="headerlink" title="方法调用"></a>方法调用</h3><p><code>Android</code> 端的 <code>MethodChannel</code> 提供了下列两个方法用于调用 <code>Flutter</code> 层的方法：</p>
<ul>
<li><code>invokeMethod(@NonNull String method, @Nullable Object arguments)</code></li>
<li><code>invokeMethod(String method, @Nullable Object arguments, MethodChannel.Result callback)</code></li>
</ul>
<p>与 <code>Flutter</code> 层调用设备平台代码一样，<code>Android</code> 端调用 <code>Flutter</code> 层代码也需要先通过 <code>MethodCodec</code> 的 <code>encodeMethodCall</code> 方法将方法调用进行编码，然后通过 <code>BinaryMessenger.send</code> 将对应的信息发送到 <code>Flutter</code> 层。</p>
<h3 id="响应-Flutter-层的方法调用"><a href="#响应-Flutter-层的方法调用" class="headerlink" title="响应 Flutter 层的方法调用"></a>响应 Flutter 层的方法调用</h3><p><code>setMethodCallHandler(@Nullable MethodChannel.MethodCallHandler handler)</code> 方法通过接收一个 <code>handler</code> 对象来响应来自于 <code>Flutter</code> 层的方法调用。</p>
<p>与 <code>Flutter</code> 层调用设备平台的方法一样的，设备平台调用 <code>Flutter</code> 层的方法也是通过 <code>MethodChannel</code> 实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.invokeMethod(<span class="string">&quot;a_method&quot;</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<h2 id="OptionalMethodChannel"><a href="#OptionalMethodChannel" class="headerlink" title="OptionalMethodChannel"></a>OptionalMethodChannel</h2><p><code>OptionalMethodChannel</code> 是 <code>MethodChannel</code> 的子类。与 <code>MethodChannel</code> 所不同的是，如果调用 <code>invokeMethod</code> 找不到与之对应的设备平台的方法，<code>MethodChannel</code> 以抛出异常的形式返回，而 <code>OptionalMethodChannel</code> 则是返回 <code>null</code>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>MethodChannel</code> 的主要作用是提供一种 <code>Flutter</code> 端方法和设备平台端的方法相互调用的机制。默认情况下，<code>MethodChannel</code> 使用 <code>StandardMethodCodec</code> 作为数据的编解码器，并最终通过 <code>BinaryMessages</code> 完成与设备平台端数据的接收和传递。</p>
<p>在 <code>MethodChannel</code> 中除了默认的 <code>StandardMethodCodec</code> 作为 <code>codec</code> 的默认实现，还可以选择 <code>JSONMethodCodec</code> 作为 <code>codec</code> 编解码器的实现，用于传递 <code>JSON</code> 类型的数据。</p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>MethodChannel</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter 开发（13）：EventChannel 的使用</title>
    <url>/index.html//2019/flutter-event-channel.html</url>
    <content><![CDATA[<p><code>EventChannel</code> 适用于 <code>Flutter</code> 端和设备平台端数据事件的通信。比较常见的使用 <code>EventChannel</code> 的场景是通过广播监听（<code>Android</code> 平台上的 <code>BroadcastReceiver</code>）动态的监听设备事件。</p>
<p>本文中的示例代码是 <code>Flutter</code> 官方示例，感兴趣的小伙伴可以移步 <a href="https://github.com/flutter/flutter/tree/master/examples/platform_channel">flutter/examples/platform_channel/</a>。</p>
<span id="more"></span>

<h2 id="EventChannel-的初始化"><a href="#EventChannel-的初始化" class="headerlink" title="EventChannel 的初始化"></a>EventChannel 的初始化</h2><p>与 <code>MethodChannel</code> 相类似的，<code>EventChannel</code> 也需要一个全局唯一的 <code>name</code> 属性作为其标识符：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> EventChannel eventChannel = EventChannel(<span class="string">&#x27;samples.flutter.io/charging&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>创建 <code>EventChannel</code> 的对象之后，我们需要向 <code>EventChannel</code> 注册一个监听回调方法用于监听事件：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">eventChannel.receiveBroadcastStream().listen(_onEvent, onError: _onError);</span><br><span class="line"><span class="keyword">void</span> _onEvent(<span class="built_in">Object</span> event) &#123;</span><br><span class="line">  setState(() &#123;</span><br><span class="line">    _chargingStatus =</span><br><span class="line">        <span class="string">&quot;Battery status: <span class="subst">$&#123;event == <span class="string">&#x27;charging&#x27;</span> ? <span class="string">&#x27;&#x27;</span> : <span class="string">&#x27;dis&#x27;</span>&#125;</span>charging.&quot;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _onError(<span class="built_in">Object</span> error) &#123;</span><br><span class="line">  setState(() &#123;</span><br><span class="line">    _chargingStatus = <span class="string">&#x27;Battery status: unknown.&#x27;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="设备平台-Android-端的初始化"><a href="#设备平台-Android-端的初始化" class="headerlink" title="设备平台 Android 端的初始化"></a>设备平台 Android 端的初始化</h2><p>在设备平台（<code>Android</code>）端，我们需要配置 <code>EventChannel</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> EventChannel(getFlutterView(), CHARGING_CHANNEL).setStreamHandler(</span><br><span class="line">    <span class="keyword">new</span> StreamHandler() &#123;</span><br><span class="line">      <span class="keyword">private</span> BroadcastReceiver chargingStateChangeReceiver;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onListen</span><span class="params">(Object arguments, EventSink events)</span> </span>&#123;</span><br><span class="line">        chargingStateChangeReceiver = createChargingStateChangeReceiver(events);</span><br><span class="line">        registerReceiver(</span><br><span class="line">            chargingStateChangeReceiver, <span class="keyword">new</span> IntentFilter(Intent.ACTION_BATTERY_CHANGED));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCancel</span><span class="params">(Object arguments)</span> </span>&#123;</span><br><span class="line">        unregisterReceiver(chargingStateChangeReceiver);</span><br><span class="line">        chargingStateChangeReceiver = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>其中，<code>onListen</code> 是 <code>Flutter</code> 端设置监听回调方法之后调用，我们在该方法中触发时向系统注册监听电量变化的广播：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> BroadcastReceiver <span class="title">createChargingStateChangeReceiver</span><span class="params">(<span class="keyword">final</span> EventSink events)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BroadcastReceiver() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> status = intent.getIntExtra(BatteryManager.EXTRA_STATUS, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (status == BatteryManager.BATTERY_STATUS_UNKNOWN) &#123;</span><br><span class="line">          events.error(<span class="string">&quot;UNAVAILABLE&quot;</span>, <span class="string">&quot;Charging status unavailable&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">boolean</span> isCharging = status == BatteryManager.BATTERY_STATUS_CHARGING ||</span><br><span class="line">                               status == BatteryManager.BATTERY_STATUS_FULL;</span><br><span class="line">          events.success(isCharging ? <span class="string">&quot;charging&quot;</span> : <span class="string">&quot;discharging&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>onCancel</code> 是事件流断开时触发，我们在其中将广播取消。由此一来，设备平台端的事件变化可以通过 <code>EventChannel</code> 从设备平台端传递到 <code>Flutter</code> 端。</p>
<p>当设备平台端的事件发生变化时，通过 <code>EventSink</code> 对象 <code>events</code> 将对应的状态回传给 <code>Flutter</code> 端。</p>
<h2 id="EventChannel-的原理"><a href="#EventChannel-的原理" class="headerlink" title="EventChannel 的原理"></a>EventChannel 的原理</h2><p>事实上，<code>EventChannel</code> 是使用 <code>MethodChannel</code> 和 <code>Stream</code> 以达到监听事件变化的目的的：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Stream&lt;<span class="built_in">dynamic</span>&gt; receiveBroadcastStream([<span class="built_in">dynamic</span> arguments]) &#123;</span><br><span class="line">  <span class="keyword">final</span> MethodChannel methodChannel = MethodChannel(name, codec);</span><br><span class="line">  StreamController&lt;<span class="built_in">dynamic</span>&gt; controller;</span><br><span class="line">  controller = StreamController&lt;<span class="built_in">dynamic</span>&gt;.broadcast(onListen: () <span class="keyword">async</span> &#123;</span><br><span class="line">    BinaryMessages.setMessageHandler(name, (ByteData reply) <span class="keyword">async</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (reply == <span class="keyword">null</span>) &#123;</span><br><span class="line">        controller.close();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          controller.add(codec.decodeEnvelope(reply));</span><br><span class="line">        &#125; <span class="keyword">on</span> PlatformException <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          controller.addError(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> methodChannel.invokeMethod&lt;<span class="keyword">void</span>&gt;(<span class="string">&#x27;listen&#x27;</span>, arguments);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (exception, stack) &#123;</span><br><span class="line">      FlutterError.reportError(FlutterErrorDetails(</span><br><span class="line">        exception: exception,</span><br><span class="line">        stack: stack,</span><br><span class="line">        <span class="keyword">library</span>: <span class="string">&#x27;services library&#x27;</span>,</span><br><span class="line">        context: <span class="string">&#x27;while activating platform stream on channel <span class="subst">$name</span>&#x27;</span>,</span><br><span class="line">      ));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, onCancel: () <span class="keyword">async</span> &#123;</span><br><span class="line">    BinaryMessages.setMessageHandler(name, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> methodChannel.invokeMethod&lt;<span class="keyword">void</span>&gt;(<span class="string">&#x27;cancel&#x27;</span>, arguments);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (exception, stack) &#123;</span><br><span class="line">      FlutterError.reportError(FlutterErrorDetails(</span><br><span class="line">        exception: exception,</span><br><span class="line">        stack: stack,</span><br><span class="line">        <span class="keyword">library</span>: <span class="string">&#x27;services library&#x27;</span>,</span><br><span class="line">        context: <span class="string">&#x27;while de-activating platform stream on channel <span class="subst">$name</span>&#x27;</span>,</span><br><span class="line">      ));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> controller.stream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在 <code>Flutter</code> 端调用 <code>receiveBroadcastStream</code> 方法之后，会返回一个 <code>Stream</code> 对象用于接收数据流，其中 <code>listen</code> 方法则用于监听数据的变化。</p>
<p>而在 <code>receiveBroadcastStream</code> 方法调用时，其中通过 <code>MethodChannel</code> 调用了对应设备平台上的 <code>onListen</code> 和 <code>onCancel</code> 两个方法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>与 <code>MethodChannel</code> 一样，<code>EventChannel</code> 最为核心的实现也是 <code>BinaryMessages</code> 和 <code>MethodCodec</code>。默认的，<code>EventChannel</code> 使用 <code>StandardMethodCodec</code> 作为 <code>codec</code> 属性的默认实现。</p>
<p>与 <code>MethodChannel</code> 一样，<code>EventChannel</code> 也可以使用 <code>JSONMethodCodec</code> 作为其编解码器的实现。</p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>EventChannel</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter 开发（14）：BasicMessageChannel 的使用</title>
    <url>/index.html//2019/flutter-basic-message-channel.html</url>
    <content><![CDATA[<p>与 <code>MethodChannel</code> 和 <code>EventChannel</code> 接收一个 <code>MethodCodec</code> 对象所不同的是，<code>BasicMessageChannel</code> 接收一个 <code>MessageCodec&lt;T&gt;</code> 作为其编解码器的实现。<code>BasicMessageChannel</code> 允许我们使用自定义的消息编解码器进行异步消息传递。</p>
<p>本文中所使用的代码示例出自 <code>Flutter</code> 官方示例，感兴趣的小伙伴请移步 <a href="https://github.com/flutter/flutter/tree/master/examples/flutter_view">flutter/examples/flutter_view</a></p>
<span id="more"></span>
<h2 id="BasicMessageChannel-的初始化"><a href="#BasicMessageChannel-的初始化" class="headerlink" title="BasicMessageChannel 的初始化"></a>BasicMessageChannel 的初始化</h2><p><code>BasicMessageChannel</code> 不提供默认的 <code>MessageCodec</code> 的实现，我们需要在初始化 <code>BasicMessageChannel</code> 时指定具体的 <code>MessageCodec</code>。我们以使用 <code>StringCodec</code> 初始化 <code>BasicMessageChannel</code> 并传递 <code>String</code> 类型的数据为例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> BasicMessageChannel&lt;<span class="built_in">String</span>&gt; platform = BasicMessageChannel&lt;<span class="built_in">String</span>&gt;(_channel, StringCodec());</span><br></pre></td></tr></table></figure>

<p>对象初始化之后，我们通过 <code>setMessageHandler</code> 方法设置一个 <code>MessageHandler</code> 回调函数：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">platform.setMessageHandler(_handlePlatformIncrement);</span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; _handlePlatformIncrement(<span class="built_in">String</span> message) <span class="keyword">async</span> &#123;</span><br><span class="line">  setState(() &#123;</span><br><span class="line">    _counter++;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> _emptyMessage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化完成之后，我们可以通过 <code>platform.send(&#39;pong&#39;);</code> 向设备平台端发送一个 <code>String</code> 类型的数据。</p>
<h2 id="设备平台-Android-端的初始化"><a href="#设备平台-Android-端的初始化" class="headerlink" title="设备平台 Android 端的初始化"></a>设备平台 Android 端的初始化</h2><p>相应的，我们需要在设备平台端（<code>Android</code>） 初始化 <code>BasicMessageChannel</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">messageChannel = <span class="keyword">new</span> BasicMessageChannel&lt;&gt;(flutterView, CHANNEL, StringCodec.INSTANCE);</span><br><span class="line">messageChannel.</span><br><span class="line">    setMessageHandler(<span class="keyword">new</span> MessageHandler&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String s, Reply&lt;String&gt; reply)</span> </span>&#123;</span><br><span class="line">            onFlutterIncrement();</span><br><span class="line">            reply.reply(EMPTY_MESSAGE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>设备平台端收到数据之后，<code>onMessage</code> 方法会被触发。</p>
<p>同样的，在设备平台端可以使用 <code>messageChannel.send(PING);</code> 向 <code>Flutter</code> 端发送 <code>String</code> 类型的数据，<code>Flutter</code> 端收到数据之后，<code>_handlePlatformIncrement</code> 方法会被触发。</p>
<h2 id="BasicMessageChannel-的原理"><a href="#BasicMessageChannel-的原理" class="headerlink" title="BasicMessageChannel 的原理"></a>BasicMessageChannel 的原理</h2><p>与 <code>MethodChannel</code> 一样，<code>BasicMessageChannel</code> 在发送数据时需要先通过 <code>codec</code> 将消息编码，然后通过 <code>BinaryMessages</code> 将编码之后的消息发送出去，最后通过 <code>codec</code> 再将返回值进行解码：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;T&gt; send(T message) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> codec.decodeMessage(<span class="keyword">await</span> BinaryMessages.send(name, codec.encodeMessage(message)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>BasicMessageChannel</code> 提供了一种机制允许我们自己定义消息的编解码器。相应的，<code>Flutter</code> 中已经提供了 <code>BinaryCodec</code>、<code>StringCodec</code> 和 <code>JSONMessageCodec</code> 作为常用数据类型的编解码器实现。如果还不能满足需求，我们可以通过扩展 <code>MessageCodec&lt;T&gt;</code> 达到目的。</p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>BasicMessageChannel</tag>
      </tags>
  </entry>
  <entry>
    <title>Git Commit Message 模板</title>
    <url>/index.html//2019/git-commit-template.html</url>
    <content><![CDATA[<h2 id="Commit-Message-规范"><a href="#Commit-Message-规范" class="headerlink" title="Commit Message 规范"></a>Commit Message 规范</h2><p>每一个 <code>Commit Message</code> 应该包含一个 <code>header</code>、<code>body</code> 和 <code>footer</code>。其中，<code>header</code>、<code>body</code> 和 <code>footer</code> 之间以空行作为间隔。<code>header</code> 是必须要填写的：</p>
<ul>
<li><code>header</code> 通常包含此次提交的类型：<ul>
<li><code>feat</code> 新特性</li>
<li><code>fix</code> <code>bug</code> 修复</li>
<li><code>docs</code> 文档改动</li>
<li><code>style</code> 格式化</li>
<li><code>refactor</code> 重构代码</li>
<li><code>test</code> 添加缺失的测试, 重构测试, 不包括生产代码变动</li>
<li><code>chore</code> 更新grunt任务等; 不包括生产代码变动</li>
</ul>
</li>
<li><code>body</code> 通常包含此次改动的影响范围、改动的详细信息</li>
<li><code>footer</code> 通常包含一些需要关闭的 <code>issues</code> 信息等</li>
</ul>
<h2 id="模板文件"><a href="#模板文件" class="headerlink" title="模板文件"></a>模板文件</h2><p>建议将如下内容保存到本机的某个目录，例如 <code>MAC</code> 的 <code>~/.git-commit-template.txt</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> &lt;类型&gt;: (类型的值见下面描述) &lt;主题&gt; (最多50个字)</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解释为什么要做这些改动</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> |&lt;----  请限制每行最多72个字   ----&gt;|</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提供相关文章和其它资源的链接和关键字</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例如: Github issue <span class="comment">#23</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --- 提交 结束 ---</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 类型值包含</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    feat (新特性)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    fix (bug修复)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    docs (文档改动)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    style (格式化, 缺失分号等; 不包括生产代码变动)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    refactor (重构代码)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    <span class="built_in">test</span> (添加缺失的测试, 重构测试, 不包括生产代码变动)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    chore (更新grunt任务等; 不包括生产代码变动)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    主题和内容以一个空行分隔</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    主题限制为最大50个字</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    主题行大写</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    主题行结束不用标点</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    主题行使用祈使名</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    内容每行72个字</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    内容用于解释为什么和是什么,而不是怎么做</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    内容多行时以<span class="string">&#x27;-&#x27;</span>分隔</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --------------------</span></span><br></pre></td></tr></table></figure>

<h2 id="使用模板"><a href="#使用模板" class="headerlink" title="使用模板"></a>使用模板</h2><p>使用如下命令将模板文件指定为 <code>Git</code> 的 <code>commit.template</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global commit.template &lt;.git-commit-template.txt file path&gt;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global commit.template ~/.git-commit-template.txt</span><br></pre></td></tr></table></figure>

<h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><p>对于 <code>Android Studio</code> 或者 <code>IDEA</code> 来说，可以使用 <a href="https://plugins.jetbrains.com/plugin/9861-git-commit-template/">Git Commit Template</a> 插件，在图形化 <code>Commit</code> 界面使用该插件生成标准 <code>Commit Message</code>。</p>
]]></content>
      <categories>
        <category>项目管理</category>
      </categories>
      <tags>
        <tag>Git Message 模板</tag>
      </tags>
  </entry>
  <entry>
    <title>OutOfMemoryError:pthread_create (1040KB stack) failed 异常分析</title>
    <url>/index.html//2020/oom-exception-caused-by-pthread-create-failed.html</url>
    <content><![CDATA[<p>线上出现一些 <code>OutOfMemoryError</code>，经过分析崩溃数据，发现出现 <code>OOM</code> 时进程的可用空间还是非常大的。</p>
<p>从崩溃的堆栈信息中可以分析出引发该 <code>OOM</code> 的主要与 <code>OkHttp</code> 有关系，而业务场景中都是普通的数据请求（<code>JSON</code>），并没有使用 <code>BitMap</code> 这一类的较大内存占用的资源。更何况，进程的可用内存空间还是很充足的。</p>
<p>虽然堆栈信息不尽相同，但是最终从大量堆栈 <code>LOG</code> 中分析出有价值的信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: pthread_create (1040KB stack) failed: Try again</span><br><span class="line">at java.lang.Thread.nativeCreate(Native Method)</span><br><span class="line">at java.lang.Thread.start(Thread.java:<span class="number">733</span>)</span><br><span class="line">at tech.fiissh.base.utils.c.u(SourceFile:<span class="number">7</span>)</span><br><span class="line">at tech.fiissh.base.common.e.c.a(SourceFile:<span class="number">40</span>)</span><br><span class="line">at tech.fiissh.base.common.e.c.a(SourceFile:<span class="number">156</span>)</span><br><span class="line">at tech.fiissh.base.common.e.b.a(SourceFile:<span class="number">30</span>)</span><br><span class="line">at tech.fiissh.base.common.e.b.a$<span class="number">1.</span>handleMessage(SourceFile:<span class="number">6</span>)</span><br><span class="line">at android.os.Handler.dispatchMessage(Handler.java:<span class="number">105</span>)</span><br><span class="line">at android.os.Looper.loop(Looper.java:<span class="number">164</span>)</span><br><span class="line">at android.app.ActivityThread.main(ActivityThread.java:<span class="number">6942</span>)</span><br><span class="line">at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:<span class="number">327</span>)</span><br><span class="line">at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:<span class="number">1374</span>)</span><br><span class="line"></span><br><span class="line">java.lang.OutOfMemoryErrorat java.lang.String.&lt;init&gt;(String.java:<span class="number">255</span>)</span><br><span class="line">at libcore.io.IoUtils$FileReader.toString(IoUtils.java:<span class="number">272</span>)</span><br><span class="line">at libcore.io.IoUtils.readFileAsString(IoUtils.java:<span class="number">114</span>)</span><br><span class="line">at com.android.org.conscrypt.CertPinManager.readPinFile(CertPinManager.java:<span class="number">111</span>)</span><br><span class="line">at com.android.org.conscrypt.CertPinManager.rebuild(CertPinManager.java:<span class="number">85</span>)</span><br><span class="line">at com.android.org.conscrypt.CertPinManager.&lt;init&gt;(CertPinManager.java:<span class="number">49</span>)</span><br><span class="line">at com.android.org.conscrypt.TrustManagerImpl.&lt;init&gt;(TrustManagerImpl.java:<span class="number">137</span>)</span><br><span class="line">at com.android.org.conscrypt.TrustManagerImpl.&lt;init&gt;(TrustManagerImpl.java:<span class="number">97</span>)</span><br><span class="line">at com.android.org.conscrypt.TrustManagerFactoryImpl.engineGetTrustManagers(TrustManagerFactoryImpl.java:<span class="number">80</span>)</span><br><span class="line">at javax.net.ssl.TrustManagerFactory.getTrustManagers(TrustManagerFactory.java:<span class="number">219</span>)</span><br><span class="line">at tech.fiissh.thrid.okhttp.internal.Util.platformTrustManager(Util.java:<span class="number">670</span>)</span><br><span class="line">at tech.fiissh.thrid.okhttp.OkHttpClient.&lt;init&gt;(OkHttpClient.java:<span class="number">256</span>)</span><br><span class="line">at tech.fiissh.thrid.okhttp.OkHttpClient$Builder.build(OkHttpClient.java:<span class="number">1035</span>)</span><br><span class="line">at tech.fiissh.base.common.net.e.b.&lt;init&gt;(OkHttpStack.java:<span class="number">73</span>)</span><br><span class="line">at tech.fiissh.base.common.net.g.&lt;init&gt;(NetworkDispatcher.java:<span class="number">51</span>)</span><br><span class="line">at tech.fiissh.base.common.net.i$<span class="number">1.</span>run(RequestQueue.java:<span class="number">110</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1112</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">587</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">841</span>)</span><br></pre></td></tr></table></figure>

<p>经过与源码文件进行比较，<code>OkHttpStack</code> 第73行的方法实际上是通过 <code>OkHttpClient.Builder</code> 来实例化一个 <code>OkHttpClient</code> 对象。</p>
<p>通常情况下我们所理解的 <code>OOM</code> 是由于进程的可用堆内存不够（即 <code>Runtime.getRuntime().maxMemory()</code> 小于需要申请的内存大小）的情况下系统会抛出 <code>OutOfMemoryError</code>。其报错信息中详细的记录了我们的内存分配需求和可用堆内存的大小信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Failed to allocate a XXX <span class="keyword">byte</span> allocation with XXX free bytes and XXXKB until OOM</span><br></pre></td></tr></table></figure>

<p>通过对 <code>pthread_create</code> 关键字的搜索，最终在 <a href="https://cs.android.com/android/platform/superproject/+/master:art/runtime/thread.cc">thread.cc</a> 中找到了抛出该异常的位置，并且通过对 <code>Thread::CreateNativeThread</code> 函数的分析发现，在创建线程时，系统会先判断当前线程数是否超过了系统对线程数的限制，如果超过该限制则抛出 <code>java.lang.OutOfMemoryError:pthread_create (XXXXKB stack) failed</code> 异常。</p>
<p>那么，问题的根源在哪里？通过对代码的分析，发现每次发起一个网络请求的时候都会创建一个 <code>OkHttpClient</code>，而每个 <code>OkHttpClient</code> 对象都会初始化一个线程池（线程的生命周期又较长），如果在短时间内发起多次请求，那么线程池会被创建多个，而线程数也会随之增加。解决的方案则是将 <code>OkHttpClient</code> 通过单例的方式对外提供。</p>
<p>针对上述线程创建的问题，可以参考 <a href="https://juejin.im/entry/59f7ea06f265da43143ffee4">不可思议的OOM</a>，作者针对出现类似问题的场景做了深入分析。</p>
<p>关于 <code>HTTPClient</code> 的问题，可以参考 <a href="https://www.jianshu.com/p/3b232d9f38c2">OkHttp竟然玩出OOM？</a>，作者针对为什么创建多个线程池的场景进行了深入的分析。</p>
]]></content>
      <categories>
        <category>Exception</category>
      </categories>
      <tags>
        <tag>OutOfMemoryError</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter 开发（07）：编写平台相关的代码</title>
    <url>/index.html//2019/flutter-platform-specific.html</url>
    <content><![CDATA[<p>前面文章介绍的 <code>path_provider.dart</code> 库和 <code>shared_preferences.dart</code> 库的实际上是依赖于设备的具体环境的。比如说在 <code>shared_preferences.dart</code> 库在存储数据时，在 <code>Android</code> 设备上使用的是 <code>SharedPreference</code> 相关的功能，而在 <code>iOS</code> 上则是使用了 <code>NSUserDefaults</code> 的相关功能。换句话说，这些代码都是平台相关的。</p>
<p>本文主要介绍 <code>Flutter</code> 中平台相关的代码的开发，其目的是快速了解 <code>Android</code> 和 <code>iOS</code> 原生代码与 <code>Flutter</code> 之间的通信。</p>
<p>本文将以 <code>Flutter</code> 的官方 <a href="https://github.com/flutter/plugins/tree/master/packages/path_provider">path_provider/path_provider.dart</a> 库作为示例。</p>
<p>平台通道的作用是在 <code>Flutter</code> 和设备之间传递消息，如下所示：</p>
<p><img src="/images/flutter-platform-channel.png" alt="flutter-platform-channel"></p>
<p><code>Flutter</code> 中平台特定的 <code>API</code> 支持并不依赖于代码生成，而是依赖于灵活的消息传递方式：</p>
<ul>
<li>应用程序的 <code>Flutter</code> 部分通过平台通道（<code>Platform Channel</code>）将消息发送到该应用程序的设备平台（<code>Android</code> 或 <code>iOS</code>）</li>
<li>设备平台通过对平台通道的监听接收到消息之后，调用设备平台上对应的 <code>API</code>（使用设备平台原生开发语言），然后将响应数据发送回应用程序的 <code>Flutter</code> 部分</li>
</ul>
<p>本文中有大量的内容参考自阿里咸鱼技术团队的 <a href="https://zhuanlan.zhihu.com/p/43163159">深入理解 Flutter Platform Channel</a> 一文。该文章对 <code>Flutter</code> 的平台通道有非常详细的讲解。</p>
<p>再次表达对咸鱼团队的感谢以及对肥肥作为伸手党的不齿。</p>
<span id="more"></span>
<h2 id="平台通道类型"><a href="#平台通道类型" class="headerlink" title="平台通道类型"></a>平台通道类型</h2><p><code>Flutter</code> 中定义了三种不同类型的平台通道，他们的代码实现在 <code>platform_channel.dart</code> 文件中：</p>
<ul>
<li><code>BasicMessageChannel</code>：用于传递字符串和半结构化的消息</li>
<li><code>MethodChannel</code> 和 <code>OptionalMethodChannel</code>：用于传递方法调用</li>
<li><code>EventChannel</code>：用于传递数据流</li>
</ul>
<p>上述三种类型的平台通道相互独立，都有着各自的用途。从源码的角度来说，每个平台通道都有三个非常重要的成员变量：</p>
<ul>
<li><code>name</code>： <code>String</code> 类型，表示平台通道的名称，也是通道的唯一标识符</li>
<li><code>BinaryMessenger</code>： <code>BinaryMessenger</code> 类型，用于表示消息，是接收和发送消息的具体实现</li>
<li><code>codec</code>： <code>MessageCodec</code> 或者 <code>MethodCodec</code> 类型，是消息的编解码器</li>
</ul>
<h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><p><code>name</code> 属性是平台通道的唯一标识符。一个 <code>Flutter</code> 应用中可能会存在多个平台通道，每一个平台通道在创建时必须指定一个位移的 <code>name</code> 属性（<code>Flutter</code> 使用该属性来区分每一个通道）。</p>
<p>当有消息从 <code>Flutter</code> 端发送到设备平台时，会根据其传递过来的 <code>name</code> 属性找到该通道对应的 <code>Handler</code>（消息处理器）。</p>
<h3 id="BinaryMessenger"><a href="#BinaryMessenger" class="headerlink" title="BinaryMessenger"></a>BinaryMessenger</h3><p>上述三种类型的平台通道都是通过 <code>BinaryMessenger</code> 达到与 <code>Flutter</code> 通信的目的的：</p>
<p><img src="/images/binary-messenger.jpg" alt="binary-messenger"></p>
<p><code>BinaryMessenger</code> 使用的消息数据格式为二进制格式的数据。当我们初始化一个通道并向钙通道注册消息处理器（<code>Handler</code>）时，实际上会生成一个与之对应的 <code>BinaryMessageHandler</code>，并以通道的唯一标示符（<code>name</code>）作为 <code>key</code> 存储到 <code>Map&lt;String, _MessageHandler&gt; _handlers</code> （定义在 <code>platform_messages.dart/BinaryMessages</code> 中）对象中。当我们需要使用 <code>BinaryMessenger</code> 发送消息时，会根据 <code>name</code> 属性查找对应的 <code>BinaryMessageHandler</code>，然后完成消息的发送。</p>
<blockquote>
<p><code>BinaryMessages</code> 在 <code>Android</code> 端是一个接口，其具体实现是 <code>FlutterNativeView</code>。在 <code>iOS</code> 端是一个协议，其名称为 <code>FlutterBinaryMessenger</code>，<code>FlutterViewController</code> 遵循了它。</p>
</blockquote>
<p>在 <code>Flutter</code> 中，<code>BinaryMessenger</code> 并不知道平台通道的存在。事实上，<code>BinaryMessenger</code> 只和 <code>BinaryMessengerHandler</code> 直接通信（<code>name</code> 属性与 <code>BinaryMessengerHandler</code> 一一对象）。</p>
<p>由于平台通道从 <code>BinaryMessengerHandler</code> 接收到的消息是二进制格式的，需要使用 <code>codec</code> 将消息解码为可识别的数据并传递给 <code>Handler</code> 进行处理。</p>
<p>当 <code>Handler</code> 处理完消息之后，会通过回调方法返回 <code>result</code>，并将 <code>result</code> 通过 <code>codec</code> 编码为二进制数据，最终通过 <code>BinaryMessenger</code> 发送回 <code>Flutter</code>。</p>
<h3 id="codec"><a href="#codec" class="headerlink" title="codec"></a>codec</h3><p><code>Flutter</code> 中定义了两种类型的 <code>codec</code>：</p>
<ul>
<li><code>MessageCodec</code>：用于二进制格式的数据与基础数据之间的编解码</li>
<li><code>MethodCodec</code>：用于二进制格式的数据与方法调用以及返回结果之间的编解码</li>
</ul>
<p><img src="/images/flutter-codec.jpg" alt="flutter-codec"></p>
<h4 id="MessageCodec"><a href="#MessageCodec" class="headerlink" title="MessageCodec"></a>MessageCodec</h4><p><code>MessageCodec</code> 用于二进制格式的数据与基础数据之间的编解码，其主要目的是将消息处理为消息处理器（<code>Handler</code>）能够识别的数据。通道 <code>BasicMessageChannel</code> 使用的编解码器类型就是 <code>MessageCodec</code>。<code>MessageCodec</code> 的代码定义如下（<code>message_codec.dart/MessageCodec</code>）：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageCodec</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">Encodes the specified [message] in binary.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">Returns null if the message is null.</span></span></span><br><span class="line">  ByteData encodeMessage(T message);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Decodes the specified [message] from binary.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">Returns null if the message is null.</span></span></span><br><span class="line">  T decodeMessage(ByteData message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>ByteData encodeMessage</code> 接口用于编码数据，<code>T decodeMessage</code> 用于解码数据。</p>
<blockquote>
<p>在 <code>Android</code> 中，<code>MessageCodec</code> 是一个接口，其中定义了两个方法 <code>encodeMessage</code> 和 <code>decodeMessage</code>。其中，<code>encodeMessage</code> 接收一个特定的数据类型，并将其编码为二进制数据 <code>ByteBuffer</code>。<code>decodeMessage</code> 则是接收二进制数据 <code>ByteBuffer</code>，并将其解码为特定的数据类型。在 <code>iOS</code> 中的名称是 <code>FlutterMessageCodec</code>，是一个协议类型，定义了两个方法 <code>encode</code> 和 <code>decode</code>。其中，<code>encode</code> 接收一个类型为 <code>id</code> 的消息，并将其编码为 <code>NSData</code> 类型。<code>decode</code> 则是接收 <code>NSData</code> 类型的信息，并将其解码为 <code>id</code> 类型的数据。</p>
</blockquote>
<p>在 <code>Flutter</code> 中，<code>MessageCodec</code> 有如下四种类型的定义（<code>message_codecs.dart</code>）：</p>
<ul>
<li><code>BinaryCodec</code>： 二进制数据的编解码</li>
<li><code>StringCodec</code>： <code>String</code> 类型和二进制数据之间的编解码（<code>UTF-8</code>）</li>
<li><code>JSONMessageCodec</code>： <code>JSON</code> 格式的基础数据类型与二进制数据之间的编解码</li>
<li><code>StandardMessageCodec</code>： <code>BasicMessageChannel</code> 的默认编解码器</li>
</ul>
<p><code>Flutter</code> 的 <code>BasicMessageChannel</code> 通道使用 <code>StandardMessageCodec</code>编解码器，支持简单的类似于 <code>JSON</code> 的高效二进制序列数据，例如 <code>bool</code>、<code>num</code>、<code>String</code>、<code>List</code>、<code>Map</code> 以及 <code>byte buffer</code> 等（详细信息请移步 <a href="https://docs.flutter.io/flutter/services/StandardMessageCodec-class.html">StandardMessageCodec class</a>）。当我们发送和接收消息时，这些值在消息中的序列化和反序列化操作都将自动进行。</p>
<h5 id="BinaryCodec"><a href="#BinaryCodec" class="headerlink" title="BinaryCodec"></a>BinaryCodec</h5><p><code>BinaryCodec</code> 是二进制类型数据的编解码器：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryCodec</span> <span class="keyword">implements</span> <span class="title">MessageCodec</span>&lt;<span class="title">ByteData</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">Creates a [MessageCodec] with unencoded binary messages represented using</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">[ByteData].</span></span></span><br><span class="line">  <span class="keyword">const</span> BinaryCodec();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ByteData decodeMessage(ByteData message) =&gt; message;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ByteData encodeMessage(ByteData message) =&gt; message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看出，无论是编码还是解码，<code>BinaryCodec</code> 对 <code>message</code> 没有做任何的处理（实际上，无论编解码操作，<code>BinaryCodec</code> 接收的都是 <code>ByteData</code> 类型的数据）。在 <code>Android</code> 上，<code>ByteData</code> 类型的数据表示为 <code>java.nio.ByteBuffer</code>，而在 <code>iOS</code> 上则表示为 <code>NSData</code>。</p>
<h5 id="StringCodec"><a href="#StringCodec" class="headerlink" title="StringCodec"></a>StringCodec</h5><p><code>StringCodec</code> 用于 <code>UTF-8</code> 类型的字符串数据和二进制数据之间的编解码：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringCodec</span> <span class="keyword">implements</span> <span class="title">MessageCodec</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">Creates a [MessageCodec] with UTF-8 encoded String messages.</span></span></span><br><span class="line">  <span class="keyword">const</span> StringCodec();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> decodeMessage(ByteData message) &#123;</span><br><span class="line">    <span class="keyword">if</span> (message == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> utf8.decoder.convert(message.buffer.asUint8List(message.offsetInBytes, message.lengthInBytes));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ByteData encodeMessage(<span class="built_in">String</span> message) &#123;</span><br><span class="line">    <span class="keyword">if</span> (message == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> Uint8List encoded = utf8.encoder.convert(message);</span><br><span class="line">    <span class="keyword">return</span> encoded.buffer.asByteData();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>String</code> 类型的数据 <code>message</code> 在 <code>Android</code> 上的表示为 <code>java.util.String</code>，而在 <code>iOS</code> 上则表示为 <code>NSString</code>。</p>
<p>数据类型的转换使用了 <code>dart.convert</code> 库中的 <code>Utf8Codec</code>。</p>
<h5 id="JSONMessageCodec"><a href="#JSONMessageCodec" class="headerlink" title="JSONMessageCodec"></a>JSONMessageCodec</h5><p><code>JSONMessageCodec</code> 用于 <code>UTF-8</code> 的 <code>JSON</code> 型消息与二进制数据之间的编解码：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JSONMessageCodec</span> <span class="keyword">implements</span> <span class="title">MessageCodec</span>&lt;<span class="title">dynamic</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// The codec serializes messages as defined by the JSON codec of the</span></span><br><span class="line">  <span class="comment">// dart:convert package. The format used must match the Android and</span></span><br><span class="line">  <span class="comment">// iOS counterparts.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Creates a [MessageCodec] with UTF-8 encoded JSON messages.</span></span></span><br><span class="line">  <span class="keyword">const</span> JSONMessageCodec();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ByteData encodeMessage(<span class="built_in">dynamic</span> message) &#123;</span><br><span class="line">    <span class="keyword">if</span> (message == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const</span> StringCodec().encodeMessage(json.encode(message));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">dynamic</span> decodeMessage(ByteData message) &#123;</span><br><span class="line">    <span class="keyword">if</span> (message == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> message;</span><br><span class="line">    <span class="keyword">return</span> json.decode(<span class="keyword">const</span> StringCodec().decodeMessage(message));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该解码器所支持的基础数据类型有如下几种：</p>
<ul>
<li><code>null</code></li>
<li><code>bool</code></li>
<li><code>num</code></li>
<li><code>String</code></li>
<li><code>List</code></li>
<li><code>Map</code></li>
</ul>
<p>在 <code>Android</code> 上，<code>dynamic message</code> 的数据表示为 <code>JSON</code> 对象（<code>org.json</code> 包），而在 <code>iOS</code> 上则表示为 <code>NSJSONSerialization</code>。</p>
<p><code>JSON</code> 类型的数据转换为二进制数据使用了 <code>StringCodec().encodeMessage(json.encode(message))</code>，该过程实际上是先将 <code>json</code> 对象转换为 <code>String</code>，然后再通过 <code>StringCodec().encodeMessage</code> 方法将 <code>String</code> 数据转换为 <code>ByteData</code>。相反的，首先，通过使用 <code>StringCodec().decodeMessage(message)</code> 方法将二进制数据转换为 <code>String</code>，然后可以通过使用 <code>json.decode</code> 方法将 <code>String</code> 数据转换为 <code>JSON</code> 对象。</p>
<h5 id="StandardMessageCodec"><a href="#StandardMessageCodec" class="headerlink" title="StandardMessageCodec"></a>StandardMessageCodec</h5><p><code>StandardMessageCodec</code> 用于基本数据类型与二进制数据的编解码。</p>
<p>下表显示了 <code>StandardMessageCodec</code> 中需要转换的基础数据类型在 <code>Android</code> 和 <code>iOS</code> 中对应的关系：</p>
<table>
<thead>
<tr>
<th>Flutter</th>
<th>Android</th>
<th>iOS</th>
</tr>
</thead>
<tbody><tr>
<td>null</td>
<td>null</td>
<td>nil (NSNull when nested)</td>
</tr>
<tr>
<td>bool</td>
<td>ava.lang.Boolean</td>
<td>NSNumber numberWithBool:</td>
</tr>
<tr>
<td>int</td>
<td>java.lang.Integer</td>
<td>NSNumber numberWithInt:</td>
</tr>
<tr>
<td>int, if 32 bits not enough</td>
<td>java.lang.Long</td>
<td>NSNumber numberWithLong:</td>
</tr>
<tr>
<td>int, if 64 bits not enough</td>
<td>java.math.BigInteger</td>
<td>FlutterStandardBigInteger</td>
</tr>
<tr>
<td>double</td>
<td>java.lang.Double</td>
<td>NSNumber numberWithDouble:</td>
</tr>
<tr>
<td>String</td>
<td>java.lang.String</td>
<td>NSString</td>
</tr>
<tr>
<td>Uint8List</td>
<td>byte[]</td>
<td>FlutterStandardTypedData typedDataWithBytes:</td>
</tr>
<tr>
<td>Int32List</td>
<td>int[]</td>
<td>FlutterStandardTypedData typedDataWithInt32:</td>
</tr>
<tr>
<td>Int64List</td>
<td>long[]</td>
<td>FlutterStandardTypedData typedDataWithInt64:</td>
</tr>
<tr>
<td>Float64List</td>
<td>double[]</td>
<td>FlutterStandardTypedData typedDataWithFloat64:</td>
</tr>
<tr>
<td>List</td>
<td>java.util.ArrayList</td>
<td>NSArray</td>
</tr>
<tr>
<td>Map</td>
<td>java.util.HashMap</td>
<td>NSDictionary</td>
</tr>
</tbody></table>
<p><code>StandardMessageCodec</code> 中对基础数据类型的编码操作是在 <code>writeValue</code> 方法中完成的，而解码操作则是在 <code>readValue</code> 方法中完成。对基础数据类型和二进制数据相互转换感兴趣的小伙伴可以深入学习这两个方法。本文对此不再做介绍。</p>
<h4 id="MethodCodec"><a href="#MethodCodec" class="headerlink" title="MethodCodec"></a>MethodCodec</h4><p><code>MethodCodec</code> 用于二进制数据与方法调用和返回结果之间的编解码。<code>MethodChannel</code> 和 <code>EventChannel</code> 两个通道类型所使用的编解码器就是 <code>MethodCodec</code>。<code>MethodCodec</code> 的代码定义如下（<code>message_codec/MethodCodec</code>）：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodCodec</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">Encodes the specified [methodCall] into binary.</span></span></span><br><span class="line">  ByteData encodeMethodCall(MethodCall methodCall);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Decodes the specified [methodCall] from binary.</span></span></span><br><span class="line">  MethodCall decodeMethodCall(ByteData methodCall);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Decodes the specified result [envelope] from binary.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">Throws [PlatformException], if [envelope] represents an error, otherwise</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">returns the enveloped result.</span></span></span><br><span class="line">  <span class="built_in">dynamic</span> decodeEnvelope(ByteData envelope);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Encodes a successful [result] into a binary envelope.</span></span></span><br><span class="line">  ByteData encodeSuccessEnvelope(<span class="built_in">dynamic</span> result);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Encodes an error result into a binary envelope.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">The specified error [code], human-readable error [message], and error</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">[details] correspond to the fields of [PlatformException].</span></span></span><br><span class="line">  ByteData encodeErrorEnvelope(&#123;<span class="meta">@required</span> <span class="built_in">String</span> code, <span class="built_in">String</span> message, <span class="built_in">dynamic</span> details&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MethodCodec</code> 中各个方法的说明如下：</p>
<ul>
<li><code>ByteData encodeMethodCall</code>：编码方法调用</li>
<li><code>MethodCall decodeMethodCall</code>：解码方法调用</li>
<li><code>dynamic decodeEnvelope</code>：将方法调用的二进制数据解码</li>
<li><code>ByteData encodeSuccessEnvelope</code>：方法调用成功时，将 <code>result</code> 编码为二进制数据</li>
<li><code>ByteData encodeErrorEnvelope</code>：方法调用失败时，将 <code>code</code>、<code>message</code> 和 <code>details</code> 编码为二进制数据</li>
</ul>
<p>与 <code>MessageCodec</code> 所不同的是，<code>MethodCodec</code> 用于方法调用（方法对象）的编解码。一个方法对象代表一次从 <code>Flutter</code> 发起的一次方法调用。每个方法调用有两个成员变量（以 <code>MethodChannel</code> 的 <code>invokeMethod</code> 方法为例）：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;<span class="built_in">dynamic</span>&gt; invokeMethod(<span class="built_in">String</span> method, [<span class="built_in">dynamic</span> arguments]) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">assert</span>(method != <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">dynamic</span> result = <span class="keyword">await</span> BinaryMessages.send(</span><br><span class="line">    name,</span><br><span class="line">    codec.encodeMethodCall(MethodCall(method, arguments)),</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> MissingPluginException(<span class="string">&#x27;No implementation found for method <span class="subst">$method</span> on channel <span class="subst">$name</span>&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> codec.decodeEnvelope(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>method</code> 表示需要调用的方法名称，通用类型（<code>Android</code> 中的 <code>Object</code> 和 <code>iOS</code> 中的 <code>id</code>） <code>arguments</code> 表示需要调用的方法参数。</p>
<p>相对于 <code>MessageCodec</code>，<code>MethodCodec</code> 编解码器多了针对于调用结果的处理接口。当方法调用成功是，使用 <code>encodeSuccessEnvelope</code> 将 <code>result</code> 编码为二进制数据，而当方法调用失败时，则使用 <code>encodeErrorEnvelope</code> 将 <code>code</code>、<code>message</code> 和 <code>details</code> 编码为二进制数据。</p>
<p>在 <code>Flutter</code> 中，<code>MethodCodec</code> 有如下两种类型的定义（<code>message_codecs.dart</code>）：</p>
<ul>
<li><code>JSONMethodCodec</code>：编解码 <code>JSON</code> 类型的方法调用，实际上依赖于 <code>JSONMessageCodec</code></li>
<li><code>StandardMethodCodec</code>：<code>MethodCodec</code> 的默认实现，二进制类型的方法调用编解码器，实际上依赖于 <code>StandardMessageCodec</code></li>
</ul>
<h5 id="JSONMethodCodec"><a href="#JSONMethodCodec" class="headerlink" title="JSONMethodCodec"></a>JSONMethodCodec</h5><p><code>JSONMethodCodec</code> 用于 <code>UTF-8</code> 的 <code>JSON</code> 类型的方法调用与二进制数据之间的转换：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JSONMethodCodec</span> <span class="keyword">implements</span> <span class="title">MethodCodec</span> </span>&#123;</span><br><span class="line">  <span class="comment">// The codec serializes method calls, and result envelopes as outlined below.</span></span><br><span class="line">  <span class="comment">// This format must match the Android and iOS counterparts.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// * Individual values are serialized as defined by the JSON codec of the</span></span><br><span class="line">  <span class="comment">//   dart:convert package.</span></span><br><span class="line">  <span class="comment">// * Method calls are serialized as two-element maps, with the method name</span></span><br><span class="line">  <span class="comment">//   keyed by &#x27;method&#x27; and the arguments keyed by &#x27;args&#x27;.</span></span><br><span class="line">  <span class="comment">// * Reply envelopes are serialized as either:</span></span><br><span class="line">  <span class="comment">//   * one-element lists containing the successful result as its single</span></span><br><span class="line">  <span class="comment">//     element, or</span></span><br><span class="line">  <span class="comment">//   * three-element lists containing, in order, an error code String, an</span></span><br><span class="line">  <span class="comment">//     error message String, and an error details value.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Creates a [MethodCodec] with UTF-8 encoded JSON method calls and result</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">envelopes.</span></span></span><br><span class="line">  <span class="keyword">const</span> JSONMethodCodec();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ByteData encodeMethodCall(MethodCall call) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const</span> JSONMessageCodec().encodeMessage(&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt;&#123;</span><br><span class="line">      <span class="string">&#x27;method&#x27;</span>: call.method,</span><br><span class="line">      <span class="string">&#x27;args&#x27;</span>: call.arguments,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  MethodCall decodeMethodCall(ByteData methodCall) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">dynamic</span> decoded = <span class="keyword">const</span> JSONMessageCodec().decodeMessage(methodCall);</span><br><span class="line">    <span class="keyword">if</span> (decoded <span class="keyword">is</span>! <span class="built_in">Map</span>)</span><br><span class="line">      <span class="keyword">throw</span> FormatException(<span class="string">&#x27;Expected method call Map, got <span class="subst">$decoded</span>&#x27;</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">dynamic</span> method = decoded[<span class="string">&#x27;method&#x27;</span>];</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">dynamic</span> arguments = decoded[<span class="string">&#x27;args&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span> (method <span class="keyword">is</span> <span class="built_in">String</span>)</span><br><span class="line">      <span class="keyword">return</span> MethodCall(method, arguments);</span><br><span class="line">    <span class="keyword">throw</span> FormatException(<span class="string">&#x27;Invalid method call: <span class="subst">$decoded</span>&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">dynamic</span> decodeEnvelope(ByteData envelope) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">dynamic</span> decoded = <span class="keyword">const</span> JSONMessageCodec().decodeMessage(envelope);</span><br><span class="line">    <span class="keyword">if</span> (decoded <span class="keyword">is</span>! <span class="built_in">List</span>)</span><br><span class="line">      <span class="keyword">throw</span> FormatException(<span class="string">&#x27;Expected envelope List, got <span class="subst">$decoded</span>&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (decoded.length == <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> decoded[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (decoded.length == <span class="number">3</span></span><br><span class="line">        &amp;&amp; decoded[<span class="number">0</span>] <span class="keyword">is</span> <span class="built_in">String</span></span><br><span class="line">        &amp;&amp; (decoded[<span class="number">1</span>] == <span class="keyword">null</span> || decoded[<span class="number">1</span>] <span class="keyword">is</span> <span class="built_in">String</span>))</span><br><span class="line">      <span class="keyword">throw</span> PlatformException(</span><br><span class="line">        code: decoded[<span class="number">0</span>],</span><br><span class="line">        message: decoded[<span class="number">1</span>],</span><br><span class="line">        details: decoded[<span class="number">2</span>],</span><br><span class="line">      );</span><br><span class="line">    <span class="keyword">throw</span> FormatException(<span class="string">&#x27;Invalid envelope: <span class="subst">$decoded</span>&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ByteData encodeSuccessEnvelope(<span class="built_in">dynamic</span> result) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const</span> JSONMessageCodec().encodeMessage(&lt;<span class="built_in">dynamic</span>&gt;[result]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ByteData encodeErrorEnvelope(&#123;<span class="meta">@required</span> <span class="built_in">String</span> code, <span class="built_in">String</span> message, <span class="built_in">dynamic</span> details&#125;) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(code != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const</span> JSONMessageCodec().encodeMessage(&lt;<span class="built_in">dynamic</span>&gt;[code, message, details]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中可以看出，<code>JSONMethodCodec</code> 实际上是依赖 <code>JSONMessageCodec</code> 实现的。当使用 <code>JSONMethodCodec</code> 编码方法调用时，会先将方法调用转化为 <code>&#123;&quot;method&quot;:method,&quot;args&quot;:args&#125;</code>，然后通过 <code>JSONMessageCodec().encodeMessage</code> 完成调用。而 <code>JSONMethodCodec</code> 在编码调用结果 <code>result</code> 时，会先通过 <code>JSONMessageCodec().decodeMessage(envelope)</code> 将其转换为一个数组，如果调用成功，则通过 <code>JSONMessageCodec().encodeMessage(&lt;dynamic&gt;[result])</code> 将 <code>result</code> 编码为二进制数据，如果失败，则通过 <code>JSONMessageCodec().encodeMessage(&lt;dynamic&gt;[code, message, details])</code> 将 <code>code</code>、<code>message</code> 和 <code>details</code> 编码为二进制数据。该过程是在 <code>MethodChannel</code> 的 <code>_handleAsMethodCall</code> 完成的：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;ByteData&gt; _handleAsMethodCall(ByteData message, Future&lt;<span class="built_in">dynamic</span>&gt; handler(MethodCall call)) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> MethodCall call = codec.decodeMethodCall(message);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> codec.encodeSuccessEnvelope(<span class="keyword">await</span> handler(call));</span><br><span class="line">  &#125; <span class="keyword">on</span> PlatformException <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> codec.encodeErrorEnvelope(</span><br><span class="line">      code: e.code,</span><br><span class="line">      message: e.message,</span><br><span class="line">      details: e.details,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">on</span> MissingPluginException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> codec.encodeErrorEnvelope(code: <span class="string">&#x27;error&#x27;</span>, message: e.toString(), details: <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="StandardMethodCodec"><a href="#StandardMethodCodec" class="headerlink" title="StandardMethodCodec"></a>StandardMethodCodec</h5><p><code>StandardMethodCodec</code> 是 <code>MethodCodec</code> 的默认实现，主要用于基础数据类型与二进制数据之间的编解码。<code>StandardMethodCodec</code> 的实现依赖于 <code>StandardMessageCodec</code>：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StandardMethodCodec</span> <span class="keyword">implements</span> <span class="title">MethodCodec</span> </span>&#123;</span><br><span class="line">  <span class="comment">// The codec method calls, and result envelopes as outlined below. This format</span></span><br><span class="line">  <span class="comment">// must match the Android and iOS counterparts.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// * Individual values are encoded using [StandardMessageCodec].</span></span><br><span class="line">  <span class="comment">// * Method calls are encoded using the concatenation of the encoding</span></span><br><span class="line">  <span class="comment">//   of the method name String and the arguments value.</span></span><br><span class="line">  <span class="comment">// * Reply envelopes are encoded using first a single byte to distinguish the</span></span><br><span class="line">  <span class="comment">//   success case (0) from the error case (1). Then follows:</span></span><br><span class="line">  <span class="comment">//   * In the success case, the encoding of the result value.</span></span><br><span class="line">  <span class="comment">//   * In the error case, the concatenation of the encoding of the error code</span></span><br><span class="line">  <span class="comment">//     string, the error message string, and the error details value.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Creates a [MethodCodec] using the Flutter standard binary encoding.</span></span></span><br><span class="line">  <span class="keyword">const</span> StandardMethodCodec([<span class="keyword">this</span>.messageCodec = <span class="keyword">const</span> StandardMessageCodec()]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">The message codec that this method codec uses for encoding values.</span></span></span><br><span class="line">  <span class="keyword">final</span> StandardMessageCodec messageCodec;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ByteData encodeMethodCall(MethodCall call) &#123;</span><br><span class="line">    <span class="keyword">final</span> WriteBuffer buffer = WriteBuffer();</span><br><span class="line">    messageCodec.writeValue(buffer, call.method);</span><br><span class="line">    messageCodec.writeValue(buffer, call.arguments);</span><br><span class="line">    <span class="keyword">return</span> buffer.done();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  MethodCall decodeMethodCall(ByteData methodCall) &#123;</span><br><span class="line">    <span class="keyword">final</span> ReadBuffer buffer = ReadBuffer(methodCall);</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">dynamic</span> method = messageCodec.readValue(buffer);</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">dynamic</span> arguments = messageCodec.readValue(buffer);</span><br><span class="line">    <span class="keyword">if</span> (method <span class="keyword">is</span> <span class="built_in">String</span> &amp;&amp; !buffer.hasRemaining)</span><br><span class="line">      <span class="keyword">return</span> MethodCall(method, arguments);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">const</span> FormatException(<span class="string">&#x27;Invalid method call&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ByteData encodeSuccessEnvelope(<span class="built_in">dynamic</span> result) &#123;</span><br><span class="line">    <span class="keyword">final</span> WriteBuffer buffer = WriteBuffer();</span><br><span class="line">    buffer.putUint8(<span class="number">0</span>);</span><br><span class="line">    messageCodec.writeValue(buffer, result);</span><br><span class="line">    <span class="keyword">return</span> buffer.done();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ByteData encodeErrorEnvelope(&#123;<span class="meta">@required</span> <span class="built_in">String</span> code, <span class="built_in">String</span> message, <span class="built_in">dynamic</span> details&#125;) &#123;</span><br><span class="line">    <span class="keyword">final</span> WriteBuffer buffer = WriteBuffer();</span><br><span class="line">    buffer.putUint8(<span class="number">1</span>);</span><br><span class="line">    messageCodec.writeValue(buffer, code);</span><br><span class="line">    messageCodec.writeValue(buffer, message);</span><br><span class="line">    messageCodec.writeValue(buffer, details);</span><br><span class="line">    <span class="keyword">return</span> buffer.done();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">dynamic</span> decodeEnvelope(ByteData envelope) &#123;</span><br><span class="line">    <span class="comment">// First byte is zero in success case, and non-zero otherwise.</span></span><br><span class="line">    <span class="keyword">if</span> (envelope.lengthInBytes == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">const</span> FormatException(<span class="string">&#x27;Expected envelope, got nothing&#x27;</span>);</span><br><span class="line">    <span class="keyword">final</span> ReadBuffer buffer = ReadBuffer(envelope);</span><br><span class="line">    <span class="keyword">if</span> (buffer.getUint8() == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> messageCodec.readValue(buffer);</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">dynamic</span> errorCode = messageCodec.readValue(buffer);</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">dynamic</span> errorMessage = messageCodec.readValue(buffer);</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">dynamic</span> errorDetails = messageCodec.readValue(buffer);</span><br><span class="line">    <span class="keyword">if</span> (errorCode <span class="keyword">is</span> <span class="built_in">String</span> &amp;&amp; (errorMessage == <span class="keyword">null</span> || errorMessage <span class="keyword">is</span> <span class="built_in">String</span>) &amp;&amp; !buffer.hasRemaining)</span><br><span class="line">      <span class="keyword">throw</span> PlatformException(code: errorCode, message: errorMessage, details: errorDetails);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">const</span> FormatException(<span class="string">&#x27;Invalid envelope&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用 <code>StandardMethodCodec</code> 编码方法调用时，会先通过 <code>StandardMessageCodec</code> 的 <code>writeValue</code> 将 <code>call.method</code> 和 <code>call.arguments</code> 写入 <code>buffer</code>。在解码方法调用时，会通过 <code>readValue</code> 将写入的二进制数据取出。</p>
<p>在编码调用结果时，如果调用成功，则会先向 <code>buffer</code> 中写入数据 0（表示调用成功），然后再写入编码后的 <code>result</code>。如果调用失败，则先向 <code>buffer</code> 中写入 1（表示调用失败），然后再写入 编码后的 <code>code</code>、<code>message</code> 和 <code>details</code>。该过程也是在 <code>MethodChannel</code> 的 <code>_handleAsMethodCall</code> 方法中实现的。</p>
<h3 id="消息处理器"><a href="#消息处理器" class="headerlink" title="消息处理器"></a>消息处理器</h3><p>当我们接收到二进制消息，并通过 <code>codec</code> 对象将消息处理为消息处理器能够是别的数据之后，消息处理器才开始工作：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Future&lt;ByteData&gt; send(<span class="built_in">String</span> channel, ByteData message) &#123;</span><br><span class="line">  <span class="keyword">final</span> _MessageHandler handler = _mockHandlers[channel];</span><br><span class="line">  <span class="keyword">if</span> (handler != <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> handler(message);</span><br><span class="line">  <span class="keyword">return</span> _sendPlatformMessage(channel, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以通道类型一一对应的，<code>Flutter</code> 中定义了三种消息处理器：</p>
<ul>
<li><code>MessageHandler</code>： 用于处理字符串或者半结构化的消息类型，对应 <code>BasicMessageChannel</code></li>
<li><code>MethodHandler</code>： 用于处理方法的调用，对应 <code>MethodChannel</code></li>
<li><code>StreamHandler</code>： 用于处理事件流，对应 <code>EventChannel</code></li>
</ul>
<h2 id="path-provider"><a href="#path-provider" class="headerlink" title="path_provider"></a>path_provider</h2><p>为了学习方便，肥肥基于官方 <a href="https://github.com/flutter/plugins/tree/master/packages/path_provider">path_provider/path_provider.dart</a> 项目重新在 <code>Github</code> 进行了部署： <a href="https://github.com/fiissh/path_provider">fiissh/path_provider</a>。需要的小伙伴可以自行 <code>clone</code>。</p>
<p>在 <code>Android Studio</code>（请确保环境已经正确配置） 中打开项目，我们首先来看一下 <code>lib/path_provider.dart</code> 文件。该文件中定义了三个方法：</p>
<ul>
<li><code>Future&lt;Directory&gt; getTemporaryDirectory()</code></li>
<li><code>Future&lt;Directory&gt; getApplicationDocumentsDirectory()</code></li>
<li><code>Future&lt;Directory&gt; getExternalStorageDirectory()</code></li>
</ul>
<p>以及在文件开头的位置定义了一个编译时常量 <code>_channel</code>：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MethodChannel _channel = MethodChannel(<span class="string">&#x27;plugins.flutter.io/path_provider&#x27;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>path_provider</code> 主要使用了三种平台通道类型中的 <code>MethodChannel</code> 通道。<code>plugins.flutter.io/path_provider</code> 作为 <code>MethodChannel</code> 构造参数，在其初始化时将会作为该通道的唯一标识。</p>
</blockquote>
<h3 id="getTemporaryDirectory-和-getApplicationDocumentsDirectory-方法"><a href="#getTemporaryDirectory-和-getApplicationDocumentsDirectory-方法" class="headerlink" title="getTemporaryDirectory() 和 getApplicationDocumentsDirectory() 方法"></a>getTemporaryDirectory() 和 getApplicationDocumentsDirectory() 方法</h3><p>实际上两个方法的实现机制是一样的。我们只分析 <code>getApplicationDocumentsDirectory()</code> 方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;Directory&gt; getApplicationDocumentsDirectory() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">// TODO(amirh): remove this on when the invokeMethod update makes it to stable Flutter.</span></span><br><span class="line">  <span class="comment">// https://github.com/flutter/flutter/issues/26431</span></span><br><span class="line">  <span class="comment">// ignore: strong_mode_implicit_dynamic_method</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> path = <span class="keyword">await</span> _channel.invokeMethod(<span class="string">&#x27;getApplicationDocumentsDirectory&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Directory(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法的定义非常简单，最关键的代码只有一行：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="built_in">String</span> path = <span class="keyword">await</span> _channel.invokeMethod(<span class="string">&#x27;getApplicationDocumentsDirectory&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>其作用是通过 <code>_channel</code> 通道的 <code>invokeMethod</code> 方法调用 <code>Android</code> 和 <code>iOS</code> 平台上的 <code>getApplicationDocumentsDirectory</code> 方法，并在调用之后返回 <code>String</code> 类型的返回值 <code>path</code>。</p>
<p>现在我们比较明确的一点是，<code>getApplicationDocumentsDirectory()</code> 方法调用之后会通过 <code>MethodChannel</code> 平台通道调用 <code>Android</code> 或 <code>iOS</code> 上的 <code>getApplicationDocumentsDirectory</code> 方法。</p>
<p><code>Android</code> 或者 <code>iOS</code> 设备是如何知道 <code>Flutter</code> 的具体调用意图的呢？</p>
<p>我们进入到 <code>path_provider</code> 项目的 <code>Android</code> 部分（项目右键-<code>Flutter</code>-<code>Open Android module in Android Studio</code>）可以看到，在 <code>io.flutter.plugins.pathprovider</code> 包下有一个 <code>PathProviderPlugin.java</code> 类。该类继承自 <code>MethodCallHandler</code> 并实现了 <code>onMethodCall</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMethodCall</span><span class="params">(MethodCall call, Result result)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (call.method) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;getTemporaryDirectory&quot;</span>:</span><br><span class="line">      result.success(getPathProviderTemporaryDirectory());</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;getApplicationDocumentsDirectory&quot;</span>:</span><br><span class="line">      result.success(getPathProviderApplicationDocumentsDirectory());</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;getStorageDirectory&quot;</span>:</span><br><span class="line">      result.success(getPathProviderStorageDirectory());</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      result.notImplemented();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 <code>IntelliJ IDEA</code> 时，使用项目右键-<code>Flutter</code>-<code>Open Android module in Android Studio</code> 的方式可能会出现无法打开的情况。此时建议使用 <code>Android Studio</code>。</p>
</blockquote>
<p><code>onMethodCall</code> 方法接收来自 <code>Flutter</code> 端传递过来的 <code>call</code> 和 <code>result</code> 两个参数。其中，<code>call</code> 对象存储了我们需要调用的方法名称（比如，<code>Flutter</code> 层需要调用的方法为 <code>getApplicationDocumentsDirectory</code>，通过 <code>call.method</code> 属性实现与 <code>Android</code> 端方法的对应）。<code>result</code> 对象则负责将 <code>Android</code> 端方法调用的结果传递回 <code>Flutter</code> 层。</p>
<p>静态方法 <code>registerWith</code> 则用于创建 <code>MethodChannel</code> 对象以及初始化 <code>PathProviderPlugin</code> 对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerWith</span><span class="params">(Registrar registrar)</span> </span>&#123;</span><br><span class="line">  MethodChannel channel = <span class="keyword">new</span> MethodChannel(registrar.messenger(), <span class="string">&quot;plugins.flutter.io/path_provider&quot;</span>);</span><br><span class="line">  PathProviderPlugin instance = <span class="keyword">new</span> PathProviderPlugin(registrar);</span><br><span class="line">  channel.setMethodCallHandler(instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过在 <code>Android</code> 端初始化一个 <code>MethodChannel</code> 对象，并设置与 <code>Flutter</code> 端一样的平台通道唯一标识（<code>plugins.flutter.io/path_provider</code>），可以实现 <code>Flutter</code> 端和设备端的平台通道的映射。<code>PathProviderPlugin</code> 作为消息处理器的具体实现（<code>MethodCallHandler</code>），通过 <code>channel.setMethodCallHandler(instance)</code> 实现了平台通道与消息处理器的对应关系。</p>
<p>在实现了平台通道与消息处理器之间的对应关系之后，来自 <code>Flutter</code> 层的调用又是如何准确的知道消息处理器的位置呢？<code>path_provider</code> 的示例项目的 <code>Android</code> 部分给了我们答案（<code>io.flutter.plugins</code> 包）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneratedPluginRegistrant</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerWith</span><span class="params">(PluginRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (alreadyRegisteredWith(registry)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PathProviderPlugin.registerWith(registry.registrarFor(<span class="string">&quot;io.flutter.plugins.pathprovider.PathProviderPlugin&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">alreadyRegisteredWith</span><span class="params">(PluginRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String key = GeneratedPluginRegistrant.class.getCanonicalName();</span><br><span class="line">    <span class="keyword">if</span> (registry.hasPlugin(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    registry.registrarFor(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>io.flutter.plugins.pathprovider.PathProviderPlugin</code> 是我们的消息处理器的绝对路径。该过程将消息处理器的对决路径注册到 <code>Flutter</code> 在设备端的引擎中，然后通过 <code>Flutter</code> 端和设备端设置的通道唯一标识将平台通道、消息处理器实现一一对应的关系。</p>
<p>静态方法 <code>registerWith</code> 在 <code>Flutter</code> 应用项目的唯一一个 <code>Activity</code>（<code>Android</code> 端）中被调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">FlutterActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    GeneratedPluginRegistrant.registerWith(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getExternalStorageDirectory"><a href="#getExternalStorageDirectory" class="headerlink" title="getExternalStorageDirectory()"></a>getExternalStorageDirectory()</h3><p>在实现原理上，<code>getExternalStorageDirectory()</code> 与其他另外两个方法并没有实际的区别。<code>getExternalStorageDirectory()</code> 比较特殊的地方在于，通过在 <code>Flutter</code> 端使用 <code>Platform.isIOS</code> 方法判断设备是否是 <code>iOS</code>，以此达到判断平台的目的。这也就意味着，<code>iOS</code> 设备上使用 <code>Flutter</code> 调用 <code>getExternalStorageDirectory()</code> 方法将会抛出一个异常：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;Directory&gt; getExternalStorageDirectory() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (Platform.isIOS)</span><br><span class="line">    <span class="keyword">throw</span> UnsupportedError(<span class="string">&quot;Functionality not available on iOS&quot;</span>);</span><br><span class="line">  <span class="comment">// TODO(amirh): remove this on when the invokeMethod update makes it to stable Flutter.</span></span><br><span class="line">  <span class="comment">// https://github.com/flutter/flutter/issues/26431</span></span><br><span class="line">  <span class="comment">// ignore: strong_mode_implicit_dynamic_method</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> path = <span class="keyword">await</span> _channel.invokeMethod(<span class="string">&#x27;getStorageDirectory&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Directory(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Platform</code> 类（<code>platform.dart</code> 文件，<code>dart.io</code> 库）定义了大量的当前设备环境相关的信息，其中包括判断当前设备类型、获取设备操作系统相关信息等。关于 <code>Platform</code> 类的详细信息，请移步 <code>Flutter</code> 官方文档 <a href="https://docs.flutter.io/flutter/dart-io/Platform-class.html">Platform class</a>。</p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>MethodChannel</tag>
        <tag>EventChannel</tag>
        <tag>BasicMessageChannel</tag>
        <tag>Flutter 平台相关</tag>
        <tag>Platform</tag>
        <tag>Handler</tag>
        <tag>codec</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter 开发（08）：Flutter 插件开发（flutter_file_path_provide）</title>
    <url>/index.html//2019/flutter-plugin-file-path-provider.html</url>
    <content><![CDATA[<p>本文主要介绍 <code>Flutter</code> 插件开发的相关内容，并在 <a href="https://github.com/flutter/plugins/tree/master/packages/path_provider">path_provider/path_provider.dart</a> 插件项目的基础上开发我们自己的 <code>flutter_file_path_provide</code> 插件。</p>
<p>本文中涉及到的主要技术是基于 <a href="https://fiissh.tech/2019/flutter-platform-specific.html">Flutter 开发（07）：编写平台相关的代码</a>。当然，在我们的 <code>flutter_file_path_provide</code> 插件项目中只使用到了 <code>MethodChannel</code>。另外两种平台通道我们将在其他文章中介绍。</p>
<p>由于肥肥从事 <code>Android SDK</code> 开发，所以 <code>flutter_file_path_provide</code> 插件项目中的 <code>iOS</code> 部分在本文撰写时并没有实现。</p>
<span id="more"></span>
<h2 id="创建插件项目"><a href="#创建插件项目" class="headerlink" title="创建插件项目"></a>创建插件项目</h2><p>第一步，打开 <code>Android Studio</code>，在首页面选择 <code>Start a new Flutter project</code>：</p>
<p><img src="/images/android-studio-welcome-page.jpg" alt="android-studio-welcome-page.jpg"></p>
<p>第二步，在 <code>New Flutter Project</code> 页面选择 <code>Flutter Plugin</code>，然后点击 <code>Next</code>：</p>
<p><img src="/images/android-studio-select-flutter-plugin.jpg" alt="android-studio-select-flutter-plugin.jpg"></p>
<p>第三步，在 <code>Configure the new Flutter plugin</code> 界面填写相关的项目信息（<code>flutter_file_path_provide</code>），然后点击 <code>Next</code>：</p>
<p><img src="/images/configure-new-flutter-plugin.jpg" alt="configure-new-flutter-plugin.jpg"></p>
<p>第四步，在 <code>Set the package name</code> 页面填写包名等信息（<code>tech.fiissh.flutter.plugin.path</code>），然后点击 <code>Finish</code>：</p>
<p><img src="/images/set-package-name.jpg" alt="set-package-name.jpg"></p>
<p>如果我们的 <code>Android</code> 和 <code>iOS</code> 的部分需要使用 <code>Kotlin</code> 和 <code>Swift</code> 进行开发，请分别勾选 <code>Include Kotlin support for Android code</code> 和 <code>Include Swift support for iOS code</code>。默认情况下 <code>Android</code> 将使用 <code>Java</code> 语言，<code>iOS</code> 将使用 <code>Object-C</code> 语言。</p>
<p>本文中 <code>Android</code> 部分将使用 <code>Java</code> 语言进行开发。</p>
<p>第五步，等待项目构建完成之后，我们将得到如下项目结构：</p>
<p><img src="/images/flutter-project.jpg" alt="flutter-project.jpg"></p>
<p>其中，<code>android</code> 目录是我们插件的 <code>Android</code> 部分的项目，用于编写 <code>Android</code> 的源代码。<code>ios</code> 目录是插件的 <code>iOS</code> 部分的项目，用于编写 <code>iOS</code> 的源代码。<code>example</code> 目录是我们插件项目的示例项目，其中包含了 <code>android</code> 和 <code>iOS</code> 两个平台的 <code>Module</code>。<code>lib</code> 目录则是我们编写 <code>Dart</code> 代码的地方。</p>
<p>虽然我们在创建项目的过程中填写的包名为 <code>tech.fiissh.flutter.plugin.path</code>，但是项目创建完成之后，插件的 <code>Android</code> 部分的包名则为 <code>tech.fiissh.flutter.plugin.flutter_file_path_provide</code>，而 <code>example</code> 的 <code>Android</code> 部分的包名则为 <code>tech.fiissh.flutter.plugin.flutter_file_path_provide_example</code>。如果我们需要修改包名，请将对应项目的 <code>AndroidManifest.xml</code> 文件中的 <code>package</code> 属性、<code>build.gradle</code> 文件中的 <code>applicationId</code> 属性都进行修改。修改之后，插件部分我们使用 <code>tech.fiissh.flutter.plugin.path</code> 包名，<code>example</code> 部分我们使用 <code>tech.fiissh.flutter.sample.path</code> 包名。</p>
<p>需要注意的是，修改报名之后，我们需要将项目根目录的 <code>pubspec.yaml</code> 文件中的 <code>plugin</code> 属性修改为新的包名：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">flutter:</span></span><br><span class="line">  <span class="comment"># This section identifies this Flutter project as a plugin project.</span></span><br><span class="line">  <span class="comment"># The androidPackage and pluginClass identifiers should not ordinarily</span></span><br><span class="line">  <span class="comment"># be modified. They are used by the tooling to maintain consistency when</span></span><br><span class="line">  <span class="comment"># adding or updating assets for this project.</span></span><br><span class="line">  <span class="attr">plugin:</span></span><br><span class="line">    <span class="attr">androidPackage:</span> <span class="string">tech.fiissh.flutter.plugin.path</span></span><br><span class="line">    <span class="attr">pluginClass:</span> <span class="string">FlutterFilePathProvidePlugin</span></span><br></pre></td></tr></table></figure>

<h2 id="开发插件"><a href="#开发插件" class="headerlink" title="开发插件"></a>开发插件</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>我们插件的主要功能是获取对应设备平台上的可用的存储目录，并将该目录的绝对地址实例化为 <code>Directory</code> 对象。根据 <code>Android</code> 和 <code>iOS</code> 上常用的存储目录，我们总结出几个不同的目录，对应的 <code>Flutter</code> 层的方法如下：</p>
<ul>
<li><code>getExternalStorageDirectory</code>：<code>Android</code> 平台下读取外部存储的路径，即 <code>SD</code> 卡目录，例如 <code>/storage/sdcard0/</code></li>
<li><code>getExternalStorageApplicationTemporaryDirectory</code>：<code>Android</code> 平台下外部存储的缓存目录，例如 <code>/storage/emulated/0/Android/data/tech.fiissh.sample.path/temp/</code></li>
<li><code>getInternalStorageApplicationTemporaryDirectory</code>： <code>Android</code> 平台下内部存储的缓存目录，例如 <code>/data/user/0/tech.fiissh.flutter.sample.path/temp/</code></li>
<li><code>getExternalStorageApplicationCacheDirectory</code>: <code>Android</code> 平台下的外部存储的应用程序缓存目录，例如 <code>/storage/emulated/0/Android/data/tech.fiissh.sample.path/cache/</code></li>
<li><code>getInternalStorageApplicationCacheDirectory</code>：<code>Android </code> 平台下的内部存储的应用程序缓存目录，例如 <code>/data/user/0/tech.fiissh.flutter.sample.path/cache/</code></li>
<li><code>getExternalStorageApplicationDirectory</code>： <code>Android</code> 平台下外部存储的应用程序目录，例如 <code>/storage/emulated/0/Android/data/tech.fiissh.sample.path/files/</code></li>
<li><code>getInternalStorageApplicationDirectory</code>： <code>Android</code> 平台下内部存储的应用程序目录，例如 <code>/data/user/0/tech.fiissh.flutter.sample.path/files/</code></li>
</ul>
<h3 id="插件的开发"><a href="#插件的开发" class="headerlink" title="插件的开发"></a>插件的开发</h3><h4 id="Flutter-层的开发"><a href="#Flutter-层的开发" class="headerlink" title="Flutter 层的开发"></a>Flutter 层的开发</h4><p>项目创建完成之后，<code>Android Studio</code> 已经为我们创建了一个简单的获取设备平台操作系统版本号的示例。</p>
<p>我们打开 <code>lib/flutter_file_path_provide.dart</code> 文件，删除 <code>platformVersion</code> 方法，得到如下代码：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterFilePathProvide</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> MethodChannel _channel = <span class="keyword">const</span> MethodChannel(<span class="string">&#x27;flutter_file_path_provide&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>FlutterFilePathProvide</code> 类中已经默认创建了一个名称为 <code>flutter_file_path_provide</code> 的 <code>MethodChannel</code> 对象 <code>_channel</code>。</p>
<p>根据我们在需求分析中定义的方法，我们得到如下 <code>FlutterFilePathProvide</code> 类：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterFilePathProvide</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> FlutterFilePathProvide();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">String</span> _METHOD_CHANNEL_NAME = <span class="string">&#x27;fiissh.flutter.plugin/flutter_file_path_provide&#x27;</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> MethodChannel _channel = <span class="keyword">const</span> MethodChannel(_METHOD_CHANNEL_NAME);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">String</span> _EXTERNAL_STORAGE_DIRECTORY_METHOD_NAME = <span class="string">&quot;getExternalStorageDirectory&quot;</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">String</span> _EXTERNAL_STORAGE_APPLICATION_TEMPORARY_DIRECTORY = <span class="string">&quot;getExternalStorageApplicationTemporaryDirectory&quot;</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">String</span> _INTERNAL_STORAGE_APPLICATION_TEMPORARY_DIRECTORY = <span class="string">&quot;getInternalStorageApplicationTemporaryDirectory&quot;</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">String</span> _EXTERNAL_STORAGE_APPLICATION_CACHE_DIRECTORY_METHOD_NAME = <span class="string">&quot;getExternalStorageApplicationCacheDirectory&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">String</span> _EXTERNAL_STORAGE_APPLICATION_DIRECTORY_METHOD_NAME = <span class="string">&quot;getExternalStorageApplicationDirectory&quot;</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">String</span> _INTERNAL_STORAGE_APPLICATION_CACHE_DIRECTOR_METHOD_NAME = <span class="string">&quot;getInternalStorageApplicationCacheDirectory&quot;</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">String</span> _INTERNAL_STORAGE_APPLICATION_DIRECTOR_METHOD_NAME = <span class="string">&quot;getInternalStorageApplicationDirectory&quot;</span>;</span><br><span class="line"></span><br><span class="line">  Future&lt;Result&gt; getExternalStorageDirectory() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _getDirectory(_EXTERNAL_STORAGE_DIRECTORY_METHOD_NAME);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;Result&gt; getExternalStorageApplicationCacheDirectory() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _getDirectory(_EXTERNAL_STORAGE_APPLICATION_CACHE_DIRECTORY_METHOD_NAME);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;Result&gt; getInternalStorageApplicationCacheDirectory() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _getDirectory(_INTERNAL_STORAGE_APPLICATION_CACHE_DIRECTOR_METHOD_NAME);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;Result&gt; getExternalStorageApplicationDirectory() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _getDirectory(_EXTERNAL_STORAGE_APPLICATION_DIRECTORY_METHOD_NAME);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;Result&gt; getInternalStorageApplicationDirectory() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _getDirectory(_INTERNAL_STORAGE_APPLICATION_DIRECTOR_METHOD_NAME);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;Result&gt; getExternalStorageApplicationTemporaryDirectory() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _getDirectory(_EXTERNAL_STORAGE_APPLICATION_TEMPORARY_DIRECTORY);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;Result&gt; getInternalStorageApplicationTemporaryDirectory() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _getDirectory(_INTERNAL_STORAGE_APPLICATION_TEMPORARY_DIRECTORY);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;Result&gt; _getDirectory(<span class="built_in">String</span> methodName, [<span class="built_in">String</span> extra]) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="built_in">String</span> path;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      path = <span class="keyword">await</span> _channel.invokeMethod(methodName, extra);</span><br><span class="line">      <span class="built_in">print</span>(path);</span><br><span class="line">      <span class="keyword">return</span> Result(Result.ERROR_CODE_SUCCESS, <span class="string">&#x27;success&#x27;</span>, Directory(<span class="string">&#x27;<span class="subst">$path</span>/&#x27;</span>));</span><br><span class="line">    &#125; <span class="keyword">on</span> PlatformException <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">return</span> Result(<span class="built_in">num</span>.parse(e.code), e.message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>_getDirectory(String methodName, [String extra])</code> 方法是所有方法调用的核心。其作用是 <code>_channel</code> 对象根据传递进来的 <code>methodName</code> 参数以及可选参数 <code>extra</code>，将调用传递到设备平台上与 <code>MethodChannel</code> 对应的 <code>MethodCallHandler</code>（<code>android/src/main/java/tech.fiissh.flutter.plugin.path/FlutterFilePathProvidePlugin</code>）对象。</p>
<p><code>MethodChannel</code> 类除了 <code>name</code> 和 <code>codec</code> 属性之外，还有另外几个重要的方法：</p>
<ul>
<li><code>Future&lt;T&gt; invokeMethod&lt;T&gt;(String method, [dynamic arguments])</code></li>
<li><code>Future&lt;List&lt;T&gt;&gt; invokeListMethod&lt;T&gt;(String method, [dynamic arguments])</code></li>
<li><code>Future&lt;Map&lt;K, V&gt;&gt; invokeMapMethod&lt;K, V&gt;(String method, [dynamic arguments])</code></li>
</ul>
<p>上述三个方法，是 <code>MethodChannel</code> 方法调用最常用的方法。通过泛型的定义方式，使得其返回值可以有多种类型。另外的两个方法 <code>setMethodCallHandler</code> 和 <code>setMockMethodCallHandler</code> 则是用于设备平台通过平台通道调用 <code>Flutter</code> 层方法时使用。</p>
<p>我们重点说一下 <code>_getDirectory</code> 方法。该方法是 <code>Flutter</code> 层发起调用并处理结果的最核心的方法。我们看到 <code>await _channel.invokeMethod(methodName, extra);</code> 调用之后会得到返回值 <code>path</code>，此时 <code>path</code> 就是我们需要的结果（<code>path</code> 为空的情况已经在 <code>Android</code> 端进行了判断）。此处通过异常捕获的方式捕获了 <code>PlatformException</code> 对象，并将该异常信息写入到 <code>Result</code> 中并返回。那么，<code>PlatformException</code> 是如何产生的呢？我们将会在 <code>Android</code> 端代码实现中做讲解。</p>
<p><code>Result</code> 类用于对外提供结果，其定义如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">调用成功，此时 <span class="emphasis">_directory 不为 null</span></span></span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">int</span> ERROR_CODE_SUCCESS = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown"><span class="emphasis">调用失败，设备平台返回值为空</span></span></span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">int</span> ERROR_CODE_UN_SUCCESS_NULL = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown"><span class="emphasis">调用失败，设备平台出现异常</span></span></span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">int</span> ERROR_CODE_UN_SUCCESS_EXCEPTION = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown"><span class="emphasis"> 调用失败，没有对应的方法</span></span></span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">int</span> ERROR_CODE_UN_SUCCESS_NOT_IMPLEMENT_METHOD = <span class="number">3</span>;</span><br><span class="line">  Directory _directory;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> _errorCode = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">String</span> _errorMessage = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  Result(<span class="keyword">this</span>._errorCode, [<span class="keyword">this</span>._errorMessage, <span class="keyword">this</span>._directory]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> errorMessage =&gt; _errorMessage;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> errorCode =&gt; _errorCode;</span><br><span class="line"></span><br><span class="line">  Directory <span class="keyword">get</span> directory =&gt; _directory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Android-端的开发"><a href="#Android-端的开发" class="headerlink" title="Android 端的开发"></a>Android 端的开发</h4><p><code>Flutter</code> 层的代码开发完成之后，我们调用 <code>Flutter</code> 的方法，该方法将最终在 <code>Android</code> 端产生响应。</p>
<p><code>Android</code> 层的代码实现在类 <code>FlutterFilePathProvidePlugin.java</code> 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.fiissh.flutter.plugin.path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Environment;</span><br><span class="line"><span class="keyword">import</span> android.text.TextUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.flutter.plugin.common.MethodCall;</span><br><span class="line"><span class="keyword">import</span> io.flutter.plugin.common.MethodChannel;</span><br><span class="line"><span class="keyword">import</span> io.flutter.plugin.common.MethodChannel.MethodCallHandler;</span><br><span class="line"><span class="keyword">import</span> io.flutter.plugin.common.MethodChannel.Result;</span><br><span class="line"><span class="keyword">import</span> io.flutter.plugin.common.PluginRegistry.Registrar;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FlutterFilePathProvidePlugin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlutterFilePathProvidePlugin</span> <span class="keyword">implements</span> <span class="title">MethodCallHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String _METHOD_CHANNEL_NAME = <span class="string">&quot;fiissh.flutter.plugin/flutter_file_path_provide&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String _EXTERNAL_STORAGE_DIRECTORY_METHOD_NAME = <span class="string">&quot;getExternalStorageDirectory&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String _EXTERNAL_STORAGE_APPLICATION_CACHE_DIRECTORY_METHOD_NAME = <span class="string">&quot;getExternalStorageApplicationCacheDirectory&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String _EXTERNAL_STORAGE_APPLICATION_TEMPORARY_DIRECTORY = <span class="string">&quot;getExternalStorageApplicationTemporaryDirectory&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String _INTERNAL_STORAGE_APPLICATION_TEMPORARY_DIRECTORY = <span class="string">&quot;getInternalStorageApplicationTemporaryDirectory&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String _EXTERNAL_STORAGE_APPLICATION_DIRECTORY_METHOD_NAME = <span class="string">&quot;getExternalStorageApplicationDirectory&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String _INTERNAL_STORAGE_APPLICATION_CACHE_DIRECTOR_METHOD_NAME = <span class="string">&quot;getInternalStorageApplicationCacheDirectory&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String _INTERNAL_STORAGE_APPLICATION_DIRECTOR_METHOD_NAME = <span class="string">&quot;getInternalStorageApplicationDirectory&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Registrar registrar;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Plugin registration.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerWith</span><span class="params">(Registrar registrar)</span> </span>&#123;</span><br><span class="line">        FlutterFilePathProvidePlugin.registrar = registrar;</span><br><span class="line">        <span class="keyword">final</span> MethodChannel channel = <span class="keyword">new</span> MethodChannel(registrar.messenger(), _METHOD_CHANNEL_NAME);</span><br><span class="line">        channel.setMethodCallHandler(<span class="keyword">new</span> FlutterFilePathProvidePlugin());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMethodCall</span><span class="params">(MethodCall call, Result result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (TextUtils.equals(call.method, _EXTERNAL_STORAGE_DIRECTORY_METHOD_NAME)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String path = getExternalStorageDirectory();</span><br><span class="line">                <span class="keyword">if</span> (TextUtils.isEmpty(path)) &#123;</span><br><span class="line">                    result.error(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;path is null&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.success(path);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                result.error(<span class="string">&quot;2&quot;</span>, e.getMessage(), <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TextUtils.equals(call.method, _EXTERNAL_STORAGE_APPLICATION_TEMPORARY_DIRECTORY)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String path = getExternalStorageApplicationTemporaryDirectory();</span><br><span class="line">                <span class="keyword">if</span> (TextUtils.isEmpty(path)) &#123;</span><br><span class="line">                    result.error(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;path is null&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.success(path);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                result.error(<span class="string">&quot;2&quot;</span>, e.getMessage(), <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TextUtils.equals(call.method, _INTERNAL_STORAGE_APPLICATION_TEMPORARY_DIRECTORY)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String path = getInternalStorageApplicationTemporaryDirectory();</span><br><span class="line">                <span class="keyword">if</span> (TextUtils.isEmpty(path)) &#123;</span><br><span class="line">                    result.error(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;path is null&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.success(path);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                result.error(<span class="string">&quot;2&quot;</span>, e.getMessage(), <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TextUtils.equals(call.method, _EXTERNAL_STORAGE_APPLICATION_CACHE_DIRECTORY_METHOD_NAME)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String path = getExternalStorageApplicationCacheDirectory();</span><br><span class="line">                <span class="keyword">if</span> (TextUtils.isEmpty(path)) &#123;</span><br><span class="line">                    result.error(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;path is null&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.success(path);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                result.error(<span class="string">&quot;2&quot;</span>, e.getMessage(), <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TextUtils.equals(call.method, _EXTERNAL_STORAGE_APPLICATION_DIRECTORY_METHOD_NAME)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String path = getExternalStorageApplicationDirectory();</span><br><span class="line">                <span class="keyword">if</span> (TextUtils.isEmpty(path)) &#123;</span><br><span class="line">                    result.error(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;path is null&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.success(path);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                result.error(<span class="string">&quot;2&quot;</span>, e.getMessage(), <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TextUtils.equals(call.method, _INTERNAL_STORAGE_APPLICATION_CACHE_DIRECTOR_METHOD_NAME)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String path = getInternalStorageApplicationCacheDirectory();</span><br><span class="line">                <span class="keyword">if</span> (TextUtils.isEmpty(path)) &#123;</span><br><span class="line">                    result.error(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;path is null&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.success(path);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                result.error(<span class="string">&quot;2&quot;</span>, e.getMessage(), <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TextUtils.equals(call.method, _INTERNAL_STORAGE_APPLICATION_DIRECTOR_METHOD_NAME)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String path = getInternalStorageApplicationDirectory();</span><br><span class="line">                <span class="keyword">if</span> (TextUtils.isEmpty(path)) &#123;</span><br><span class="line">                    result.error(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;path is null&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.success(path);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                result.error(<span class="string">&quot;2&quot;</span>, e.getMessage(), <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.error(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;method notImplemented&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getExternalStorageDirectory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Environment.getExternalStorageDirectory().getAbsolutePath();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getExternalStorageApplicationTemporaryDirectory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> registrar.activeContext().getExternalCacheDir().getParent() + <span class="string">&quot;/temp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getInternalStorageApplicationTemporaryDirectory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> registrar.activeContext().getCacheDir().getParent() + <span class="string">&quot;/temp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getExternalStorageApplicationCacheDirectory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> registrar.activeContext().getExternalCacheDir().getAbsolutePath();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getInternalStorageApplicationCacheDirectory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> registrar.activeContext().getCacheDir().getAbsolutePath();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getExternalStorageApplicationDirectory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> registrar.activeContext().getExternalFilesDir(<span class="keyword">null</span>).getAbsolutePath();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 内部存储</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getInternalStorageApplicationDirectory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> registrar.activeContext().getFilesDir().getAbsolutePath();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>FlutterFilePathProvidePlugin</code> 继承自 <code>MethodCallHandler</code> 并实现了 <code>onMethodCall(MethodCall call, Result result)</code>。该方法的作用是接收来自于 <code>Flutter</code> 层的方法调用，并将方法名称和参数等信息通过回调的方式传递到 <code>Android</code> 层。</p>
<p>上述代码中，我们通过 <code>call.method</code> 和方法名称的一一对应关系来最终完成 <code>Android</code> 层代码的调用。以其中一个 <code>if</code> 语句为例，我们可以看到，在 <code>Android</code> 层的方法调用成功之后，会通过调用 <code>result.success</code> 将结果回写到 <code>Flutter</code> 层。如果调用不成功，则需要调用 <code>result.error</code> 将错误信息回写到 <code>Flutter</code> 层。</p>
<p><code>Flutter</code> 层通过捕获 <code>PlatformException</code> 的方式读取到回写的错误信息。也就是说，<code>Android</code> 层的 <code>result.error</code> 调用最终体现在 <code>Flutter</code> 层是一个 <code>PlatformException</code> 异常。</p>
<p>事实上，<code>result</code> 还有一个 <code>notImplemented</code> 方法用于表示找不到对应的方法。在上述示例中我们是以 <code>result.error</code> 调用的方法替代了 <code>notImplemented</code> 方法。</p>
<p>静态方法 <code>registerWith</code> 最终在 <code>ManiActivity</code> 中得到调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FlutterFilePathProvidePlugin.registerWith(registry.registrarFor(<span class="string">&quot;tech.fiissh.flutter.plugin.path.FlutterFilePathProvidePlugin&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>上述方法中，<code>registrarFor</code> 方法最终返回一个 <code>PluginRegistry.Registrar</code> 对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Registrar</span> </span>&#123;</span><br><span class="line">    <span class="function">Activity <span class="title">activity</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Context <span class="title">context</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Context <span class="title">activeContext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">BinaryMessenger <span class="title">messenger</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">TextureRegistry <span class="title">textures</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">PlatformViewRegistry <span class="title">platformViewRegistry</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">FlutterView <span class="title">view</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">lookupKeyForAsset</span><span class="params">(String var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">lookupKeyForAsset</span><span class="params">(String var1, String var2)</span></span>;</span><br><span class="line"></span><br><span class="line">    PluginRegistry.<span class="function">Registrar <span class="title">publish</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    PluginRegistry.<span class="function">Registrar <span class="title">addRequestPermissionsResultListener</span><span class="params">(PluginRegistry.RequestPermissionsResultListener var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    PluginRegistry.<span class="function">Registrar <span class="title">addActivityResultListener</span><span class="params">(PluginRegistry.ActivityResultListener var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    PluginRegistry.<span class="function">Registrar <span class="title">addNewIntentListener</span><span class="params">(PluginRegistry.NewIntentListener var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    PluginRegistry.<span class="function">Registrar <span class="title">addUserLeaveHintListener</span><span class="params">(PluginRegistry.UserLeaveHintListener var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    PluginRegistry.<span class="function">Registrar <span class="title">addViewDestroyListener</span><span class="params">(PluginRegistry.ViewDestroyListener var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Registrar</code> 中持有当前 <code>Activity</code> 的 <code>Activity</code> 和 <code>Context</code> 实例，并定义了一些动态权限申请、打开其他 <code>Activity</code> 等相关的方法。</p>
<h2 id="发布插件"><a href="#发布插件" class="headerlink" title="发布插件"></a>发布插件</h2><p>在插件开发完成之后（当然，<code>flutter_file_path_provide</code> 插件还没有开发完成），可以将插件发布到 <a href="https://pub.dartlang.org/">Pub</a> 上。</p>
<p>插件发布之前我们需要做如下准备工作：</p>
<ul>
<li>修改 <code>README.md</code>，撰写插件的使用说明</li>
<li>修改 <code>CHANGELOG.md</code>，记录插件的版本变更</li>
<li>修改 <code>LICENSE</code> 条款的文件</li>
<li>撰写所有公共 <code>API</code> 说明</li>
</ul>
<p>上述准备工作完成之后，使用如下命令进行检查：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flutter packages pub publish --dry-run</span><br></pre></td></tr></table></figure>

<p>最后，通过如下命令进行发布：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flutter packages pub publish</span><br></pre></td></tr></table></figure>

<p>关于发布插件的详细信息，请参考 <a href="https://www.dartlang.org/tools/pub/publishing">Publishing a Package</a>。</p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter 开发</tag>
        <tag>Flutter 插件开发</tag>
        <tag>flutter_file_path_provide</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter 开发（09）：Flutter 异步编程</title>
    <url>/index.html//2019/flutter-async-program.html</url>
    <content><![CDATA[<p>本文主要介绍 <code>Flutter</code> 异步编程相关的内容。关键字 <code>async</code>、<code>async</code><sup><em></em></sup>、<code>sync</code>、<code>sync</code><sup></sup>、<code>await</code>、<code>yield</code> 以及 <code>Future</code>、<code>Stream</code> 和 <code>Timer</code> 对象构成了 <code>Flutter</code> 异步编程的全部内容。</p>
<p><code>Future</code> 是一个泛型对象，表示程序在将来的某个时刻能够获取到一个值，泛型类型表示了该返回值的类型。当返回值是 <code>Future</code> 的方法被调用之后，<code>Flutter</code>（<code>Dart</code>）将会做两件事情：</p>
<ul>
<li>将需要执行的的任务添加到异步队列中，并返回一个未完成的 <code>Future</code> 对象</li>
<li>如果任务的运行结果有效（包括异常信息），<code>Future</code> 以该值完成任务的执行。如果需要使用 <code>Future</code> 中的值，可以使用如下两种方式：<ul>
<li>使用 <code>async</code> 和 <code>await</code> 关键字</li>
<li>使用 <code>Future API</code></li>
</ul>
</li>
</ul>
<p><code>Stream</code> 也是一个泛型对象，表示异步数据的流通管道。它只允许从一端插入数据并通过管道从另外一端流出数据。为了控制 <code>Stream</code>，我们通常使用 <code>StreamController</code> 对 <code>Stream</code> 进行管理：</p>
<ul>
<li><code>StreamController</code> 提供了类型为 <code>StreamSink</code> 的 <code>sink</code> 属性作为数据的入口</li>
<li><code>StreamController</code> 提供了 <code>stream</code> 属性作为数据的出口</li>
</ul>
<p>在<code>Dart 1.9</code> 中引入了函数生成器的概念，利用惰性方法计算结果序列，以提升性能。生成器有两种类型：</p>
<ul>
<li>同步生成器：在需要的时候才生成值，然后使用者从生成器中拉取。使用 <code>sync</code><sup>*</sup> 表示</li>
<li>异步生成器：会以它自身的速度生成值，然后推送到使用者可以使用的地方。使用 <code>async</code><sup>*</sup> 表示</li>
</ul>
<p><code>Timer</code> 提供了一种使用计时器的异步任务的执行方式，</p>
<span id="more"></span>
<h2 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h2><p>从 <code>Dart 1.9</code> 开始，<code>Dart</code> 添加了 <code>async</code> 和 <code>await</code> 关键字用来实现异步的功能。它们允许我们编写看起来像是同步代码而且不需要使用 <code>Future</code> 的异步代码。在方法体前面使用 <code>async</code> 关键字修饰即表示这是一个异步方法。对调用者来说，调用 <code>async</code> 方法和其他方法没有什么区别，而且对于 <code>return</code> 返回值来说也没有什么影响。</p>
<p>非异步调用的方法定义如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> getVersionName() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;1.0.0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方式：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> versionName = getVersionName();</span><br></pre></td></tr></table></figure>

<p><code>async</code> 修饰的异步方法最终将返回值封装为 <code>Future</code> 对象。即：使用 <code>async</code> 修饰的异步方法，其返回值类型需要封装为 <code>Future</code> 对象。<code>getVersionName()</code> 方法修改为异步方法之后定义如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;<span class="built_in">String</span>&gt; getVersionName() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;1.0.0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方式：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> versionName = <span class="keyword">await</span> getVersionName();</span><br></pre></td></tr></table></figure>

<p>如果同步方法的返回值类型为 <code>T</code>，那么该方法异步方式的返回值类型应该是 <code>Future&lt;T&gt;</code>。如果同步方法中返回值类型为 <code>Future&lt;T&gt;</code>，那么对应的异步方法的返回值类型同样是 <code>Future&lt;T&gt;</code> 而不是 <code>Future&lt;Future&lt;T&gt;&gt;</code>。</p>
<p>如果异步方法没有显式的使用 <code>return</code> 返回一个值，那么在 <code>Flutter</code> 中将自动封装一个 <code>Future&lt;Null&gt;</code> 作为返回值。</p>
<p>需要注意的是，<code>await</code> 只能在 <code>async</code> 修饰的方法中使用，而且可以使用多次。使用 <code>await</code> 修饰的方法会自动进入阻塞状态，一直到任务执行完成并返回对应的值。</p>
<h2 id="函数生成器"><a href="#函数生成器" class="headerlink" title="函数生成器"></a>函数生成器</h2><p>在 <code>Dart 1.9</code> 中引入了函数生成器的概念，利用惰性函数计算结果序列，以提升性能。</p>
<p>函数生成器有两种类型：同步生成器和异步生成器。同步生成器在需要的时候才生成值，然后使用者从生成器中拉取。异步生成器会以它自身的速度生成值，然后推送到使用者可以使用的地方。</p>
<h3 id="同步生成器：sync"><a href="#同步生成器：sync" class="headerlink" title="同步生成器：sync*"></a>同步生成器：sync<sup>*</sup></h3><p>通过在方法主体前添加 <code>sync</code><sup>*</sup> 可以标记该方法为同步生成器。同步生成器返回一个 <code>Iterable&lt;T&gt;</code> 泛型对象，并使用 <code>yield</code> 语句来传递值。以获取第一个自然数 <code>n</code> 为例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Iterable</span>&lt;<span class="built_in">int</span>&gt; naturalsTo(<span class="built_in">int</span> n) <span class="keyword">sync</span>* &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Begin&quot;</span>);</span><br><span class="line">  <span class="built_in">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (k &lt; n) <span class="keyword">yield</span> k++;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;End&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用方法 <code>naturalsTo</code> 的时候，会立刻返回 <code>Iterable&lt;int&gt;</code> 对象。在我们调用 <code>iterator.moveNext()</code> 之前，函数的主体并不会执行。当运行该方法时，代码会执行到 <code>yield</code> 关键字修饰的位置，并暂停运行，此时 <code>moveNext()</code> 方法会返回 <code>true</code>。方法会在下一次调用 <code>moveNext()</code> 的时候恢复执行。当循环结束的时候，上述方法会隐式的执行 <code>return</code> 并终止迭代，此时 <code>moveNext()</code> 方法会返回 <code>false</code>。</p>
<p>我们通过如下代码晚上上述方法的调用：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iterator = naturalsTo(<span class="number">3</span>).iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (iterator.moveNext()) &#123;</span><br><span class="line">  <span class="built_in">print</span>(iterator.current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Begin</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">End</span><br></pre></td></tr></table></figure>

<h3 id="异步生成器：async"><a href="#异步生成器：async" class="headerlink" title="异步生成器：async*"></a>异步生成器：async<sup>*</sup></h3><p>通过在方法主体前添加 <code>async</code><sup>*</sup> 可以标记该方法为异步生成器。异步生成器返回一个 <code>Stream</code> 对象，并使用 <code>yield</code> 语句来传递值。以自然数生成器为例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Stream&lt;<span class="built_in">int</span>&gt; asynchronousNaturalsTo(<span class="built_in">int</span> n) <span class="keyword">async</span>* &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Begin&quot;</span>);</span><br><span class="line">  <span class="built_in">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (k &lt; n) <span class="keyword">yield</span> k++;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;End&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过如下代码完成调用：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">asynchronousNaturalsTo(<span class="number">3</span>).listen((v) &#123;</span><br><span class="line">  <span class="built_in">print</span>(v);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/// <span class="markdown">outputs</span></span></span><br><span class="line"><span class="comment">/// <span class="markdown">I/flutter (19802): Begin</span></span></span><br><span class="line"><span class="comment">/// <span class="markdown">I/flutter (19802): 0</span></span></span><br><span class="line"><span class="comment">/// <span class="markdown">I/flutter (19802): 1</span></span></span><br><span class="line"><span class="comment">/// <span class="markdown">I/flutter (19802): 2</span></span></span><br><span class="line"><span class="comment">/// <span class="markdown">I/flutter (19802): End</span></span></span><br></pre></td></tr></table></figure>

<p>当调用 <code>asynchronousNaturalsTo</code> 方法的时候，程序会立刻返回 <code>Stream&lt;int&gt;</code> 对象，但是函数体并没有执行。一旦开始 <code>listen</code> 监听数据流，方法体就开始执行。当执行到 <code>yield</code> 修饰的位置的时候，会将 <code>yield</code> 修饰的表达式的运算结果添加到 <code>Stream</code> 数据流中。异步生成器没有必要暂停，因为数据流可以通过 <code>StreamSubscription</code> 进行控制：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StreamSubscription&lt;int&gt; subscription = asynchronousNaturalsTo(3).listen(null);</span><br><span class="line">subscription.onData((value) &#123;</span><br><span class="line">  print(value);</span><br><span class="line">  if (value == 1) &#123;</span><br><span class="line">    subscription.pause();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过 <code>StreamSubscription</code> 来控制 <code>Stream</code> 的暂停(<code>subscription.pause()</code>)和取消(<code>subscription.cancel()</code>)。如果被暂停，方法会执行到 <code>yield</code> 修饰的位置，然后暂停，直到我们通过 <code>subscription.resume()</code> 恢复 <code>Stream</code>。</p>
<h3 id="yield-和-yield"><a href="#yield-和-yield" class="headerlink" title="yield 和 yield*"></a>yield 和 yield<sup>*</sup></h3><p>在上述的示例中，可以使用 <code>yield</code> 方便的传递值。如果我们的生成器函数中使用到了递归调用，那么使用 <code>yield</code> 将会带来一些性能问题。以从大到小获取自然数的的代码为例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Iterable</span>&lt;<span class="built_in">int</span>&gt; naturalsDownFrom(<span class="built_in">int</span> n) <span class="keyword">sync</span>* &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i <span class="keyword">in</span> naturalsDownFrom(n - <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="keyword">yield</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码通过递归调用的方式获取自然数。需要注意的是，我们每次调用 <code>naturalsDownFrom</code> 方法都会构建一个新的序列，并通过遍历新的序列然后使用 <code>yield</code> 将元素插入到当前序列中。我们在代码的一些位置插入输出来进行分析：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> level = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">Iterable</span>&lt;<span class="built_in">int</span>&gt; naturalsDownFrom(<span class="built_in">int</span> n) <span class="keyword">sync</span>* &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Begin&quot;</span>);</span><br><span class="line">    level = level + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;当前 n 为：<span class="subst">$n</span>  level 执行次数：<span class="subst">$level</span>&#x27;</span>);</span><br><span class="line">    <span class="keyword">yield</span> n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i <span class="keyword">in</span> naturalsDownFrom(n - <span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;当前 i 为：<span class="subst">$i</span>  level 执行次数：<span class="subst">$level</span>&#x27;</span>);</span><br><span class="line">      <span class="keyword">yield</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;End&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">I/flutter (31880): Begin</span><br><span class="line">I/flutter (31880): 当前 n 为：3  level 执行次数：1</span><br><span class="line">I/flutter (31880): Begin</span><br><span class="line">I/flutter (31880): 当前 n 为：2  level 执行次数：2</span><br><span class="line">I/flutter (31880): 当前 i 为：2  level 执行次数：2</span><br><span class="line">I/flutter (31880): Begin</span><br><span class="line">I/flutter (31880): 当前 n 为：1  level 执行次数：3</span><br><span class="line">I/flutter (31880): 当前 i 为：1  level 执行次数：3</span><br><span class="line">I/flutter (31880): 当前 i 为：1  level 执行次数：3</span><br><span class="line">I/flutter (31880): End</span><br><span class="line">I/flutter (31880): End</span><br></pre></td></tr></table></figure>

<p>在上述代码中：</p>
<ul>
<li>当 <code>n</code> 为3时，只执行了一次 <code>yield n</code></li>
<li>当 <code>n</code> 为2时，先执行了一次 <code>yield n</code>，然后执行了一次 <code>yield i</code>(实际上是执行了一次 <code>n = 3</code> 时的逻辑)</li>
<li>当 <code>n</code> 为1时，先执行了一次 <code>yield n</code>，然后执行了两次 <code>yield i</code>（实际上是分别执行了 <code>n = 3</code> 和 <code>n = 2</code> 时的逻辑）</li>
</ul>
<p>也就是说，这种方式下，使用 <code>yield</code> 传递值的次数总共执行了 $x(x-1)/2$ 次，时间复杂度为 $O(n^2)$，存在明显的性能问题。</p>
<p>我们使用 <code>yield</code><sup>*</sup> 对原来的递归调用进行修改：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> level = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Iterable</span>&lt;<span class="built_in">int</span>&gt; naturalsDownFrom(<span class="built_in">int</span> n) <span class="keyword">sync</span>* &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Begin&quot;</span>);</span><br><span class="line">    level = level + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;当前 n 为：<span class="subst">$n</span>  level 执行次数：<span class="subst">$level</span>&#x27;</span>);</span><br><span class="line">    <span class="keyword">yield</span> n;</span><br><span class="line">    <span class="keyword">yield</span>* naturalsDownFrom(n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;End&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">I/flutter (32505): Begin</span><br><span class="line">I/flutter (32505): 当前 n 为：3  level 执行次数：1</span><br><span class="line">I/flutter (32505): Begin</span><br><span class="line">I/flutter (32505): 当前 n 为：2  level 执行次数：2</span><br><span class="line">I/flutter (32505): Begin</span><br><span class="line">I/flutter (32505): 当前 n 为：1  level 执行次数：3</span><br><span class="line">I/flutter (32505): End</span><br><span class="line">I/flutter (32505): End</span><br></pre></td></tr></table></figure>

<p>使用 <code>yield</code><sup><em></em></sup> 调整之后，通过 <code>yield</code> 传递值的过程只有三次。<code>yield</code><sup></sup> 的作用是：将 <code>yield</code><sup><em></em></sup> 后面的子序列（在 <code>sync</code><sup></sup> 方法中，子序列必须是一个 <code>Iterable</code> 可迭代对象；在 <code>async</code><sup>*</sup> 方法中，子序列必须是一个 <code>Stream</code> 数据流）的所有元素插入到当前创建的序列中，而不是创建新的序列。</p>
<p>综上，<code>yield</code> 在递归调用中造成性能开销过大的本质原因是，生成器函数在每次调用的时候都会生成一个新的序列。在递归调用中，需要额外的开销将子序列的元素插入到当前序列中。</p>
<h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>如果要使用 <code>Future</code>，需要在代码中导入相应的库：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:async&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><code>Future</code> 表示一个异步任务在将来执行时产生的结果。<code>Flutter</code> 使用的 <code>Dart</code> 语言是单线程模型的语言，在 <code>Flutter</code> 中使用 <code>isolate</code>（协程）来表示一个异步任务。在 <code>Flutter</code> 线程的消息机制中，有一个消息循环（<code>event loop</code>）和两个队列（<code>event queue</code> 和 <code>microtask queue</code>）：</p>
<ul>
<li><code>event queue</code> 中包含所有的的外来事件，包括 <code>I/O</code>、<code>mouse events</code>、<code>drawing events</code>、<code>timers</code> 以及 <code>isolate</code> 之间的消息等。在任意的 <code>isolate</code> 中新增的事件都会放入到 <code>even loop</code> 中等待执行</li>
<li><code>microtask queue</code> 只在当前 <code>isolate</code> 的任务队列中排队，优先级高于 <code>event queue</code>，主要是通过 <code>scheduleMicrotask</code> 来调度</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1975877-7f5e775270e16dad?imageMogr2/auto-orient/strip%7CimageView2/2/w/471"></p>
<p><code>Flutter</code> 中的事件处理遵循如下规则：</p>
<ul>
<li>首先处理 <code>microtask queue</code> 中的任务（事件）</li>
<li>处理完 <code>microtask queue</code> 中的所有任务之后，从 <code>event queue</code> 中取出一个任务进行处理</li>
<li>回到 <code>microtask queue</code>，处理其中的任务，然后重复上述过程</li>
</ul>
<p>那么 <code>Flutter</code> 中是如何实现异步任务的呢？我们只需要将任务放入到 <code>microtask queue</code> 或者 <code>event queue</code> 中即可。通过 <code>Future.microtask</code> 接口（实际上使用了 <code>scheduleMicrotask</code>）可以将任务放置在 <code>microtask queue</code>。而通过 <code>Future</code> 的构造方法 <code>Future(FutureOr&lt;T&gt; computation())</code> 创建的任务则放置到了 <code>event queue</code> 中（实际上是通过 <code>Timer.run</code> 实现的）。</p>
<h3 id="创建异步（同步）任务"><a href="#创建异步（同步）任务" class="headerlink" title="创建异步（同步）任务"></a>创建异步（同步）任务</h3><p><code>Future</code> 中提供了多个接口用于创建异步或同步任务：</p>
<ul>
<li>使用 <code>factory Future(FutureOr&lt;T&gt; computation())</code>：该方法可以在 <code>event loop</code> 中创建一个异步任务</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future(() =&gt; <span class="built_in">print</span>(<span class="string">&#x27;在 event queue 中运行的 Future&#x27;</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>factory Future.delayed(Duration duration, [FutureOr&lt;T&gt; computation()])</code>：该方法可以在 <code>event loop</code> 中创建一个延时执行的异步任务</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future.delayed(<span class="keyword">const</span> <span class="built_in">Duration</span>(seconds:<span class="number">1</span>), () =&gt; <span class="built_in">print</span>(<span class="string">&#x27;1秒后在 event queue 中运行的 Future&#x27;</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>factory Future.microtask(FutureOr&lt;T&gt; computation())</code>：该方法可以在 <code>microtask queue</code> 中创建一个异步任务</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future.microtask(() =&gt; <span class="built_in">print</span>(<span class="string">&#x27;在 microtask queue 里运行的 Future&#x27;</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>factory Future.sync(FutureOr&lt;T&gt; computation())</code>：该方法可以创建一个同步任务</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future.<span class="keyword">sync</span>(() =&gt; <span class="built_in">print</span>(<span class="string">&#x27;同步运行的Future&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>Future.sync</code> 创建的同步任务指的是构造 <code>Future</code> 是传入的 <code>computation()</code> 对象是同步执行的。但是通过 <code>then</code> 注册的回调方法是在 <code>microtask queue</code> 中执行的。</p>
<h4 id="Completer"><a href="#Completer" class="headerlink" title="Completer"></a>Completer</h4><p><code>future.dart</code> 中有一个很特殊的类：<code>Completer</code>。我们通过 <code>Future</code> 的接口向队列添加任务之后，我们只能被动的通过注册的回调方法接收结果或者处理错误。而 <code>Completer</code> 提供了一系列接口允许我们对 <code>Future</code> 的执行过程进行控制。一个比较好的示例是 <a href="https://github.com/dart-lang/http/blob/21e02c10c042cbd396d39b825dc7538ea6cccab8/lib/src/utils.dart">http/http.dart 库</a> 中的 <code>store</code> 方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future store(Stream stream, EventSink sink) &#123;</span><br><span class="line">  <span class="keyword">var</span> completer = <span class="keyword">new</span> Completer();</span><br><span class="line">  stream.listen(sink.add, onError: sink.addError, onDone: () &#123;</span><br><span class="line">    sink.close();</span><br><span class="line">    completer.complete();</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> completer.future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="then"><a href="#then" class="headerlink" title="then"></a>then</h3><p><code>Future</code>通过向 <code>then()</code> 方法注册回调方法来接收返回的结果：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;R&gt; then&lt;R&gt;(FutureOr&lt;R&gt; onValue(T value), &#123;<span class="built_in">Function</span> onError&#125;);</span><br></pre></td></tr></table></figure>

<p>如果任务正确执行并返回了正确的值（非异常值），<code>onValue</code> 回调方法会被调用。此时通过 <code>value</code> 获取对应的返回值。另外，<code>then</code> 方法中还有一个可选的 <code>onError</code> 回调方法用于处理 <code>onValue</code> 回调方法执行过程中出现的异常信息。如果不注册该回调方法，那么将默认通过 <code>catchError</code> 返回异常信息。</p>
<p>需要注意的是，<code>onError</code> 的回调方法需要提供一个或两个参数，其中第二个参数为 可选的 <code>StackTrace</code> 对象。</p>
<p>需要注意的是，在肥肥测试的过程中 <code>onError</code> 并没有被执行，而是将异常信息交给了 <code>catchError</code> 进行处理。目前不确定是何种原因造成的问题。测试使用的代码如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">getVersionName().then((value) &#123;</span><br><span class="line">  <span class="built_in">print</span>(value);</span><br><span class="line">  <span class="built_in">String</span> result = <span class="keyword">null</span>;</span><br><span class="line">  result.substring(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">&#125;, onError: (<span class="built_in">Object</span> e, StackTrace st) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;出现异常 onError： &#123;e.toString()&#125;&#x27;</span>);</span><br><span class="line">&#125;).catchError((<span class="built_in">Object</span> e) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;出现异常 catchError：&#123;e.toString()&#125;&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="catchError"><a href="#catchError" class="headerlink" title="catchError"></a>catchError</h3><p><code>Future</code> 通过向 <code>catchError</code> 接口注册回调方法的方式来处理异常：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;T&gt; catchError(<span class="built_in">Function</span> onError, &#123;<span class="built_in">bool</span> test(<span class="built_in">Object</span> error)&#125;);</span><br></pre></td></tr></table></figure>

<p>异步任务执行的过程中出现的异常信息将会由 <code>catchError</code> 进行处理。</p>
<p>我们也可以通过 <code>Future.error</code> 返回错误信息，该错误信息也会由 <code>catchError</code> 进行处理。</p>
<p>另外，<code>catchError</code> 方法还有一个可选的 <code>test</code> 参数用于接收一个回调。如果该方法返回 <code>true</code>，那么 <code>catchError</code> 捕获的异常信息将会先由 <code>test</code> 参数对应的回调方法进行响应，然后再由 <code>onError</code> 参数对应的回调方法进行响应。如果返回 <code>false</code>，那么 <code>test</code> 参数对应的回调执行之后，<code>onError</code> 参数对应的回调则不再执行，应用程序将会抛出 <code>Unhandled Exception</code>。</p>
<h3 id="whenComplete"><a href="#whenComplete" class="headerlink" title="whenComplete"></a>whenComplete</h3><p><code>Future</code> 通过向 <code>whenComplete</code> 接口注册回调方法的方式来保证特定的代码逻辑一定能够得到执行。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;T&gt; whenComplete(FutureOr action());</span><br></pre></td></tr></table></figure>

<p>与使用 <code>try-catch-finally</code> 捕获异常信息类似的，<code>Future</code> 可以通过 <code>whenComplete</code> 的回调方法保证无论何种情况都会保证代码的执行。</p>
<h3 id="Future-wait"><a href="#Future-wait" class="headerlink" title="Future.wait"></a>Future.wait</h3><p>如果需要调用多个异步方法并且一并将返回值返回，可以使用 <code>Future.wait</code> 接口。当所有 <code>Future</code> 完成后，返回 <code>List</code> 类型的值列表：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Future&lt;<span class="built_in">List</span>&lt;T&gt;&gt; wait&lt;T&gt;(<span class="built_in">Iterable</span>&lt;Future&lt;T&gt;&gt; futures, &#123;<span class="built_in">bool</span> eagerError: <span class="keyword">false</span>, <span class="keyword">void</span> cleanUp(T successValue)&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Future-doWhile"><a href="#Future-doWhile" class="headerlink" title="Future.doWhile"></a>Future.doWhile</h3><p>如果需要执行循环的任务，可以使用 <code>Future.doWhile</code>。只有当执行结果返回 <code>false</code> 的时候才会停止：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Future doWhile(FutureOr&lt;<span class="built_in">bool</span>&gt; action())</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter 异步编程</tag>
        <tag>await</tag>
        <tag>sync</tag>
        <tag>Future</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter 开发（00）：Dart 语言语法预览</title>
    <url>/index.html//2019/dart-language-language-tour.html</url>
    <content><![CDATA[<p>本文主要针对 <code>Dart</code> 语言的语法规则以及常用概念进行介绍，主要目标是快速了解 <code>Dart</code> 的主要特性。</p>
<p>本文中介绍的 <code>Dart</code> 语言特性是基于 <code>Dart 2.1.0</code>。由于肥肥本身从事于 <code>Android</code> 开发多年，使用 <code>Java</code> 作为主要开发语言，所以在整理、撰写本文时会选择性的忽略一些语言特性的介绍。</p>
<p>本文是基于官网文档 <a href="https://www.dartlang.org/guides/language/language-tour">A Tour of the Dart Language</a>以及 <a href="http://dart.goodev.org/">Dart 翻译小组</a>翻译的 <a href="http://dart.goodev.org/guides/language/language-tour">Dart 语法概览</a> 文档。</p>
<p>感谢先驱们对 <code>Dart</code> 社区做出的贡献，更感谢 <a href="http://dart.goodev.org/">Dart 翻译小组</a>所付出的辛苦和贡献。</p>
<p>在 <code>Dart</code> 中一些重要的概念如下：</p>
<ul>
<li>所有的东西都是对象，所有的对象都是类的实例。即使数字、方法、<code>null</code> 也都是对象。所有的对象都继承自 <code>Object</code> 类</li>
<li>指定静态类型表明你的意图，并使检查类型检查成为可能</li>
<li><code>Dart</code> 在运行前解析所有的代码，可以使用些小技巧，例如：通过使用类型或编译时常量，来捕捉错误或使代码运行的更快</li>
<li><code>Dart</code> 支持顶级的函数，也支持类或对象的静态和实例方法。也可以在函数内部嵌套函数或本地函数</li>
<li><code>Dart</code> 支持顶级的变量，也支持类或对象的静态变量和实例变量(也被称作字段或属性)</li>
<li><code>Dart</code> 没有 <code>public</code>、<code>protected</code>、<code>private</code> 等关键字，如果一个标识符以 <code>_</code> 开头则表示私有</li>
<li>标识符以小写字母或下划线 <code>_</code> 开头，后面跟着字符和数字的任意组合</li>
<li><code>Dart</code> 中，明确区分表达式和语句</li>
<li><code>Dart tools</code> 会报告两种类型的问题：警告(<code>warnings</code>)和错误(<code>errors</code>)。警告仅标志着你的代码可能不会工作，但并不会阻止程序执行；错误可能是编译时错误，也可能是运行时错误。编译时错误会阻止程序执行；运行时错误会在程序执行时抛出异常</li>
<li><code>Dart</code> 有两种运行时模式：生产模式和检查模式。推荐在开发和 <code>debug</code> 时使用检查模式，生产环境中生产模式。生产模式是 <code>Dart</code> 程序默认的运行时模式</li>
</ul>
<span id="more"></span>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p><code>Dart</code> 语言中有三种类型的关键字：</p>
<ul>
<li>内置关键字：内置关键字的主要用作是方便 <code>JavaScript</code> 的代码向 <code>Dart</code> 移植，见下表<font color="red">红色字体</font>所示关键字</li>
<li>异步相关的关键字：<code>Dart 1.0</code> 之后为了支持异步特性而增加的关键字，见下表<font color="green">绿色字体</font>所示关键字</li>
<li>保留关键字：上述两种关键字之外的其他关键字为保留关键字，见下表<font color="blue">蓝色色字体</font>所示关键字</li>
</ul>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">关键字</th>
<th align="center">关键字</th>
<th align="center">关键字</th>
<th align="center">关键字</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><font color="red">abstract</font></td>
<td align="center"><font color="blue">continue</font></td>
<td align="center"><font color="blue">false</font></td>
<td align="center"><font color="blue">new</font></td>
<td align="center"><font color="blue">this</font></td>
</tr>
<tr>
<td align="center"><font color="red">as</font></td>
<td align="center"><font color="blue">default</font></td>
<td align="center"><font color="blue">final</font></td>
<td align="center"><font color="blue">null</font></td>
<td align="center"><font color="blue">throw</font></td>
</tr>
<tr>
<td align="center"><font color="blue">assert</font></td>
<td align="center"><font color="red">deferred</font></td>
<td align="center"><font color="blue">finally</font></td>
<td align="center"><font color="red">operator</font></td>
<td align="center"><font color="blue">true</font></td>
</tr>
<tr>
<td align="center"><font color="green">async</font></td>
<td align="center"><font color="blue">do</font></td>
<td align="center"><font color="blue">for</font></td>
<td align="center"><font color="red">part</font></td>
<td align="center"><font color="blue">try</font></td>
</tr>
<tr>
<td align="center"><font color="green">async*</font></td>
<td align="center"><font color="red">dynamic</font></td>
<td align="center"><font color="red">get</font></td>
<td align="center"><font color="blue">rethrow</font></td>
<td align="center"><font color="red">typedef</font></td>
</tr>
<tr>
<td align="center"><font color="green">await</font></td>
<td align="center"><font color="blue">else</font></td>
<td align="center"><font color="blue">if</font></td>
<td align="center"><font color="blue">return</font></td>
<td align="center"><font color="blue">var</font></td>
</tr>
<tr>
<td align="center"><font color="blue">break</font></td>
<td align="center"><font color="blue">enum</font></td>
<td align="center"><font color="red">implements</font></td>
<td align="center"><font color="red">set</font></td>
<td align="center"><font color="blue">void</font></td>
</tr>
<tr>
<td align="center"><font color="blue">case</font></td>
<td align="center"><font color="red">export</font></td>
<td align="center"><font color="red">import</font></td>
<td align="center"><font color="red">static</font></td>
<td align="center"><font color="blue">while</font></td>
</tr>
<tr>
<td align="center"><font color="blue">catch</font></td>
<td align="center"><font color="red">external</font></td>
<td align="center"><font color="blue">in</font></td>
<td align="center"><font color="blue">super</font></td>
<td align="center"><font color="blue">with</font></td>
</tr>
<tr>
<td align="center"><font color="blue">class</font></td>
<td align="center"><font color="blue">extends</font></td>
<td align="center"><font color="blue">is</font></td>
<td align="center"><font color="blue">switch</font></td>
<td align="center"><font color="green">yield</font></td>
</tr>
<tr>
<td align="center"><font color="blue">const</font></td>
<td align="center"><font color="red">factory1</font></td>
<td align="center"><font color="red">library</font></td>
<td align="center"><font color="green">sync*</font></td>
<td align="center"><font color="green">yield*</font></td>
</tr>
</tbody></table>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>可以使用 <code>var</code> 声明一个变量，编译器会自动推导其变量类型：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;fiissh.zhao&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上述代码表示，一个名字为 <code>name</code> 的变量引用了一个内容为 <code>fiissh.zhao</code> 的 <code>String</code> 对象。</p>
<p>相应的，我们可以使用具体的类型来声明一个变量：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> name = <span class="string">&#x27;fiissh.zhao&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果一个变量声明之后，我们将不会对变量产生修改，那么可以使用 <code>final</code> 或 <code>const</code> 关键字修饰变量：</p>
<ul>
<li>一个使用 <code>final</code> 修饰的变量只能被赋值一次</li>
<li>一个使用 <code>const</code> 修饰的变量指的是编译时常量</li>
</ul>
<blockquote>
<p>默认的，<code>Dart</code> 中没有初始化的变量将获得默认值 <code>null</code>。这与 <code>Java</code> 中的 <code>Object</code> 类型的对象的默认值是一样的。需要注意的是，与 <code>Java</code> 相比，<code>Dart</code> 中所有的对象（包括数字、方法以及 <code>null</code>）都继承自 <code>Object</code> 类。<br><code>Dart</code> 中 <code>final</code> 的用法与 <code>Java</code> 中的 <code>final</code> 的用法相似，都是表示一个不可变的变量。<code>Dart</code> 中 <code>const</code> 的用法则与 <code>Java</code> 中的 <code>static final</code> 的用法相似，用于表示一个常量。关于 <code>final</code> 和 <code>const</code> 的使用此处不做过多介绍。</p>
</blockquote>
<h2 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h2><p><code>Dart</code> 支持如下内置类型：</p>
<ul>
<li>数字类型</li>
<li>字符串类型</li>
<li>布尔类型</li>
<li>数组类型</li>
<li>哈希类型</li>
<li><code>runes</code></li>
<li><code>symbols</code></li>
</ul>
<h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><p><code>Dart</code> 支持如下两种类型的数字：</p>
<ul>
<li><code>int</code>：整型数值，其取值范围为 $ -2^{53} $ 到 $ 2^{53} $ 之间</li>
<li><code>double</code>：64位双精度浮点数，符合 <code>IEEE 754</code> 标准</li>
</ul>
<blockquote>
<p><code>int</code> 和 <code>double</code> 都是 <code>num</code> 的子类。<code>num</code> 类定义了基本的操作。如果 <code>num</code> 中定义的操作不能满足需求，则可以考虑使用 <code>dart:math</code> 库。<br><code>String</code> 类型的数据与 <code>num</code> 类型的相互转换可以通过 <code>num</code> 的 <code>parse</code> 方法和 <code>toString</code> 方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String -&gt; int</span></span><br><span class="line"><span class="keyword">var</span> one = <span class="built_in">int</span>.parse(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// String -&gt; double</span></span><br><span class="line"><span class="keyword">var</span> onePointOne = <span class="built_in">double</span>.parse(<span class="string">&#x27;1.1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// int -&gt; String</span></span><br><span class="line"><span class="built_in">String</span> oneAsString = <span class="number">1.</span>toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// double -&gt; String</span></span><br><span class="line"><span class="built_in">String</span> piAsString = <span class="number">3.14159</span>.toStringAsFixed(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>与 <code>Java</code> 一样，<code>int</code> 类型的数据的可以支持位移操作：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span>((<span class="number">3</span> &lt;&lt; <span class="number">1</span>) == <span class="number">6</span>);  <span class="comment">// 0011 &lt;&lt; 1 == 0110</span></span><br><span class="line"><span class="keyword">assert</span>((<span class="number">3</span> &gt;&gt; <span class="number">1</span>) == <span class="number">1</span>);  <span class="comment">// 0011 &gt;&gt; 1 == 0001</span></span><br><span class="line"><span class="keyword">assert</span>((<span class="number">3</span> | <span class="number">4</span>)  == <span class="number">7</span>);  <span class="comment">// 0011 | 0100 == 0111</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>assert</code> 表示断言。断言只在检查模式下有效，而在生产模式则无效。</p>
</blockquote>
<p>使用 <code>const</code> 修饰的数值类型，其数学运算的结果也是 <code>const</code> 类型的：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> msPerSecond = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> secondsUntilRetry = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> msUntilRetry = secondsUntilRetry * msPerSecond;</span><br></pre></td></tr></table></figure>

<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p><code>Dart</code> 中字符串使用 <code>UTF-16</code> 编码，可以使用单引号（<code>&#39;&#39;</code>）或者双引号（<code>&quot;&quot;</code>）来初始化：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&#x27;Single quotes work well for string literals.&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">&quot;Double quotes work just as well.&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> s3 = <span class="string">&#x27;It\&#x27;s easy to escape the string delimiter.&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> s4 = <span class="string">&quot;It&#x27;s even easier to use the other delimiter.&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>如果需要在字符串中使用表达式，可以使用 <code>$&#123;expression&#125;</code>。如果表达式的结果是一个非字符串对象，那么可以使用 <code>toString</code> 来获取字符串：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;string interpolation&#x27;</span>;</span><br><span class="line"><span class="keyword">assert</span>(<span class="string">&#x27;Dart has <span class="subst">$s</span>, which is very handy.&#x27;</span> ==</span><br><span class="line">       <span class="string">&#x27;Dart has string interpolation, &#x27;</span> +</span><br><span class="line">       <span class="string">&#x27;which is very handy.&#x27;</span>);</span><br><span class="line"><span class="keyword">assert</span>(<span class="string">&#x27;That deserves all caps. &#x27;</span> +</span><br><span class="line">       <span class="string">&#x27;<span class="subst">$&#123;s.toUpperCase()&#125;</span> is very handy!&#x27;</span> ==</span><br><span class="line">       <span class="string">&#x27;That deserves all caps. &#x27;</span> +</span><br><span class="line">       <span class="string">&#x27;STRING INTERPOLATION is very handy!&#x27;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，<code>==</code> 操作符判断两个对象的内容是否一样。如果两个字符串包含一样的字符编码序列， 则他们是相等的。使用 <code>+</code> 操作符可以把多个字符串拼接为一个字符串。而且，如果字符串中使用的表达式仅仅是一个标识符，那么可以省略 <code>&#123;&#125;</code></p>
</blockquote>
<p>使用三个单引号（<code>&#39;&#39;&#39;</code>）或者双引号（<code>&quot;&quot;&quot;</code>）可以创建一个多行的字符串对象：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">You can create</span></span><br><span class="line"><span class="string">multi-line strings like this one.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">&quot;&quot;&quot;This is also a</span></span><br><span class="line"><span class="string">multi-line string.&quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>通过提供一个 <code>r</code> 前缀可以创建一个<code>原始 raw</code> 字符串：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">r&quot;In a raw string, even \n isn&#x27;t special.&quot;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于<code>原始 raw</code> 字符串，将会在 <code>Runes</code> 相关的章节中介绍。</p>
</blockquote>
<p>与 <code>num</code> 类型相似的，如果使用 <code>const</code> 修饰 <code>Strings</code> 类型，其运算结果也是 <code>const</code> 类型：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> aConstNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> aConstBool = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">const</span> aConstString = <span class="string">&#x27;a constant string&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> validConstString = <span class="string">&#x27;<span class="subst">$aConstNum</span> <span class="subst">$aConstBool</span> <span class="subst">$aConstString</span>&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p><code>Dart</code> 使用 <code>bool</code> 类型的子类型 <code>true</code> 和 <code>false</code> 表示布尔类型的数据，而且他们都是 <code>const</code> 类型的。</p>
<p>在 <code>Dart</code> 中，只有 <code>true</code> 对象才被真正认定为 <code>true</code>，其他的所有的对象都是 <code>false</code>。</p>
<h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p><code>Dart</code> 中使用的数组对象是 <code>List</code>：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span> , <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>与 <code>Java</code> 中的数组一样，<code>Dart</code> 中的 <code>List</code> 下标索引也是从 0 开始的，而且索引数据的方式也与数组类似：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(i == <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>如果在 <code>List</code> 的初始化时使用 <code>const</code> 修饰，那么可以创建一个不变的 <code>List</code> 对象：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="keyword">const</span> [<span class="number">1</span> , <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<h3 id="哈希类型"><a href="#哈希类型" class="headerlink" title="哈希类型"></a>哈希类型</h3><p><code>Dart</code> 中使用的键值类型是 <code>Map</code>：</p>
<ul>
<li>键和值可以是任何类型的对象</li>
<li>每个键只能出现一次，而值则可以出现多次</li>
</ul>
<p>可以使用如下两种方式声明一个 <code>Map</code> 对象：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gifts = &#123;</span><br><span class="line"><span class="comment">// Keys      Values</span></span><br><span class="line">  <span class="string">&#x27;first&#x27;</span> : <span class="string">&#x27;partridge&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;second&#x27;</span>: <span class="string">&#x27;turtledoves&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;fifth&#x27;</span> : <span class="string">&#x27;golden rings&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gifts = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">gifts[<span class="string">&#x27;first&#x27;</span>] = <span class="string">&#x27;partridge&#x27;</span>;</span><br><span class="line">gifts[<span class="string">&#x27;second&#x27;</span>] = <span class="string">&#x27;turtledoves&#x27;</span>;</span><br><span class="line">gifts[<span class="string">&#x27;fifth&#x27;</span>] = <span class="string">&#x27;golden rings&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>相应的，可以通过如下方式读取 <code>Map</code> 中的对象：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> object = gifts[<span class="string">&#x27;first&#x27;</span>];</span><br></pre></td></tr></table></figure>

<p>如果在 <code>Map</code> 的初始化时使用 <code>const</code> 修饰，那么可以创建一个不变的 <code>Map</code> 对象：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> constantMap = <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="number">2</span>: <span class="string">&#x27;helium&#x27;</span>,</span><br><span class="line">  <span class="number">10</span>: <span class="string">&#x27;neon&#x27;</span>,</span><br><span class="line">  <span class="number">18</span>: <span class="string">&#x27;argon&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Runes"><a href="#Runes" class="headerlink" title="Runes"></a>Runes</h3><p>在 <code>Dart</code> 中，<code>runes</code> 代表字符串的 <code>UTF-32</code> 编码。</p>
<blockquote>
<p><code>Unicode</code> 为每一个字符、标点符号、表情符号等都定义了 一个唯一的数值。 由于 <code>Dart</code> 字符串是 <code>UTF-16</code> 字符编码，，所以如果在字符串中表达 <code>32-bit Unicode</code>（即 <code>UTF-32</code> 编码） 值就需要 新的语法了。</p>
</blockquote>
<p>通常使用 <code>\uXXXX</code> 的方式来表示 <code>Unicode</code> 编码（<code>XXXX</code> 表示4个16进制的数）。 例如，心形符号 (♥) 是 <code>\u2665</code>。对于那么不是4个数值的情况， 把编码值放到大括号中即可。 例如，笑脸 <code>emoji</code> (😆) 是 <code>\u&#123;1f600&#125;</code>。</p>
<p><code>String</code> 类有一些属性可以提取 <code>runes</code> 信息。 <code>codeUnitAt</code> 和 <code>codeUnit</code> 属性返回 <code>UTF-16</code> 编码。</p>
<p>下列实例演示了 <code>runes</code>、<code>UTF-16</code> 编码 和 <code>UTF-32</code> 编码之间的关系：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> clapping = <span class="string">&#x27;\u&#123;1f44f&#125;&#x27;</span>;</span><br><span class="line">  <span class="built_in">print</span>(clapping);</span><br><span class="line">  <span class="built_in">print</span>(clapping.codeUnits);</span><br><span class="line">  <span class="built_in">print</span>(clapping.runes.toList());</span><br><span class="line"></span><br><span class="line">  Runes input = <span class="keyword">new</span> Runes(</span><br><span class="line">      <span class="string">&#x27;\u2665  \u&#123;1f605&#125;  \u&#123;1f60e&#125;  \u&#123;1f47b&#125;  \u&#123;1f596&#125;  \u&#123;1f44d&#125;&#x27;</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="keyword">new</span> <span class="built_in">String</span>.fromCharCodes(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行之后输出：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">👏</span><br><span class="line">[55357, 56399]</span><br><span class="line">[128079]</span><br><span class="line">♥  😅  😎  👻  🖖  👍</span><br></pre></td></tr></table></figure>

<h3 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h3><p>在 <code>Dart</code> 中，一个 <code>Symbol</code> 对象表示程序中声明的操作符和标识符。在标识符前面增加一个 <code>#</code> 用于表示 <code>Symbol</code> 对象：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">#radix</span><br><span class="line">#bar</span><br></pre></td></tr></table></figure>

<p>在 <code>Dart</code>中，<code>Symbol</code> 是使用较少的特性。在混淆之后的代码中，由于使用 <code>Symbol</code> 的名字不会改变，这使得我们可以方便的使用名字来引用标识符。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>在 <code>Dart</code> 中，方法是 <code>Function</code> 对象，这也就意味着我们可以给方法赋值，甚至可以把方法作为参数进行传递。</p>
<p>方法的定义方式如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> isNoble(<span class="built_in">int</span> atomicNumber) &#123;</span><br><span class="line">  <span class="keyword">return</span> _nobleGases[atomicNumber] != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，我们也可以忽略方法返回值和参数列表的类型定义：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">isNoble(atomicNumber) &#123;</span><br><span class="line">  <span class="keyword">return</span> _nobleGases[atomicNumber] != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于只有一个表达式的方法，你可以选择 使用缩写语法来定义：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> isNoble(<span class="built_in">int</span> atomicNumber) =&gt; _nobleGases[atomicNumber] != <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>这个 <code>=&gt;</code> 语法是 <code>&#123; return expr; &#125;</code> 形式的缩写。</p>
<p>方法可以有两种类型的参数：必需的和可选的。 必需的参数在参数列表前面，后面是可选参数。</p>
<h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>可选参数可以是命名参数或者基于位置的参数，但是这两种参数不能同时当做可选参数。</p>
<h4 id="可选命名参数"><a href="#可选命名参数" class="headerlink" title="可选命名参数"></a>可选命名参数</h4><p>调用方法的时候，我们可以使用 <code>param_name:value</code> 的形式来指定命名参数：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">enableFlags(bold: <span class="keyword">true</span>, hidden: <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<p>在定义方法的时候，可以使用 <code>&#123;param_1,param_2,param_3,...&#125;</code> 的形式来指定命名参数：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">enableFlags(&#123;<span class="built_in">bool</span> bold, <span class="built_in">bool</span> hidden&#125;) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可选位置参数"><a href="#可选位置参数" class="headerlink" title="可选位置参数"></a>可选位置参数</h4><p>把一些方法的参数放到 <code>[]</code> 中就可以变成可选位置参数：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> say(<span class="built_in">String</span> from, <span class="built_in">String</span> msg, [<span class="built_in">String</span> device]) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">&#x27;<span class="subst">$from</span> says <span class="subst">$msg</span>&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (device != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">&#x27;<span class="subst">$result</span> with a <span class="subst">$device</span>&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是不使用可选位置参数调用上述方法的示例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span>(say(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Howdy&#x27;</span>) == <span class="string">&#x27;Bob says Howdy&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>下面是使用可选位置参数调用上述方法的示例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span>(say(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Howdy&#x27;</span>, <span class="string">&#x27;smoke signal&#x27;</span>) == <span class="string">&#x27;Bob says Howdy with a smoke signal&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h4><p>在定义方法的时候，可以使用 <code>=</code> 来定义可选参数的默认值。默认值只能是 <code>const</code> 类型（编译时常量）。如果没有提供默认值，那么参数默认为 <code>null</code>。</p>
<p>下面是为可选命名参数设置默认值的示例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> enableFlags(&#123;<span class="built_in">bool</span> bold = <span class="keyword">false</span>, <span class="built_in">bool</span> hidden = <span class="keyword">false</span>&#125;) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是为可选位置参数设置默认值的示例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> say(<span class="built_in">String</span> from, <span class="built_in">String</span> msg,</span><br><span class="line">    [<span class="built_in">String</span> device = <span class="string">&#x27;carrier pigeon&#x27;</span>, <span class="built_in">String</span> mood]) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">&#x27;<span class="subst">$from</span> says <span class="subst">$msg</span>&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (device != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">&#x27;<span class="subst">$result</span> with a <span class="subst">$device</span>&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (mood != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">&#x27;<span class="subst">$result</span> (in a <span class="subst">$mood</span> mood)&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面示例是当方法中使用了 <code>List</code> 或 <code>Map</code> 时设置默认值的方式：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> doStuff(</span><br><span class="line">    &#123;<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">const</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; gifts = <span class="keyword">const</span> &#123;</span><br><span class="line">      <span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;paper&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;second&#x27;</span>: <span class="string">&#x27;cotton&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;third&#x27;</span>: <span class="string">&#x27;leather&#x27;</span></span><br><span class="line">    &#125;&#125;) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;list:  <span class="subst">$list</span>&#x27;</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;gifts: <span class="subst">$gifts</span>&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h3><p>每一个 <code>Dart</code> 应用程序都有一个顶级的 <code>main()</code> 方法的入口才能运行。<code>main()</code> 方法的返回值为 <code>void</code> 并且有一个可选的 <code>List&lt;String&gt;</code> 参数：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello <span class="subst">$i</span>&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名方法"><a href="#匿名方法" class="headerlink" title="匿名方法"></a>匿名方法</h3><p>在 <code>Dart</code> 中。大部分方法是有名字的，例如 <code>main()</code> 方法。但是我们也可以创建一个匿名方法（也称为 <code>lambda</code> 或者 <code>closure</code> 闭包）：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">([[<span class="built_in">Type</span>] param1[, …]]) &#123;</span><br><span class="line">  codeBlock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>与非匿名方法类似的，我们可以在括号之间定义一些参数，参数之间使用逗号分隔，而大括号之间则是方法体。</p>
<p>下面的代码定义了一个参数为 <code>i</code>（该参数没有指定类型）的匿名方法。<code>list</code> 中的每个元素都会调用这个函数来 打印出来，同时来计算了每个元素在 <code>list</code> 中的索引位置：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="string">&#x27;apples&#x27;</span>, <span class="string">&#x27;oranges&#x27;</span>, <span class="string">&#x27;grapes&#x27;</span>, <span class="string">&#x27;bananas&#x27;</span>, <span class="string">&#x27;plums&#x27;</span>];</span><br><span class="line">list.forEach((i) &#123;</span><br><span class="line">  <span class="built_in">print</span>(list.indexOf(i).toString() + <span class="string">&#x27;: &#x27;</span> + i);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="静态作用域"><a href="#静态作用域" class="headerlink" title="静态作用域"></a>静态作用域</h3><p>由于 <code>Dart</code> 是静态语言，所以变量的作用域在写代码的时候就已经确定了。通常情况下，大括号中定义的变量只能在大括号中访问，其作用域与 <code>Java</code> 类似。</p>
<p>下面是作用域的一个示例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> topLevel = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> insideMain = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  myFunction() &#123;</span><br><span class="line">    <span class="keyword">var</span> insideFunction = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    nestedFunction() &#123;</span><br><span class="line">      <span class="keyword">var</span> insideNestedFunction = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">assert</span>(topLevel);</span><br><span class="line">      <span class="keyword">assert</span>(insideMain);</span><br><span class="line">      <span class="keyword">assert</span>(insideFunction);</span><br><span class="line">      <span class="keyword">assert</span>(insideNestedFunction);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，<code>nestedFunction()</code> 可以访问所有的变量，包含顶级变量。</p>
</blockquote>
<h3 id="闭包语法"><a href="#闭包语法" class="headerlink" title="闭包语法"></a>闭包语法</h3><p>一个闭包是一个方法对象，不管该对象在何处被调用，该对象都可以访问其作用域内的变量。方法可以封闭定义在其作用域内的变量：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span> makeAdder(<span class="built_in">num</span> addBy) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">num</span> i) =&gt; addBy + i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="comment">// Create a function that adds 2.</span></span><br><span class="line">  <span class="keyword">var</span> add2 = makeAdder(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a function that adds 4.</span></span><br><span class="line">  <span class="keyword">var</span> add4 = makeAdder(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">assert</span>(add2(<span class="number">3</span>) == <span class="number">5</span>);</span><br><span class="line">  <span class="keyword">assert</span>(add4(<span class="number">3</span>) == <span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>makeAdder()</code> 捕获到了变量 <code>addBy</code>，不管我们在何处执行 <code>makeAdder()</code> 方法所返回的方法（<code>(num i) =&gt; addBy + i</code>），都可以使用 <code>addBy</code> 参数。</p>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>在 <code>Dart</code> 中，所有的方法都有返回值。如果没有指定返回值，则默认把 <code>return null;</code> 作为方法最后一行的语句执行。</p>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>下表展示了 <code>Dart</code> 中定义的操作符：</p>
<table>
<thead>
<tr>
<th>描述</th>
<th>操作符</th>
</tr>
</thead>
<tbody><tr>
<td>unary postfix</td>
<td><code>expr++</code>、<code>expr--</code>，<code>()</code>、<code>[]</code>、<code>.</code>、<code>?.</code></td>
</tr>
<tr>
<td>unary prefix</td>
<td><code>-expr</code>、<code>!expr</code>、<code>~expr</code>、<code>++expr</code>、<code>--expr</code></td>
</tr>
<tr>
<td>multiplicative</td>
<td><code>*</code>、<code>/</code>、<code>%</code>、<code>~/</code></td>
</tr>
<tr>
<td>additive</td>
<td><code>+</code>、<code>-</code></td>
</tr>
<tr>
<td>shift</td>
<td><code>&lt;&lt;</code>、<code>&gt;&gt;</code></td>
</tr>
<tr>
<td>bitwise AND</td>
<td><code>&amp;</code></td>
</tr>
<tr>
<td>bitwise XOR</td>
<td><code>^</code></td>
</tr>
<tr>
<td>bitwise OR</td>
<td>`</td>
</tr>
<tr>
<td>relational and type test</td>
<td><code>&gt;=</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&lt;</code>、<code>as</code>、<code>is</code>、<code>is!</code></td>
</tr>
<tr>
<td>equality</td>
<td><code>==</code>、<code>!=</code></td>
</tr>
<tr>
<td>logical AND</td>
<td><code>&amp;&amp;</code></td>
</tr>
<tr>
<td>logical OR</td>
<td>`</td>
</tr>
<tr>
<td>if null</td>
<td><code>??</code></td>
</tr>
<tr>
<td>conditional</td>
<td><code>expr1 ? expr2 : expr3</code></td>
</tr>
<tr>
<td>cascade</td>
<td><code>..</code></td>
</tr>
<tr>
<td>assignment</td>
<td><code>=</code>、<code>*=</code>、<code>/=</code>、<code>~/=</code>、<code>%=</code>、<code>+=</code>、<code>-=</code>、<code>&lt;&lt;=</code>、<code>&gt;&gt;=</code>、<code>&amp;=</code>、<code>^=</code>、`</td>
</tr>
</tbody></table>
<p>上述表格所列的操作符都是按照优先级顺序从左到右，从上到下的方式来列出的，上面和左边的操作符优先级要高于下面和右边的。</p>
<p>例如 <code>%</code> 操作符优先级高于 <code>==</code>，而 <code>==</code> 高于 <code>&amp;&amp;</code>。所以下面的代码结果是一样的：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1: Parens improve readability.</span></span><br><span class="line"><span class="keyword">if</span> ((n % i == <span class="number">0</span>) &amp;&amp; (d % i == <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2: Harder to read, but equivalent.</span></span><br><span class="line"><span class="keyword">if</span> (n % i == <span class="number">0</span> &amp;&amp; d % i == <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="算术操作符"><a href="#算术操作符" class="headerlink" title="算术操作符"></a>算术操作符</h3><p><code>Dart</code> 支持常见的算术操作符：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td>加号</td>
</tr>
<tr>
<td><code>-</code></td>
<td>减号</td>
</tr>
<tr>
<td><code>-expr</code></td>
<td>负号</td>
</tr>
<tr>
<td><code>*</code></td>
<td>乘号</td>
</tr>
<tr>
<td><code>/</code></td>
<td>除号</td>
</tr>
<tr>
<td><code>~/</code></td>
<td>除号（返回值为0）</td>
</tr>
<tr>
<td><code>%</code></td>
<td>取模</td>
</tr>
<tr>
<td><code>++</code></td>
<td>自增操作</td>
</tr>
<tr>
<td><code>--</code></td>
<td>自减操作</td>
</tr>
</tbody></table>
<blockquote>
<p>需要注意的是，<code>++</code> 和 <code>--</code> 操作符在变量的前后位置不一样，其运算过程不一样。例如 <code>++var</code> 和 <code>var++</code> 运算，其表达式都等同于 <code>var = var +1</code>。但是 <code>++var</code> 运算时先执行 <code>var + 1</code> 然后再执行运算，而 <code>var++</code> 则正好相反，是先执行运算操作，然后再执行 <code>var + 1</code> 操作。这与 <code>Java</code> 中的自增自减运算是一致的。</p>
</blockquote>
<h3 id="等式与不等式操作符"><a href="#等式与不等式操作符" class="headerlink" title="等式与不等式操作符"></a>等式与不等式操作符</h3><p><code>Dart</code> 支持常见的等式与不等式操作符：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>==</code></td>
<td>相等</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>不相等</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于</td>
</tr>
</tbody></table>
<p>如果需要比较两个对象是否为同样的内容，使用 <code>==</code> 操作符。下面是 == 操作符工作原理解释：</p>
<ul>
<li>如果 <code>x</code> 或 <code>y</code> 是 <code>null</code>，如果两个都是 <code>null</code> 则返回 <code>true</code>，如果 只有一个是 <code>null</code> 返回 <code>false</code></li>
<li>返回如下函数的返回值 <code>x.==(y)</code></li>
</ul>
<blockquote>
<p>在某些情况下，如果我们需要判断两个对象是否是同一个对象，则使用 <code>identical()</code> 方法。</p>
</blockquote>
<h3 id="类型判断操作符"><a href="#类型判断操作符" class="headerlink" title="类型判断操作符"></a>类型判断操作符</h3><p><code>Dart</code> 支持如下类型判断操作符：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>as</code></td>
<td>类型转换</td>
</tr>
<tr>
<td><code>is</code></td>
<td>如果对象是指定的类型返回 <code>true</code></td>
</tr>
<tr>
<td><code>is!</code></td>
<td>如果对象是指定的类型返回 <code>false</code></td>
</tr>
</tbody></table>
<p>只有当 <code>obj</code> 实现了 <code>T</code> 的接口， <code>obj is T</code> 才会返回 <code>true</code>。例如 <code>obj is Object</code> 总是返回 <code>true</code>。</p>
<p>使用 <code>as</code> 操作符把对象转换为特定的类型。一般情况下，你可以把它当做用 <code>is</code> 判定类型然后调用所判定对象的方法的缩写形式。例如下面的示例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (emp <span class="keyword">is</span> Person) &#123; <span class="comment">// Type check</span></span><br><span class="line">  emp.firstName = <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>as</code> 操作符可以简化上面的代码：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">(emp <span class="keyword">as</span> Person).firstName = <span class="string">&#x27;Bob&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，上述两个代码片段是有区别的，如果 <code>emp</code> 为 <code>null</code> 或者不是 <code>Person</code> 类型，第一个代码片段的 <code>if</code> 判断就不会成立，<code>emp.firstName = &#39;Bob&#39;;</code> 则不会被执行。而第二个代码片段则会抛出一个异常。</p>
</blockquote>
<h3 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h3><p><code>Dart</code> 支持使用 <code>=</code> 和 <code>??=</code> 进行赋值操作。<code>??=</code> 的作用是为值为 <code>null</code> 的对象赋值：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">a = value;   <span class="comment">// 给 a 变量赋值</span></span><br><span class="line">b ??= value; <span class="comment">// 如果 b 是 null，则赋值给b，如果不是 null，则 b 的值保持不变</span></span><br></pre></td></tr></table></figure>

<p><code>Dart</code> 中还支持如下复合赋值操作符：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>–=</code></td>
<td><code>a -= b</code> 等同于 <code>a = a-b</code></td>
</tr>
<tr>
<td><code>/=</code></td>
<td><code>a /= b</code> 等同于 <code>a = a/b</code></td>
</tr>
<tr>
<td><code>%=</code></td>
<td><code>a %= b</code> 等同于 <code>a = a%b</code></td>
</tr>
<tr>
<td><code>&gt;&gt;=</code></td>
<td><code>a &gt;&gt;= b</code> 等同于 <code>a = a&gt;&gt;b</code></td>
</tr>
<tr>
<td><code>^=</code></td>
<td><code>a %^= b</code> 等同于 <code>a = a^b</code></td>
</tr>
<tr>
<td><code>+=</code></td>
<td><code>a += b</code> 等同于 <code>a = a+b</code></td>
</tr>
<tr>
<td><code>*=</code></td>
<td><code>a *= b</code> 等同于 <code>a = a*b</code></td>
</tr>
<tr>
<td><code>~/=</code></td>
<td><code>a ~/= b</code> 等同于 <code>a = a~/b</code></td>
</tr>
<tr>
<td><code>&lt;&lt;=</code></td>
<td><code>a &lt;&lt;= b</code> 等同于 <code>a = a&lt;&lt;b</code></td>
</tr>
<tr>
<td><code>&amp;=</code></td>
<td><code>a &amp;= b</code> 等同于 <code>a = a&amp;b</code></td>
</tr>
<tr>
<td>`</td>
<td>=`</td>
</tr>
</tbody></table>
<blockquote>
<p>复合赋值操作符是作用于左侧操作数的。表达式 <code>a op= b</code> 等同于 <code>a op= b</code>。即 <code>a += b</code> 等同于 <code>a = a+b</code></p>
</blockquote>
<h3 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><p><code>Dart</code> 中支持如下逻辑操作符：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>!expr</code></td>
<td>对表达式结果取反（<code>true</code> 变为 <code>false</code> ，<code>false</code> 变为 <code>true</code>）</td>
</tr>
<tr>
<td>`</td>
<td></td>
</tr>
<tr>
<td><code>&amp;&amp;</code></td>
<td>逻辑 <code>AND</code> （逻辑与）</td>
</tr>
</tbody></table>
<h3 id="位移操作符"><a href="#位移操作符" class="headerlink" title="位移操作符"></a>位移操作符</h3><p><code>Dart</code> 中支持如下位移操作符：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;</code></td>
<td>按位 <code>AND</code> （按位与）</td>
</tr>
<tr>
<td>`</td>
<td>`</td>
</tr>
<tr>
<td><code>^</code></td>
<td>按位 <code>!OR</code> 按位异或</td>
</tr>
<tr>
<td><code>~expr</code></td>
<td>按位非</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>左移</td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>右移</td>
</tr>
</tbody></table>
<h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><p><code>Dart</code> 中支持 <code>if-else</code> 条件表达式。另外，<code>Dart</code> 还提供额外的两种条件表达式写法用于代替 <code>if-else</code> 表达式：</p>
<ul>
<li><code>condition ? expr1 : expr2</code>：如果 <code>condition</code> 是 <code>true</code>，执行 <code>expr1</code> (并返回执行的结果)；否则执行 <code>expr2</code> 并返回其结果</li>
<li><code>expr1 ?? expr2</code>：如果 <code>expr1</code> 是 <code>non-null</code>，返回其值；否则执行 <code>expr2</code> 并返回其结果</li>
</ul>
<h3 id="级联操作符"><a href="#级联操作符" class="headerlink" title="级联操作符"></a>级联操作符</h3><p>在 <code>Dart</code> 中，级联操作符（<code>..</code>）允许我们在同一个对象上连续调用多个函数以及访问成员变量。使用级联操作符可以避免创建临时变量：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">querySelector</span>(<span class="string">&#x27;#button&#x27;</span>) <span class="comment">// Get an object.</span></span><br><span class="line">  ..text = <span class="string">&#x27;Confirm&#x27;</span>   <span class="comment">// Use its members.</span></span><br><span class="line">  ..classes.add(<span class="string">&#x27;important&#x27;</span>)</span><br><span class="line">  ..onClick.listen((e) =&gt; <span class="built_in">window</span>.alert(<span class="string">&#x27;Confirmed!&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>第一个方法 <code>querySelector()</code> 返回了一个 <code>selector</code> 对象。后面的级联操作符都是调用这个对象的成员，并忽略每个操作 所返回的值。</p>
<p>下面的代码在功能上等同于上述代码：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">querySelector</span>(<span class="string">&#x27;#button&#x27;</span>);</span><br><span class="line">button.text = <span class="string">&#x27;Confirm&#x27;</span>;</span><br><span class="line">button.classes.add(<span class="string">&#x27;important&#x27;</span>);</span><br><span class="line">button.onClick.listen((e) =&gt; <span class="built_in">window</span>.alert(<span class="string">&#x27;Confirmed!&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>下面的示例展示了级联调用的嵌套使用情况：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> addressBook = (<span class="keyword">new</span> AddressBookBuilder()</span><br><span class="line">      ..name = <span class="string">&#x27;jenny&#x27;</span></span><br><span class="line">      ..email = <span class="string">&#x27;jenny@example.com&#x27;</span></span><br><span class="line">      ..phone = (<span class="keyword">new</span> PhoneNumberBuilder()</span><br><span class="line">            ..number = <span class="string">&#x27;415-555-0100&#x27;</span></span><br><span class="line">            ..label = <span class="string">&#x27;home&#x27;</span>)</span><br><span class="line">          .build())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<h3 id="其他操作符"><a href="#其他操作符" class="headerlink" title="其他操作符"></a>其他操作符</h3><p><code>Dart</code> 中还有一些其他的操作符：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>名称</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>()</code></td>
<td>使用方法</td>
<td>代表调用一个方法</td>
</tr>
<tr>
<td><code>[]</code></td>
<td>访问 <code>List</code></td>
<td>访问 <code>List</code> 中特定位置的元素</td>
</tr>
<tr>
<td><code>.</code></td>
<td>访问元素</td>
<td><code>foo.bar</code> 代表访问 <code>foo</code> 中的元素 <code>bar</code></td>
</tr>
<tr>
<td><code>?.</code></td>
<td>条件成员访问</td>
<td>与 <code>.</code> 类似，但是左边的操作对象不能为 <code>null</code></td>
</tr>
</tbody></table>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p><code>Dart</code> 中支持如下几种流程控制语法：</p>
<ul>
<li><code>if-else</code> 条件判断</li>
<li><code>for</code> 循环</li>
<li><code>while</code> 和 <code>do-while</code> 循环</li>
<li><code>break</code> 和 <code>continue</code></li>
<li><code>switch</code> 条件判断</li>
<li><code>assert</code> 断言</li>
</ul>
<h3 id="if-else-条件判断"><a href="#if-else-条件判断" class="headerlink" title="if-else 条件判断"></a>if-else 条件判断</h3><p><code>Dart</code> 中支持 <code>if</code> 语句以及可选的 <code>else</code> 语句：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isRaining()) &#123;</span><br><span class="line">  you.bringRainCoat();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (isSnowing()) &#123;</span><br><span class="line">  you.wearJacket();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  car.putTopDown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p><code>Dart</code> 中支持如下 <code>for</code> 循环语句：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="keyword">new</span> <span class="built_in">StringBuffer</span>(<span class="string">&quot;Dart is fun&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  message.write(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要遍历的对象实现了 <code>Iterable</code> 接口，则可以使用 <code>forEach()</code> 方法。如果没必要当前遍历的索引，则使用 <code>forEach()</code> 方法是个非常好的选择：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">candidates.forEach((candidate) =&gt; candidate.interview());</span><br></pre></td></tr></table></figure>

<p><code>List</code> 和 <code>Set</code> 等实现了 <code>Iterable</code> 接口的类还支持 <code>for-in</code> 形式的遍历：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> collection = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">in</span> collection) &#123;</span><br><span class="line">  <span class="built_in">print</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="while-和-do-while-循环"><a href="#while-和-do-while-循环" class="headerlink" title="while 和 do-while 循环"></a>while 和 do-while 循环</h3><p><code>Dart</code> 中，<code>while</code> 循环在执行循环之前先判断条件是否满足：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!isDone()) &#123;</span><br><span class="line">  doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 <code>do-while</code> 是先执行循环再判断条件是否满足：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  printLine();</span><br><span class="line">&#125; <span class="keyword">while</span> (!atEndOfPage());</span><br></pre></td></tr></table></figure>

<h3 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a>break 和 continue</h3><p><code>Dart</code> 中可以实现 <code>break</code> 来中断当前的循环：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (shutDownRequested()) <span class="keyword">break</span>;</span><br><span class="line">  processIncomingRequests();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 <code>continue</code> 则是中断当前循环并进入下一次循环：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; candidates.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> candidate = candidates[i];</span><br><span class="line">  <span class="keyword">if</span> (candidate.yearsExperience &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  candidate.interview();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述代码在实现了 <code>Iterable</code> 接口的对象上可以采用如下写法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">candidates.where((c) =&gt; c.yearsExperience &gt;= <span class="number">5</span>)</span><br><span class="line">          .forEach((c) =&gt; c.interview());</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="switch-条件判断"><a href="#switch-条件判断" class="headerlink" title="switch 条件判断"></a>switch 条件判断</h3><p>在 <code>Dart</code> 中可以使用<code>switch</code> 语句比较 <code>integer</code>、<code>string</code>、或者编译时常量。比较的对象必须都是同一个类的实例，<code>class</code> 必须没有覆写 <code>==</code> 操作符：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> command = <span class="string">&#x27;OPEN&#x27;</span>;</span><br><span class="line"><span class="keyword">switch</span> (command) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;CLOSED&#x27;</span>:</span><br><span class="line">    executeClosed();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;PENDING&#x27;</span>:</span><br><span class="line">    executePending();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;APPROVED&#x27;</span>:</span><br><span class="line">    executeApproved();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;DENIED&#x27;</span>:</span><br><span class="line">    executeDenied();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;OPEN&#x27;</span>:</span><br><span class="line">    executeOpen();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    executeUnknown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>每个非空的 <code>case</code> 语句都必须有一个 <code>break</code> 语句。另外还可以通过 <code>continue</code>、<code>throw</code> 或者 <code>return</code> 来结束非空 <code>case</code> 语句。当没有 <code>case</code> 语句匹配的时候，可以使用 <code>default</code> 语句来匹配这种默认情况。</p>
</blockquote>
<p>如果你需要实现这种继续到下一个 <code>case</code> 语句中继续执行，则可以 使用 <code>continue</code> 语句跳转到对应的标签（<code>label</code>）处继续执行：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> command = <span class="string">&#x27;CLOSED&#x27;</span>;</span><br><span class="line"><span class="keyword">switch</span> (command) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;CLOSED&#x27;</span>:</span><br><span class="line">    executeClosed();</span><br><span class="line">    <span class="keyword">continue</span> nowClosed;</span><br><span class="line">    <span class="comment">// Continues executing at the nowClosed label.</span></span><br><span class="line"></span><br><span class="line">nowClosed:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;NOW_CLOSED&#x27;</span>:</span><br><span class="line">    <span class="comment">// Runs for both CLOSED and NOW_CLOSED.</span></span><br><span class="line">    executeNowClosed();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，每个 <code>case</code> 语句都可以有局部变量，局部变量只有在这个语句内可见。</p>
</blockquote>
<h3 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h3><p>在 <code>Dart</code> 中，如果条件表达式结果不满足需要，则可以使用 <code>assert</code> 语句俩打断代码的执行：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Make sure the variable has a non-null value.</span></span><br><span class="line"><span class="keyword">assert</span>(text != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make sure the value is less than 100.</span></span><br><span class="line"><span class="keyword">assert</span>(number &lt; <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make sure this is an https URL.</span></span><br><span class="line"><span class="keyword">assert</span>(urlString.startsWith(<span class="string">&#x27;https&#x27;</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是， 断言只在检查模式下运行有效，如果在生产模式运行，则断言不会执行。</p>
</blockquote>
<p><code>assert</code> 方法的参数可以为任何返回布尔值的表达式或者方法。如果返回的值为 <code>true</code>， 断言执行通过，执行结束。如果返回值为 <code>false</code>， 断言执行失败，会抛出一个 <code>AssertionError</code> 异常。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>在 <code>Dart</code> 代码中可以通过抛出异常和捕获异常以达到处理某些错误的目的。<code>Dart</code> 中提供了 <code>Exception</code> 和 <code>Error</code> 类型用于表示异常。我们可以抛出已有的异常类型，也可以自定义异常类型。与 <code>Java</code> 不同的是，<code>Dart</code> 中可以抛出任何 <code>non-null</code> 对象为异常。</p>
<h3 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h3><p>在 <code>Dart</code> 中使用关键字 <code>throw</code> 抛出一个 <code>FormatException</code> 异常：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> FormatException(<span class="string">&#x27;Expected at least 1 section&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>或者抛出一个 <code>String</code> 类型的异常：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="string">&#x27;Out of llamas!&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="catch-或-on"><a href="#catch-或-on" class="headerlink" title="catch 或 on"></a>catch 或 on</h3><p>在 <code>Dart</code> 中可以使用 <code>catch</code> 或者 <code>on</code> 处理异常。<code>on</code> 用于指定异常类型，<code>catch</code> 用于捕获异常对象：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; <span class="keyword">on</span> OutOfLlamasException &#123;</span><br><span class="line">  <span class="comment">// A specific exception</span></span><br><span class="line">  buyMoreLlamas();</span><br><span class="line">&#125; <span class="keyword">on</span> Exception <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// Anything else that is an exception</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Unknown exception: <span class="subst">$e</span>&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// No specified type, handles all</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Something really unknown: <span class="subst">$e</span>&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>catch</code> 后面可以有一个或者两个参数，第一个参数表示抛出的异常对象，第二个参数表示堆栈信息（<code>StackTrace</code>）对象。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; <span class="keyword">on</span> OutOfLlamasException &#123;</span><br><span class="line">  <span class="comment">// A specific exception</span></span><br><span class="line">  buyMoreLlamas();</span><br><span class="line">&#125; <span class="keyword">on</span> Exception <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// Anything else that is an exception</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Unknown exception: <span class="subst">$e</span>&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e, s) &#123;</span><br><span class="line">  <span class="comment">// No specified type, handles all</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Something really unknown: <span class="subst">$e</span>&#x27;</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Stack trace:\n <span class="subst">$s</span>&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以使用 <code>rethrow</code> 关键字把异常重新抛出：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> foo = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> misbehave() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    foo = <span class="string">&quot;You can&#x27;t change a final variable&#x27;s value.&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;misbehave() partially handled <span class="subst">$&#123;e.runtimeType&#125;</span>.&#x27;</span>);</span><br><span class="line">    <span class="keyword">rethrow</span>; <span class="comment">// Allow callers to see the exception.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    misbehave();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;main() finished handling <span class="subst">$&#123;e.runtimeType&#125;</span>.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p>为了确保在抛出异常时（或者没有抛出异常），某些逻辑能够正常执行，可以使用 <code>finally</code> 关键字来确保代码的正常执行：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Error: <span class="subst">$e</span>&#x27;</span>);  <span class="comment">// Handle the exception first.</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  cleanLlamaStalls();  <span class="comment">// Then clean up.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果省略了 <code>catch</code>，则会在 <code>finally</code> 执行完毕之后将异常抛出：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// Always clean up, even if an exception is thrown.</span></span><br><span class="line">  cleanLlamaStalls();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>与 <code>Java</code> 类似的，<code>Dart</code> 中的类也都是派生于 <code>Object</code> 超类，并且是单一继承结构的。</p>
<p>在 <code>Dart</code> 中通过使用 <code>new</code> 关键字和构造函数来创建一个新的对象（构造函数名字可以为 <code>ClassName</code> 或者 <code>ClassName.identifier</code>）：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonData = JSON.decode(<span class="string">&#x27;&#123;&quot;x&quot;:1, &quot;y&quot;:2&#125;&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a Point using Point().</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a Point using Point.fromJson().</span></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Point.fromJson(jsonData);</span><br></pre></td></tr></table></figure>

<p>对象的成员包括方法和数据 (方法和实例变量)。当你调用一个函数的时候，你是在一个对象上调用该函数需要访问对象的方法和数据。</p>
<p>使用点(<code>.</code>)来引用对象的变量或者方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the value of the instance variable y.</span></span><br><span class="line">p.y = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the value of y.</span></span><br><span class="line"><span class="keyword">assert</span>(p.y == <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke distanceTo() on p.</span></span><br><span class="line"><span class="built_in">num</span> distance = p.distanceTo(<span class="keyword">new</span> Point(<span class="number">4</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure>

<p>或者使用 <code>?.</code> 来替代 <code>.</code> 以避免当左边对象为 <code>null</code> 时抛出异常：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// If p is non-null, set its y value to 4.</span></span><br><span class="line">p?.y = <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>有些类提供了常量构造函数。使用常量构造函数可以创建编译时常量，要使用常量构造函数只需要用 <code>const</code> 替代 <code>new</code> 即可：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">const</span> ImmutablePoint(<span class="number">2</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 <code>Dart</code> 中，两个一样的编译时常量其实是同一个对象。也就是说 <code>var a = const ImmutablePoint(1, 1);</code> 和 <code>var b = const ImmutablePoint(1, 1);</code> 中 <code>a</code> 和 <code>b</code> 实际上是同一个对象（即 <code>assert(identical(a, b));</code> 为 <code>true</code>）。</p>
</blockquote>
<p>可以使用 <code>Object</code> 的 <code>runtimeType</code> 属性来判断实例的类型，该属性返回一个 <code>Type</code> 对象：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The type of a is <span class="subst">$&#123;p.runtimeType&#125;</span>&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="变量实例"><a href="#变量实例" class="headerlink" title="变量实例"></a>变量实例</h3><p>在 <code>Dart</code> 中，所有类的实例变量或默认初始化为 <code>null</code>：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x; <span class="comment">// Declare instance variable x, initially null.</span></span><br><span class="line">  <span class="built_in">num</span> y; <span class="comment">// Declare y, initially null.</span></span><br><span class="line">  <span class="built_in">num</span> z = <span class="number">0</span>; <span class="comment">// Declare z, initially 0.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个实例变量会自动生成一个隐式的 <code>getter</code> 方法，对于非 <code>final</code> 变量还会自动生成一个隐式的 <code>setter</code> 方法。下属代码是可以正常运行的：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> point = <span class="keyword">new</span> Point();</span><br><span class="line">  point.x = <span class="number">4</span>;          <span class="comment">// Use the setter method for x.</span></span><br><span class="line">  <span class="keyword">assert</span>(point.x == <span class="number">4</span>); <span class="comment">// Use the getter method for x.</span></span><br><span class="line">  <span class="keyword">assert</span>(point.y == <span class="keyword">null</span>); <span class="comment">// Values default to null.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>定义一个和类名字一样的方法就定义了一个构造函数：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="built_in">num</span> x, <span class="built_in">num</span> y) &#123;</span><br><span class="line">    <span class="comment">// There&#x27;s a better way to do this, stay tuned.</span></span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于把构造函数参数赋值给实例变量的场景太常见了，<code>Dart</code> 提供了一个语法糖来简化这个操作：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Syntactic sugar for setting x and y</span></span><br><span class="line">  <span class="comment">// before the constructor body runs.</span></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><p>如果我们没有定义构造函数，则会有个默认构造函数。默认构造函数没有参数，并且会调用超类的没有参数的构造函数。</p>
<p>需要注意的是，在 <code>Dart</code> 中子类不会继承父类的构造函数。子类如果没有定义构造函数，那么就只有一个默认构造函数。如果需要调用父类的构造函数，则需要我们在子类中手动调用。在构造函数参数后使用冒号 (<code>:</code>) 可以调用 超类构造函数：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> firstName;</span><br><span class="line"></span><br><span class="line">  Person.fromJson(<span class="built_in">Map</span> data) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;in Person&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Person does not have a default constructor;</span></span><br><span class="line">  <span class="comment">// you must call super.fromJson(data).</span></span><br><span class="line">  Employee.fromJson(<span class="built_in">Map</span> data) : <span class="keyword">super</span>.fromJson(data) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;in Employee&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> emp = <span class="keyword">new</span> Employee.fromJson(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prints:</span></span><br><span class="line">  <span class="comment">// in Person</span></span><br><span class="line">  <span class="comment">// in Employee</span></span><br><span class="line">  <span class="keyword">if</span> (emp <span class="keyword">is</span> Person) &#123;</span><br><span class="line">    <span class="comment">// Type check</span></span><br><span class="line">    emp.firstName = <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  (emp <span class="keyword">as</span> Person).firstName = <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="命名构造函数"><a href="#命名构造函数" class="headerlink" title="命名构造函数"></a>命名构造函数</h4><p>使用命名构造函数可以为一个类实现多个构造函数：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Named constructor</span></span><br><span class="line">  Point.fromJson(<span class="built_in">Map</span> json) &#123;</span><br><span class="line">    x = json[<span class="string">&#x27;x&#x27;</span>];</span><br><span class="line">    y = json[<span class="string">&#x27;y&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><p>在构造函数体执行之前除了可以调用超类构造函数之外，还可以初始化实例参数。使用逗号（<code>,</code>）分隔初始化表达式：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initializer list sets instance variables before</span></span><br><span class="line">  <span class="comment">// the constructor body runs.</span></span><br><span class="line">  Point.fromJson(<span class="built_in">Map</span> jsonMap)</span><br><span class="line">      : x = jsonMap[<span class="string">&#x27;x&#x27;</span>],</span><br><span class="line">        y = jsonMap[<span class="string">&#x27;y&#x27;</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;In Point.fromJson(): (<span class="subst">$x</span>, <span class="subst">$y</span>)&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化列表非常适合用来设置 <code>final</code> 变量的值。下面示例代码中初始化列表设置了三个 <code>final</code> 变量的值：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:math&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> x;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> y;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> distanceFromOrigin;</span><br><span class="line"></span><br><span class="line">  Point(x, y)</span><br><span class="line">      : x = x,</span><br><span class="line">        y = y,</span><br><span class="line">        distanceFromOrigin = sqrt(x * x + y * y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">print</span>(p.distanceFromOrigin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重定向构造函数"><a href="#重定向构造函数" class="headerlink" title="重定向构造函数"></a>重定向构造函数</h4><p>如果需要在一个构造函数中调用类中的其他构造函数，那么可以使用冒号（<code>:</code>）调用其他的构造函数：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The main constructor for this class.</span></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Delegates to the main constructor.</span></span><br><span class="line">  Point.alongXAxis(<span class="built_in">num</span> x) : <span class="keyword">this</span>(x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="常量构造函数"><a href="#常量构造函数" class="headerlink" title="常量构造函数"></a>常量构造函数</h4><p>如果我们的类是一个状态不变的对象，我们可以把这些对象定义为编译时常量。通过对构造函数使用 <code>const</code> 关键字并把所有的变量声明为 <code>final</code> 来实现：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImmutablePoint</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> x;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> y;</span><br><span class="line">  <span class="keyword">const</span> ImmutablePoint(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> ImmutablePoint origin =</span><br><span class="line">      <span class="keyword">const</span> ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="工厂方法构造函数"><a href="#工厂方法构造函数" class="headerlink" title="工厂方法构造函数"></a>工厂方法构造函数</h4><p>如果一个构造函数并不总是返回一个新的对象，则使用 <code>factory</code> 来定义这个构造函数。例如，一个工厂构造函数可能从缓存中获取一个实例并返回，或者返回一个子类型的实例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">bool</span> mute = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// _cache is library-private, thanks to the _ in front</span></span><br><span class="line">  <span class="comment">// of its name.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Logger&gt; _cache =</span><br><span class="line">      &lt;<span class="built_in">String</span>, Logger&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> Logger(<span class="built_in">String</span> name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_cache.containsKey(name)) &#123;</span><br><span class="line">      <span class="keyword">return</span> _cache[name];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> logger = <span class="keyword">new</span> Logger._internal(name);</span><br><span class="line">      _cache[name] = logger;</span><br><span class="line">      <span class="keyword">return</span> logger;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Logger._internal(<span class="keyword">this</span>.name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> log(<span class="built_in">String</span> msg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mute) &#123;</span><br><span class="line">      <span class="built_in">print</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，通过 <code>new</code> 关键字来调用工厂构造函数：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> logger = <span class="keyword">new</span> Logger(<span class="string">&#x27;UI&#x27;</span>);</span><br><span class="line">logger.log(<span class="string">&#x27;Button clicked&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><p>对象的实例方法可以访问 <code>this</code>：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:math&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">num</span> distanceTo(Point other) &#123;</span><br><span class="line">    <span class="keyword">var</span> dx = x - other.x;</span><br><span class="line">    <span class="keyword">var</span> dy = y - other.y;</span><br><span class="line">    <span class="keyword">return</span> sqrt(dx * dx + dy * dy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getter-和-setter-方法"><a href="#getter-和-setter-方法" class="headerlink" title="getter 和 setter 方法"></a>getter 和 setter 方法</h4><p><code>getter</code> 和 <code>setter</code> 方法是用来设置和访问对象属性的特殊函数。每个实例变量都有一个隐式的 <code>getter</code> 方法，每一个非 <code>final</code> 变量都有一个隐式的 <code>setter</code> 方法。我们可以通过使用 <code>get</code> 和 <code>set</code> 关键字来定义 <code>getter</code> 和 <code>setter</code> 方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> left;</span><br><span class="line">  <span class="built_in">num</span> top;</span><br><span class="line">  <span class="built_in">num</span> width;</span><br><span class="line">  <span class="built_in">num</span> height;</span><br><span class="line"></span><br><span class="line">  Rectangle(<span class="keyword">this</span>.left, <span class="keyword">this</span>.top, <span class="keyword">this</span>.width, <span class="keyword">this</span>.height);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Define two calculated properties: right and bottom.</span></span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> right             =&gt; left + width;</span><br><span class="line">      <span class="keyword">set</span> right(<span class="built_in">num</span> value)  =&gt; left = value - width;</span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> bottom            =&gt; top + height;</span><br><span class="line">      <span class="keyword">set</span> bottom(<span class="built_in">num</span> value) =&gt; top = value - height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> rect = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>, <span class="number">20</span>, <span class="number">15</span>);</span><br><span class="line">  <span class="keyword">assert</span>(rect.left == <span class="number">3</span>);</span><br><span class="line">  rect.right = <span class="number">12</span>;</span><br><span class="line">  <span class="keyword">assert</span>(rect.left == <span class="number">-8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h4><p>在 <code>Dart</code> 中，实例函数、<code>getter</code> 和 <code>setter</code> 方法可以是抽象函数。抽象函数是只定义函数接口但是没有具体实现的函数：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Doer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...Define instance variables and methods...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> doSomething(); <span class="comment">// Define an abstract method.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EffectiveDoer</span> <span class="keyword">extends</span> <span class="title">Doer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> doSomething() &#123;</span><br><span class="line">    <span class="comment">// ...Provide an implementation, so the method is not abstract here...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可复写的操作符"><a href="#可复写的操作符" class="headerlink" title="可复写的操作符"></a>可复写的操作符</h4><p>下表中的操作符可以进行复写：</p>
<p>| — | — | — | — |<br>| <code>&lt;</code> | <code>+</code> | <code>[]</code> | <code>|</code> |<br>| <code>&lt;</code>| <code>/</code> | <code>^</code>| <code>[]=</code> |<br>| <code>&lt;=</code> | <code>~/</code> | <code>&amp;</code> | <code>~</code> |<br>| <code>&gt;=</code> | <code>*</code>| <code>&lt;&lt;</code> | <code>==</code> |<br>| <code>-</code> | <code>%</code> | <code>&gt;&gt;</code> |  |</p>
<p>下面是覆写了 <code>+</code> 和 <code>-</code> 操作符的示例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> x;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> y;</span><br><span class="line">  <span class="keyword">const</span> Vector(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Overrides + (a + b).</span></span></span><br><span class="line">  Vector <span class="keyword">operator</span> +(Vector v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vector(x + v.x, y + v.y);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Overrides - (a - b).</span></span></span><br><span class="line">  Vector <span class="keyword">operator</span> -(Vector v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vector(x - v.x, y - v.y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">final</span> v = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">final</span> w = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// v == (2, 3)</span></span><br><span class="line">  <span class="keyword">assert</span>(v.x == <span class="number">2</span> &amp;&amp; v.y == <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// v + w == (4, 5)</span></span><br><span class="line">  <span class="keyword">assert</span>((v + w).x == <span class="number">4</span> &amp;&amp; (v + w).y == <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// v - w == (0, 1)</span></span><br><span class="line">  <span class="keyword">assert</span>((v - w).x == <span class="number">0</span> &amp;&amp; (v - w).y == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>在 <code>Dart</code> 中，<code>abstract</code> 关键字用于修饰一个抽象类。抽象类通常用来定义接口以及部分实现，如果我们希望我们的抽象类是可实例化的，那么需要定义一个工厂构造函数：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractContainer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...Define constructors, fields, methods...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> updateChildren(); <span class="comment">// Abstract method.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 <code>Java</code> 中抽象类一样，在 <code>Dart</code> 中抽象类是不能实例化的。如果我们在一个普通类中定义了一个抽象函数，则是可以实例化的：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecializedContainer</span> <span class="keyword">extends</span> <span class="title">AbstractContainer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...Define more constructors, fields, methods...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> updateChildren() &#123;</span><br><span class="line">    <span class="comment">// ...Implement updateChildren()...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Abstract method causes a warning but</span></span><br><span class="line">  <span class="comment">// doesn&#x27;t prevent instantiation.</span></span><br><span class="line">  <span class="keyword">void</span> doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>一个类可以通过 <code>implements</code> 关键字来实现一个或者多个接口， 并实现每个接口：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// In the interface, but visible only in this library.</span></span><br><span class="line">  <span class="keyword">final</span> _name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not in the interface, since this is a constructor.</span></span><br><span class="line">  Person(<span class="keyword">this</span>._name);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// In the interface.</span></span><br><span class="line">  <span class="built_in">String</span> greet(who) =&gt; <span class="string">&#x27;Hello, <span class="subst">$who</span>. I am <span class="subst">$_name</span>.&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// An implementation of the Person interface.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Imposter</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We have to define this, but we don&#x27;t use it.</span></span><br><span class="line">  <span class="keyword">final</span> _name = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> greet(who) =&gt; <span class="string">&#x27;Hi <span class="subst">$who</span>. Do you know who I am?&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greetBob(Person person) =&gt; person.greet(<span class="string">&#x27;bob&#x27;</span>);</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(greetBob(<span class="keyword">new</span> Person(<span class="string">&#x27;kathy&#x27;</span>)));</span><br><span class="line">  <span class="built_in">print</span>(greetBob(<span class="keyword">new</span> Imposter()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩展类"><a href="#扩展类" class="headerlink" title="扩展类"></a>扩展类</h3><p>通过使用 <code>extends</code> 实现从父类派生一个子类的目的：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;</span><br><span class="line">    _illuminateDisplay();</span><br><span class="line">    _activateIrSensor();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartTelevision</span> <span class="keyword">extends</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;</span><br><span class="line">    <span class="keyword">super</span>.turnOn();</span><br><span class="line">    _bootNetworkInterface();</span><br><span class="line">    _initializeMemory();</span><br><span class="line">    _upgradeApps();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>super</code> 关键字用于访问父类对象</p>
</blockquote>
<p>子类可以覆写实例方法，<code>getter</code> 和 <code>setter</code> 方法。下面是覆写 <code>Object</code> 类的 <code>noSuchMethod()</code> 方法的例子，如果调用了对象上不存在的方法，则就会触发 <code>noSuchMethod()</code> 方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> noSuchMethod(Invocation mirror) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>@override</code> 注解表明该方法是复写的父类方法。</p>
</blockquote>
<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>枚举类是一种特殊类型的类，主要用来表示一个数量固定的常量集。我们可以使用 <code>enum</code> 来定义一个枚举类：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">  red,</span><br><span class="line">  green,</span><br><span class="line">  blue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类中的每个值都有一个 <code>index</code> 的 <code>getter</code> 方法，该方法返回该值在枚举类型定义中的位置（从 0 开始。枚举的 <code>values</code> 常量则可以返回所有的枚举值。</p>
<h3 id="扩展类的功能"><a href="#扩展类的功能" class="headerlink" title="扩展类的功能"></a>扩展类的功能</h3><p><code>mixin</code> 是一种在多类继承中重用一个类代码的方法。使用 <code>with</code> 关键字后面为一个或者多个 <code>mixin</code> 名字来使用 <code>mixin</code>：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Musician</span> <span class="keyword">extends</span> <span class="title">Performer</span> <span class="title">with</span> <span class="title">Musical</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Maestro</span> <span class="keyword">extends</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">Musical</span>, <span class="title">Aggressive</span>, <span class="title">Demented</span> </span>&#123;</span><br><span class="line">  Maestro(<span class="built_in">String</span> maestroName) &#123;</span><br><span class="line">    name = maestroName;</span><br><span class="line">    canConduct = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个类继承 <code>Object</code>，该类没有构造函数，不能调用 <code>super</code> ，则该类就是一个 <code>mixin</code>：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Musical</span> </span>&#123;</span><br><span class="line">  <span class="built_in">bool</span> canPlayPiano = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">bool</span> canCompose = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">bool</span> canConduct = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> entertainMe() &#123;</span><br><span class="line">    <span class="keyword">if</span> (canPlayPiano) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;Playing piano&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (canConduct) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;Waving hands&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;Humming to self&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态变量和静态方法"><a href="#静态变量和静态方法" class="headerlink" title="静态变量和静态方法"></a>静态变量和静态方法</h3><p>在 <code>Dart</code> 中，可以使用 <code>static</code> 关键字来实现类级别的变量和方法，它们分别被称为静态变量和静态方法。</p>
<h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><p>静态变量在第一次使用的时候才被初始化。静态变量对于类级别的状态是非常有用的：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> red = <span class="keyword">const</span> Color(<span class="string">&#x27;red&#x27;</span>); <span class="comment">// A constant static variable.</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;      <span class="comment">// An instance variable.</span></span><br><span class="line">  <span class="keyword">const</span> Color(<span class="keyword">this</span>.name); <span class="comment">// A constant constructor.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(Color.red.name == <span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>静态方法可以当做编译时常量使用。例如，我们可以把静态方法当做常量构造函数的参数来使用。静态方法的示例如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:math&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">num</span> distanceBetween(Point a, Point b) &#123;</span><br><span class="line">    <span class="keyword">var</span> dx = a.x - b.x;</span><br><span class="line">    <span class="keyword">var</span> dy = a.y - b.y;</span><br><span class="line">    <span class="keyword">return</span> sqrt(dx * dx + dy * dy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">var</span> b = <span class="keyword">new</span> Point(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">var</span> distance = Point.distanceBetween(a, b);</span><br><span class="line">  <span class="keyword">assert</span>(distance &lt; <span class="number">2.9</span> &amp;&amp; distance &gt; <span class="number">2.8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>在 <code>Dart</code> 中，通常使用一个字母来代表泛型参数，例如 <code>E</code>、<code>T</code>、<code>S</code>、<code>K</code> 和 <code>V</code> 等。</p>
<p>在 <code>Dart</code> 中，类型是可选的，我们可以选择不使用泛型。有些情况下我们可能需要使用类型来表明意图，不管是使用泛型还是具体类型。例如，如果我们希望一个 <code>List</code> 只包含字符串对象，那么我们可以使用泛型的方式定义 <code>List&lt;String&gt;</code>:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names = <span class="keyword">new</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">names.addAll([<span class="string">&#x27;Seth&#x27;</span>, <span class="string">&#x27;Kathy&#x27;</span>, <span class="string">&#x27;Lars&#x27;</span>]);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">names.add(<span class="number">42</span>); <span class="comment">// Fails in checked mode (succeeds in production mode).</span></span><br></pre></td></tr></table></figure>


<p>另外一个使用泛型的原因是减少重复的代码。泛型可以在多种类型之间定义同一个实现，同时还可以继续使用检查模式和静态分析工具提供的代码分析功能。例如，我们创建一个保存缓存对象的接口：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectCache</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span> getByKey(<span class="built_in">String</span> key);</span><br><span class="line">  setByKey(<span class="built_in">String</span> key, <span class="built_in">Object</span> value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随着需求的变化，我们不得不重新定义一个新的缓存类来缓存 <code>String</code> 对象：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StringCache</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> getByKey(<span class="built_in">String</span> key);</span><br><span class="line">  setByKey(<span class="built_in">String</span> key, <span class="built_in">String</span> value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用泛型则可以避免上述重复的代码，我们只需要定一个泛型接口：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  T getByKey(<span class="built_in">String</span> key);</span><br><span class="line">  setByKey(<span class="built_in">String</span> key, T value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>T</code> 是一个备用类型。这是一个类型占位符，在我们调用该接口的时候需要指定具体类型。</p>
<h3 id="在构造函数中使用泛型"><a href="#在构造函数中使用泛型" class="headerlink" title="在构造函数中使用泛型"></a>在构造函数中使用泛型</h3><p>在调用构造函数的时候， 在类名字后面使用尖括号(<code>&lt; &gt;</code>)来指定 泛型类型：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names = <span class="keyword">new</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">names.addAll([<span class="string">&#x27;Seth&#x27;</span>, <span class="string">&#x27;Kathy&#x27;</span>, <span class="string">&#x27;Lars&#x27;</span>]);</span><br><span class="line"><span class="keyword">var</span> nameSet = <span class="keyword">new</span> <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt;.from(names);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Dart</code> 中的泛型类型是固化的，在运行时有也可以判断具体的类型。这与 <code>Java</code> 是不同的。<code>Java</code> 中的泛型信息是编译时的，泛型信息在运行时是不存在的。在 <code>Java</code> 中我们可以判断一个对象是否为 <code>List</code>， 但是我们无法判断一个对象是否为 <code>List&lt;String&gt;</code>。</p>
</blockquote>
<h3 id="限制泛型类型"><a href="#限制泛型类型" class="headerlink" title="限制泛型类型"></a>限制泛型类型</h3><p>在声明泛型时，我们可以通过使用 <code>extends</code> 关键字来限制泛型的类型：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SomeBaseClass</span>&gt; </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Extender</span> <span class="keyword">extends</span> <span class="title">SomeBaseClass</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// It&#x27;s OK to use SomeBaseClass or any of its subclasses inside &lt;&gt;.</span></span><br><span class="line">  <span class="keyword">var</span> someBaseClassFoo = <span class="keyword">new</span> Foo&lt;SomeBaseClass&gt;();</span><br><span class="line">  <span class="keyword">var</span> extenderFoo = <span class="keyword">new</span> Foo&lt;Extender&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// It&#x27;s also OK to use no &lt;&gt; at all.</span></span><br><span class="line">  <span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Specifying any non-SomeBaseClass type results in a warning and, in</span></span><br><span class="line">  <span class="comment">// checked mode, a runtime error.</span></span><br><span class="line">  <span class="comment">// var objectFoo = new Foo&lt;Object&gt;();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>在方法中使用泛型的示例如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">T first&lt;T&gt;(<span class="built_in">List</span>&lt;T&gt; ts) &#123;</span><br><span class="line">  <span class="comment">// ...Do some initial work or error checking, then...</span></span><br><span class="line">  T tmp ?= ts[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// ...Do some additional checking or processing...</span></span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>first (&lt;T&gt;)</code> 泛型方法可以在如下地方使用参数 <code>T</code> ：</p>
<ul>
<li>方法的返回值类型 (<code>T</code>)</li>
<li>参数的类型 (<code>List&lt;T&gt;</code>)</li>
<li>局部变量的类型 (<code>T tmp</code>)</li>
</ul>
<h2 id="库和可见性"><a href="#库和可见性" class="headerlink" title="库和可见性"></a>库和可见性</h2><p>在 <code>Dart</code> 中，使用 <code>import</code> 和 <code>library</code> 指令可以帮助我们创建模块化的可分享的代码。库不仅仅提供访问接口，还是一个私有单元：以下划线 (<code>_</code>) 开头的标识符只有在库内部可见。</p>
<blockquote>
<p>事实上，每个 <code>Dart app</code> 都是一个库， 即使没有使用 <code>library</code> 命令也是一个库。</p>
</blockquote>
<p>库可以使用 <code>Dart package</code> 工具部署。参考 <a href="https://www.dartlang.org/tools/pub">Pub Package 和 Asset Manager</a> 来获取关于 <code>pub</code>（<code>Dart</code> 的包管理工具） 的更多信息。</p>
<h3 id="使用库"><a href="#使用库" class="headerlink" title="使用库"></a>使用库</h3><p>在 <code>Dart</code> 中，使用 <code>import</code> 来指定一个库：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:html&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><code>import</code> 必须参数为库的 <code>URI</code>。 对于内置的库，<code>URI</code> 使用特殊的 <code>dart:scheme</code>。对于其他的库，我们可以使用文件系统路径或者 <code>package:scheme</code>（<code>package:scheme</code> 指定的库通过包管理器来提供，例如 <code>pub</code> 工具）：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:io&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:mylib/mylib.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:utils/utils.dart&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="指定库前缀"><a href="#指定库前缀" class="headerlink" title="指定库前缀"></a>指定库前缀</h3><p>如果我们导入的两个库有冲突的标识符，我们可以使用库的前缀来区分。例如，如果 <code>library1</code> 和 <code>library2</code> 都有一个名字为 <code>Element</code> 的类，我们可以这样使用：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lib1/lib1.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lib2/lib2.dart&#x27;</span> <span class="keyword">as</span> lib2;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">Element</span> element1 = <span class="keyword">new</span> <span class="built_in">Element</span>();           <span class="comment">// Uses Element from lib1.</span></span><br><span class="line">lib2.<span class="built_in">Element</span> element2 = <span class="keyword">new</span> lib2.<span class="built_in">Element</span>(); <span class="comment">// Uses Element from lib2.</span></span><br></pre></td></tr></table></figure>

<h3 id="导入库的一部分"><a href="#导入库的一部分" class="headerlink" title="导入库的一部分"></a>导入库的一部分</h3><p>如果我们只使用库的一部分功能，则可以选择导入需要的内容：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Import only foo.</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lib1/lib1.dart&#x27;</span> <span class="keyword">show</span> foo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Import all names EXCEPT foo.</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lib2/lib2.dart&#x27;</span> <span class="keyword">hide</span> foo;</span><br></pre></td></tr></table></figure>

<h3 id="延迟加载库"><a href="#延迟加载库" class="headerlink" title="延迟加载库"></a>延迟加载库</h3><p>下面是一些使用延迟加载库的场景：</p>
<ul>
<li>减少 <code>APP</code> 的启动时间</li>
<li>执行 <code>A/B</code> 测试，例如尝试各种算法的不同实现</li>
<li>加载很少使用的功能，例如可选的屏幕和对话框</li>
</ul>
<p>要延迟加载一个库，需要先使用 <code>deferred as</code> 来导入：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:deferred/hello.dart&#x27;</span> <span class="keyword">deferred</span> <span class="keyword">as</span> hello;</span><br></pre></td></tr></table></figure>

<p>当需要使用的时候，使用库标识符调用 <code>loadLibrary()</code> 方法来加载库：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">greet() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> hello.loadLibrary();</span><br><span class="line">  hello.printGreeting();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在上述代码中，使用 <code>await</code> 关键字暂停代码执行一直到库加载完成。</p>
</blockquote>
<p>在一个库上你可以多次调用 <code>loadLibrary()</code> 函数。 但是该库只是载入一次。使用延迟加载库的时候，需要注意如下问题：</p>
<ul>
<li>延迟加载库的常量在导入的时候是不可用的。 只有当库加载完毕的时候，库中常量才可以使用</li>
<li>在导入文件的时候无法使用延迟库中的类型。 如果你需要使用类型，则考虑把接口类型移动到另外一个库中， 让两个库都分别导入这个接口库</li>
<li><code>Dart</code> 隐式的把 <code>loadLibrary()</code> 方法导入到使用 <code>deferred as</code> 的命名空间中。<code>loadLibrary()</code> 方法返回一个 <code>Future</code> 对象</li>
</ul>
<h2 id="异步支持"><a href="#异步支持" class="headerlink" title="异步支持"></a>异步支持</h2><p><code>Dart</code> 有一些语言特性来支持异步编程。最常见的特性是 <code>async</code> 方法和 <code>await</code> 表达式。</p>
<p><code>Dart</code> 库中有很多返回 <code>Future</code> 或者 <code>Stream</code> 对象的方法。这些方法是异步的：这些函数在设置完基本的操作后就返回了，而无需等待操作执行完成。例如读取一个文件，在打开文件后就返回了。</p>
<p>有两种方式可以使用 <code>Future</code> 对象中的数据：</p>
<ul>
<li>使用 <code>async</code> 和 <code>await</code></li>
<li>使用 <code>Future API</code></li>
</ul>
<p>同样的，从 <code>Stream</code> 中获取数据也有两种方式：</p>
<ul>
<li>使用 <code>async</code> 和一个异步 <code>for</code> 循环 (<code>await for</code>)</li>
<li>使用 <code>Stream API</code></li>
</ul>
<p>使用 <code>async</code> 和 <code>await</code> 的代码是异步的：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> lookUpVersion()</span><br></pre></td></tr></table></figure>


<p>要使用 <code>await</code>，其方法必须带有 <code>async</code> 关键字：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">checkVersion() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> version = <span class="keyword">await</span> lookUpVersion();</span><br><span class="line">  <span class="keyword">if</span> (version == expectedVersion) &#123;</span><br><span class="line">    <span class="comment">// Do something.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Do something else.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>try</code>、<code>catch</code> 和 <code>finally</code> 来处理使用 <code>await</code> 的异常：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  server = <span class="keyword">await</span> HttpServer.bind(InternetAddress.LOOPBACK_IP_V4, <span class="number">4044</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// React to inability to bind to the port...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="声明异步方法"><a href="#声明异步方法" class="headerlink" title="声明异步方法"></a>声明异步方法</h3><p>一个异步方法是方法体被标记为 <code>async</code> 的方法。虽然异步方法的执行可能需要一些时间，但是异步方法在调用之后就立刻返回了————在方法体还没执行之前就返回了：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">checkVersion() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lookUpVersion() <span class="keyword">async</span> =&gt; <span class="comment">/* ... */</span>;</span><br></pre></td></tr></table></figure>

<p>在一个方法上添加 <code>async</code> 关键字，则这个方法返回值为 <code>Future</code>。例如，下面是一个返回字符串的同步方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> lookUpVersionSync() =&gt; <span class="string">&#x27;1.0.0&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果使用 <code>async</code> 关键字，则该方法返回一个 <code>Future</code>，并且认为该函数是一个耗时的操作：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;<span class="built_in">String</span>&gt; lookUpVersion() <span class="keyword">async</span> =&gt; <span class="string">&#x27;1.0.0&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>注意，方法体并不需要使用 <code>Future API</code>。 <code>Dart</code> 会自动在需要的时候创建 <code>Future</code> 对象。</p>
<h3 id="使用-await-表达式"><a href="#使用-await-表达式" class="headerlink" title="使用 await 表达式"></a>使用 await 表达式</h3><p>在<code>Dart</code> 中，<code>await</code> 表达式具有如下的形式：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> expression</span><br></pre></td></tr></table></figure>

<p>在一个异步方法内可以使用多次 <code>await</code> 表达式。例如，下面的示例使用了三次 <code>await</code> 表达式来执行相关的功能：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> entrypoint = <span class="keyword">await</span> findEntrypoint();</span><br><span class="line"><span class="keyword">var</span> exitCode = <span class="keyword">await</span> runExecutable(entrypoint, args);</span><br><span class="line"><span class="keyword">await</span> flushThenExit(exitCode);</span><br></pre></td></tr></table></figure>

<p>在 <code>await expression</code> 中， <code>expression</code> 的返回值通常是一个 <code>Future</code>；如果返回的值不是 <code>Future</code>，则 <code>Dart</code> 会自动把该值放到 <code>Future</code> 中返回。</p>
<p><code>Future</code> 对象代表返回一个对象的 <code>promise</code>。 <code>await expression</code> 执行的结果为这个返回的对象。<code>await expression</code> 会阻塞住，直到需要的对象返回为止。</p>
<h3 id="异步-for-循环"><a href="#异步-for-循环" class="headerlink" title="异步 for 循环"></a>异步 for 循环</h3><p>在 <code>Dart</code> 中，异步 <code>for</code> 循环具有如下的形式：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">for</span> (variable declaration <span class="keyword">in</span> expression) &#123;</span><br><span class="line">  <span class="comment">// Executes each time the stream emits a value.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面 <code>expression</code> 返回的值必须是 <code>Stream</code> 类型的。 执行流程如下：</p>
<ol>
<li>等待直到 <code>Stream</code> 返回一个数据</li>
<li>使用 <code>Stream</code> 返回的参数执行 <code>for</code> 循环代码</li>
<li>重复执行 1 和 2 直到 <code>Stream</code> 数据返回完毕</li>
</ol>
<p>使用 <code>break</code> 或者 <code>return</code> 语句可以停止接收 <code>Stream</code> 的数据，这样就跳出了 <code>for</code> 循环并且从 <code>Stream</code> 上取消注册了。</p>
<p>在 <code>main()</code> 方法中使用异步 for 循环的示例如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">main() <span class="keyword">async</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> request <span class="keyword">in</span> requestServer) &#123;</span><br><span class="line">    handleRequest(request);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果爱 <code>main()</code> 方法中使用了 <code>await</code>，那么 <code>main()</code> 方法也必须使用 <code>async</code>。</p>
</blockquote>
<p>异步编程的更多信息，请参考 <a href="https://www.dartlang.org/guides/libraries/library-tour#dartasync---asynchronous-programming">dart:async</a>。</p>
<h2 id="Callable-classes"><a href="#Callable-classes" class="headerlink" title="Callable classes"></a>Callable classes</h2><p>如果 <code>Dart</code> 类实现了 <code>call()</code> 方法则可以把类当做方法来调用：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WannabeFunction</span> </span>&#123;</span><br><span class="line">  call(<span class="built_in">String</span> a, <span class="built_in">String</span> b, <span class="built_in">String</span> c) =&gt; <span class="string">&#x27;<span class="subst">$a</span> <span class="subst">$b</span> <span class="subst">$c</span>!&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> wf = <span class="keyword">new</span> WannabeFunction();</span><br><span class="line">  <span class="keyword">var</span> out = wf(<span class="string">&quot;Hi&quot;</span>,<span class="string">&quot;there,&quot;</span>,<span class="string">&quot;gang&quot;</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$out</span>&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于更多 <code>Callable classes</code> 的信息，请参考 <a href="https://www.dartlang.org/articles/language/emulating-functions">Emulating Functions in Dart</a>。</p>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>所有的 <code>Dart</code> 代码在协程中运行而不是线程。每个协程都有自己的堆内存，并且确保每个协程的状态都不能被其他协程访问。</p>
<h3 id="Typedefs"><a href="#Typedefs" class="headerlink" title="Typedefs"></a>Typedefs</h3><p>在 <code>Dart</code> 语言中，方法也是对象。使用 <code>typedef</code> 或者 <code>function-type alias</code> 的方式为方法类型命名，然后可以使用命名的方法。当把方法类型赋值给一个变量的时候，<code>typedef</code> 保留类型信息。</p>
<p>下面的代码没有使用 <code>typedef</code>：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortedCollection</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Function</span> compare;</span><br><span class="line"></span><br><span class="line">  SortedCollection(<span class="built_in">int</span> f(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b)) &#123;</span><br><span class="line">    compare = f;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Initial, broken implementation.</span></span><br><span class="line"> <span class="built_in">int</span> sort(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b) =&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  SortedCollection coll = <span class="keyword">new</span> SortedCollection(sort);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 我们只知道 compare 是一个 Function 类型，</span></span><br><span class="line">  <span class="comment">// 但是不知道具体是何种 Function 类型？</span></span><br><span class="line">  <span class="keyword">assert</span>(coll.compare <span class="keyword">is</span> <span class="built_in">Function</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当把 <code>f</code> 赋值给 <code>compare</code> 的时候，类型信息会丢失（<code>f(Object a, Object b)</code> 类型变为 <code>int</code>）。</p>
<p>如果我们 <code>typedef</code>，则可以保留这些信息：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">int</span> Compare(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortedCollection</span> </span>&#123;</span><br><span class="line">  Compare compare;</span><br><span class="line"></span><br><span class="line">  SortedCollection(<span class="keyword">this</span>.compare);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Initial, broken implementation.</span></span><br><span class="line"> <span class="built_in">int</span> sort(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b) =&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  SortedCollection coll = <span class="keyword">new</span> SortedCollection(sort);</span><br><span class="line">  <span class="keyword">assert</span>(coll.compare <span class="keyword">is</span> <span class="built_in">Function</span>);</span><br><span class="line">  <span class="keyword">assert</span>(coll.compare <span class="keyword">is</span> Compare);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>typedef</code> 只是别名，<code>Dart</code> 还提供了一种判断任意 <code>function</code> 的类型的方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">int</span> Compare(<span class="built_in">int</span> a, <span class="built_in">int</span> b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> sort(<span class="built_in">int</span> a, <span class="built_in">int</span> b) =&gt; a - b;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(sort <span class="keyword">is</span> Compare); <span class="comment">// True!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h3><p>我们可以通过使用 <code>Metadata</code>（元数据）为代码添加额外的信息。元数据注解是以 <code>@</code> 开头，后面紧跟一个编译时常量或者调用一个常量构造函数实现的：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown"><span class="emphasis">_Deprecated: Use [turnOn] instead._</span></span></span></span><br><span class="line">  <span class="meta">@deprecated</span></span><br><span class="line">  <span class="keyword">void</span> activate() &#123;</span><br><span class="line">    turnOn();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Turns the TV&#x27;s power on.</span></span></span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;on!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以定义自己的元数据注解。下面的示例定义了一个带有两个参数的 <code>@todo</code> 注解：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">library</span> todo;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">todo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> who;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> what;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> todo(<span class="keyword">this</span>.who, <span class="keyword">this</span>.what);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>@todo</code> 注解的示例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;todo.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@todo</span>(<span class="string">&#x27;seth&#x27;</span>, <span class="string">&#x27;make this do something&#x27;</span>)</span><br><span class="line"><span class="keyword">void</span> doSomething() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;do something&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>元数据可以在 <code>library</code>、<code>class</code>、<code>typedef</code>、<code>type parameter</code>、<code>constructor</code>、<code>factory</code>、<code>function</code>、<code>field</code>、<code>parameter</code> 和 <code>variable</code> 声明之前使用，也可以在 <code>import</code> 或者 <code>export</code> 指令之前使用。使用反射可以在运行时获取元数据信息。</p>
<blockquote>
<p>有三个注解所有的 <code>Dart</code> 代码都可以使用： <code>@deprecated</code>、 <code>@override</code> 和 <code>@proxy</code>。<code> @override</code> 用于表示该方法是复写的父类方法，<code>@proxy</code> 用于表示忽略警告，<code>@deprecated</code> 用以表示该方法或者字段时废弃的。</p>
</blockquote>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>在 <code>Dart</code> 中支持单行、多行以及文档注释。</p>
<p>单行注释以 <code>//</code> 开始。 <code>//</code> 后面的一行内容为 <code>Dart</code> 代码注释。</p>
<p>多行注释以 <code>/*</code> 开始， <code>*/</code> 结尾。 多行注释可以嵌套。</p>
<p>文档注释可以使用 <code>///</code> 开始， 也可以使用 <code>/**</code> 开始 并以 <code>*/</code> 结束。</p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Dart 语法预览</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 设计模式概述</title>
    <url>/index.html//2020/android-source-design-pattern-index.html</url>
    <content><![CDATA[<p>如何提高软件系统的可维护性和可复用性是面向对象程序设计思想需要解决的核心问题。在面向对象程序设计中，可维护性的复用是以设计原则为基础的。每一个设计原则都蕴含着面向对象程序设计的思想，可以从不同的角度提升一个软件系统的架构水平。</p>
<p>面向对象程序设计原则是为支撑可维护性的复用而诞生的，它们是从很多的设计方案中总结出来的指导性原则，通常体现在设计模式中。</p>
<span id="more"></span>

<h2 id="面向对象程序设计原则"><a href="#面向对象程序设计原则" class="headerlink" title="面向对象程序设计原则"></a>面向对象程序设计原则</h2><p>最常见的面向对象程序设计原则有如下七条：</p>
<ul>
<li>单一职责原则，规定一个类只负责一个功能</li>
<li>开闭原则，规定软件实体应该对扩展开放，而对修改关闭</li>
<li>里氏替换原则，规定所有引用基类对象的地方应该能够透明的使用其子类对象</li>
<li>依赖倒置原则，规定抽象不应该依赖于细节，而细节应该依赖于抽象</li>
<li>接口隔离原则，规定使用多个专门的接口而不是使用单一的总接口</li>
<li>合成复用原则，规定应尽量使用对象组合而不是继承来达到复用的目的</li>
<li>迪米特法则，规定一个软件实体应该尽可能少地与其他实体发生相互作用</li>
</ul>
<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p><code>单一职责原则</code>的定义是：应该有且只有一个引起类变化的原因。</p>
<p>遵循<code>单一职责原则</code>会带来一定的收益：</p>
<ul>
<li>类的复杂度降低</li>
<li>类的内聚性提升，并在一定程度上提升了系统的可维护性</li>
<li>变更带来的风险降低</li>
</ul>
<p><code>单一职责原则</code>是实现高内聚、低耦合的指导性方针。<code>单一职责原则</code>从职责的层面将不同的职责封装在不同的类中，以此来控制类的粒度，以达到高耦合、低内聚的设计目标。</p>
<p><code>单一职责原则</code>要求开发人员从职责的角度发现类的不同职责并将其分离，从另一个角度来说，由于类的职责是一个无法量化的概念，在一定程度上需要依赖开发人员较强的分析能力和设计经验，可能在一定程度上会增加系统的复杂性。</p>
<p><code>单一职责原则</code>的目的是约束类的职责，在一定范围内尽可能保证有且只有一个引起类变化的原因。从代码设计的角度来说，<code>单一职责原则</code>不仅适用于类的设计，也适用于方法的设计。在大的职责尺度上，同样也适用于软件系统中模块的设计。</p>
<p><code>单一职责原则</code>需要在大量的业务迭代实践中进行探索。从代码设计的角度来说，很难在第一时间设计出符合<code>单一职责原则</code>的类（当然，方法的设计和实现还是相对容易符合该原则的），这需要前期对需求的极致细化和后期根据业需求进行重构。</p>
<p><code>Java</code> 语言中 <code>interface</code> 的概念可以在一定意义上帮助我们设计出符合<code>单一职责原则</code>的类。每一个不同的职责都对应一个广泛意义上的<code>interface</code>，多个细粒度的职责（也就是多个 <code>interface</code>）组合成了更大粒度上的新的职责。</p>
<p>由于<code>职责</code>概念的模糊化，我们很难说 <code>Android</code> 源代码中某一个类的设计是完全符合<code>单一职责原则</code>的。<code>Activity</code> 就只负责所有与用户交互的业务，<code>Application</code> 只负责应用程序全局的业务，从一定程度上来说，是符合<code>单一职责原则</code>的。</p>
<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p><code>开闭原则</code>是面向对象的可复用设计的第一块基石，是 <code>Java</code> 语言里面最为重要的设计原则。<code>开闭原则</code>规定，一个软件实体（如类、模块和方法）应该对扩展开放，而对修改关闭。也就是说，一个软件实体应该通过扩展来实现变化而不是通过修改已有的代码。</p>
<p><code>Java</code> 语言的 <code>抽象</code> 特性是<code>开闭原则</code>的关键。在实际的开发工程中，可以为应用程序架构定义一个相对稳定的抽象层，而将不同的实现迁移到具体的实现层中完成。<code>Java</code> 语言提供了 <code>抽象类</code> 和 <code>interface</code> 等强大的抽象工具用来实现上述目的。</p>
<p>从一定的角度来说，<code>Android</code> 系统本身就是一种符合<code>开闭原则</code>的软件实体。相较于功能机，<code>Android</code> 系统允许我们通过安装应用程序来扩展系统功能，而 <code>Android Framework</code> 层就是上述所提到的抽象层。更进一步的说，每一个应用程序可以通过添加 <code>Activity</code>、<code>Service</code> 和 <code>BroadcastReceiver</code> 等组件实现不同的需求，而不是通过修改系统中已经存在的 <code>Activity</code>、<code>Service</code> 和 <code>BroadcastReceiver</code> 等组件。</p>
<p><code>开闭原则</code>在应用程序设计方面的体现是，使用抽象（抽象类和 <code>interface</code>）构建应用程序架构，使用具体实现扩展应用程序细节。</p>
<p>从 <code>Android</code> 应用程序架构的角度来说，业务需求在架构上的体现应该是稳定的，每个模块架构在代码上的描述是基于抽象类或 <code>interface</code> 的。这种基于抽象约束的方法主要体现在如下三个方面：</p>
<ol>
<li>通过抽象类和 <code>interface</code> 约束扩展，对扩展进行边界的限定，不允许出现在抽象类和 <code>interface</code>中不存在的公共方法；</li>
<li>参数类型和饮用对象尽量使用抽象类或 <code>interface</code>，而不是使用实现类</li>
<li>保持抽象层的业务稳定</li>
</ol>
<p>从 <code>Android</code> 应用程序具体实现的角度来说，对变化进行封装也是<code>开闭原则</code>的具体体现。这种封装变化的方法主要体现在如下两个方面：</p>
<ol>
<li>将相同的变化抽象到同一个抽象类或 <code>interface</code> 中</li>
<li>将不同的变化封装到不同的抽象类和 <code>interface</code> 中，不应该有两个不同的变化出现在同一个抽象类和 <code>interface</code> 中</li>
</ol>
<p>从项目管理的角度来说，建立项目开发规范，指定所有项目参与人员都必须遵守的约定也是较为不错的实践。就项目来说，约定由于配置。<br><code>Android</code> 系统中，基于<code>开闭原则</code>设计的类随处可见。拿最为常见的集合对象来说，<code>List</code> 通过其接口定义了对外提供服务的接口，并额外提供了 <code>ArrayList</code> 和 <code>LinkedList</code> 的具体实现。在实际的使用过程中，我们可以根据需要选择具体的实现，也可以通过派生 <code>List</code> 的方式自己实现满足我们需求的子类。这个过程中，我们是通过 <code>List</code> 派生新的子类以满足我们的需求的，而不是修改已有的子类实现（例如给 <code>ArrayList</code> 增加线程安全机制）。</p>
<p>在 <code>Android</code> 的 <code>View</code> 体系中，<code>Button</code> 和 <code>CheckBox</code> 等控件都是派生自 <code>TextView</code>。如果想修改 <code>TextView</code> 显示文本的样式，只要选择合适的 <code>TextView</code> 子类实现或者重写 <code>TextView</code> 样式相关的方法即可。<code>View</code> 体系在渲染时并不关心你所使用的 <code>TextView</code> 子类，它只是关心你的实现是否符合 <code>TextView</code> 的约束。这也就意味着，<code>Android</code> 的 <code>View</code> 体系也是符合<code>开闭原则</code>的。</p>
<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p><code>继承</code>是面向对象程序设计语言的重要特性，合理的使用<code>继承</code>可以带来如下收益：</p>
<ul>
<li>代码共享，降低创建类的工作量</li>
<li>提高代码和业务的可复用性</li>
<li>提高代码的可扩展性</li>
</ul>
<p>但是由于<code>继承</code>是一种侵入性的特性，只要是通过继承得到的子类，就必须拥有父类所有的方法和属性。这在一定程度上降低了代码的灵活性并增强了类之间（子类和父类）的耦合性。设想一下，如果由于某些原因，父类对其中的方法或属性进行了修改，这对其派生出来的子类来说，可能会非常糟糕——大量的代码需要调整。</p>
<p><code>里氏替换原则</code>为继续定义了一个规范。<code>里氏替换原则</code>规定，所有使用父类的地方必须能够透明的使用其子类对象：</p>
<ul>
<li>子类必须完全实现父类的方法</li>
<li>子类可以拥有自己的属性和方法</li>
<li>覆盖或实现父类方法时，输入的参数（参数列表）可以被放大</li>
<li>覆盖或实现父类的方法时，输出的结果（返回值）可以被缩小</li>
<li>覆盖或实现父类的方法时，其访问控制权限可以被方法</li>
</ul>
<p><code>里氏替换原则</code>是实现<code>开闭原则</code>的重要方法之一。由于使用父类的地方都可以使用子类对象，因此在代码设计中应尽量使用父类型来定义对象，而在应用程序运行时再确定其子类型。这也是 <code>Java</code> 语言中<code>多态</code>特性的重要体现。</p>
<p><code>里氏替换原则</code>是我们在使用 <code>Java</code> 语言的<code>继承</code>特性时最为重要的行为准则。幸运的是，在代码的编译阶段，<code>Java</code> 编译器会帮助我们检查一个子类是否符合<code>里氏替换原则</code>。</p>
<p>在 <code>Android</code> 应用程序开发过程中，我们无时无刻不在使用<code>里氏替换原则</code>带来的便利：</p>
<ul>
<li>在实现 <code>Activity</code> 时，我们可以通过 <code>extends</code> 关键字从 <code>Activity</code> 派生我们自己的 <code>MyActivity</code>，重写必要的方法并未 <code>MyActivity</code> 添加额外的方法，<code>Android</code> 系统依旧可以正确加载 <code>Activity</code></li>
<li>所有使用 <code>Context</code> 参数的地方，我们都可以使用 <code>MyActivity</code> 进行替代</li>
<li>使用集合 <code>List</code> 的对象时，我们可以选择实例化 <code>ArrayList</code> 也可以选择 <code>LinkedList</code>，这对具体的业务来说并没有任何影响（单纯从接口的角度来说，不考虑线程安全的问题）</li>
</ul>
<p><code>Android</code> 源代码中这样的示例数不胜数。在实际的开发过程中，我们应该尽可能的避免子类拥有额外的<code>职责</code>（也就是向子类中添加额外的公共方法，违反<code>里氏替换原则</code>），一方面这会破坏类设计的<code>单一职责原则</code>，另一方面会由于子类添加的额外的公共方法而使得我们不得不使用子类对象取代原来的父类对象对外界提供服务，一定程度上提升了维护的难度。</p>
<p><code>里氏替换原则</code>的深层次目的则是要求我们在代码设计时，应尽可能的使用父类对象对外提供服务或与外界产生耦合。这与<code>依赖倒置原则</code>有着相同的目的。</p>
<h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><p>如果说<code>开闭原则</code>是面向对象程序设计的目标的话，那么<code>依赖倒置原则</code>就是面向对象程序设计的主要实现机制。<code>依赖倒置原则</code>规定，抽象不应该依赖于细节，而细节应该依赖于抽象。该原则指定了一种特定的的解耦形式，使得高层级的模块不依赖于低层级的模块的具体实现细节。<code>依赖倒置原则</code>有如下几个关键点：</p>
<ol>
<li>高层级的模块不应该依赖低层级的模块，两者都应该依赖于其自身的抽象</li>
<li>抽象不应该依赖于细节</li>
<li>细节应该依赖于抽象</li>
</ol>
<p><code>依赖倒置原则</code>在 <code>Java</code> 语言中的具体表现就是：模块间的依赖通过抽象产生，子类之间不产生直接的依赖关系，其依赖关系是通过抽象类和 <code>interface</code> 产生的。<code>依赖倒置原则</code>的核心思想是面向抽象编程而不是面向具体实现编程。这也就要求我们在代码设计时，应该尽量使用高层级的抽象。也就是说，使用抽象类和 <code>interface</code> 进行变量类型、参数类型和返回值类型的声明，而不是使用具体的实现。</p>
<p>在实现<code>依赖倒置原则</code>时，我们需要针对抽象层进行编程，而将具体的实现细节的对象通过<code>依赖注入</code>的方式注入到其他对象中。</p>
<blockquote>
<p><code>依赖注入</code>是指当一个对象要与其他对象产生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种：</p>
<ol>
<li>构造注入：通过构造函数来传入具体子类的对象</li>
<li>设值注入（<code>setter 注入</code>）：通过 <code>setter</code> 方法传入具体子类的对象</li>
<li>接口注入：在j</li>
</ol>
</blockquote>
<p><code>依赖倒置原则</code>解决的是类与类之间的耦合关系。如果类与类之间的通信直接依赖于具体的细节，那么它们之间就有着强耦合关系。当具体的实现细节出现变化时，也就意味着需要同时修改这些依赖具体细节的类。这在一定程度上降低了代码的可维护性。</p>
<p><code>依赖倒置原则</code>的本质就是通过抽象使得各个类之间彼此独立，不互相影响。从代码的角度来说，实现<code>依赖倒置原则</code>应该符合如下规范：</p>
<ol>
<li>每个类都尽量有其抽象类或 <code>interface</code></li>
<li>变量的声明类型尽量使用抽象</li>
<li>任何类应该都是派生于抽象类</li>
<li>子类尽量不要覆盖父类的方法</li>
<li>结合<code>里氏替换原则</code>使用</li>
</ol>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p><code>Java</code> 语言中，接口有两种表现形式：</p>
<ul>
<li>实例接口：通过 <code>new</code> 创建的类的实例，它是对一种事物类型的描述</li>
<li>类接口：使用 <code>interface</code> 关键字声明的类</li>
</ul>
<p><code>接口隔离原则</code>规定类之间的依赖关系应该建立在最小的接口上。也就是说，当一个接口太大时，我们需要将其分割为更小的接口，使用该接口的对象只需要知道与之相关的方法即可。这也就要求我们在设计接口时，应该尽可能的细化接口，并且保证接口中的方法尽量的少。</p>
<blockquote>
<p><code>接口隔离原则</code>与<code>单一职责原则</code>在概念上较为详尽，但是其本质的区别在于，前者规范的是接口内方法的数量，而后者则是强调接口的职责单一。</p>
</blockquote>
<p>与<code>里氏替换原则</code>规范的是<code>继承</code>的行为一样，<code>接口隔离原则</code>是对接口进行规范：</p>
<ol>
<li>接口应该尽可能的小</li>
<li>接口要高内聚</li>
<li>只提供访问者需要的方法</li>
</ol>
<p>与<code>单一职责原则</code>中<code>职责</code>的概念无法量化一样，接口的粒度大小问题也是一个无法量化的概念。接口的粒度越小，代码越灵活，但也在一定程度上增加了代码的复杂性，增加了维护的成本。</p>
<p>在软件开发过程中，确保一个接口只服务于一个模块，同时根据业务需求不断地压缩接口中的公共方法，细化为更细粒度的接口，是<code>接口隔离原则</code>的不错的实践。</p>
<h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p><code>合成复用原则</code>规定，我们在产生新的类的时候，应尽可能使用组合而不是继承的方式。在面向对象程序设计中，可以通过如下两种方式在不同的环境中复用已有的的设计和实现：</p>
<ol>
<li>通过组合（聚合）的方式：该方式强调使用已有对象的实例组合成新的对象，已有对象与新对象之间不存在继承关系</li>
<li>通过继承的方式：该方式强调通过使用继承的方式产生新的对象，已有对象与新对象之间存在继承关系</li>
</ol>
<p>使用组合的方式产生新的对象，可以将已经存在的对象包含到新的对象中，使之成为新对象中的一部分。这种方式可以保证新的对象可以使用已有对象的功能而无需暴露已有对象的实现细节。相对于继承的方式来说，这种方式耦合性相对较低，已有对象的变化对新对象的影响不会很大。</p>
<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p><code>迪米特法则</code>也称之为<code>最少知识原则</code>。该原则规定，一个对象应该对其他对象有最少的了解。也就是说，一个类应该对自己需要耦合或调用的类知道的越少越好。</p>
<p><code>迪米特法则</code>的核心是解决类与类之间的耦合问题，并以此来限制类与类之间通信的宽度和深度。如果一个软件系统符合<code>迪米特法则</code>，那么当其中的某一个模块发生改变时，对其他模块的影响将会变得非常小。该原则要求我们，应该尽量避免对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不应该发生任何的直接的相互作用。而如果两个对象之间必须产生某些调用行为的话，可以通过第三者对象转发这个调用。</p>
<p>上述方式体在代码开发过程中的体现就是：</p>
<ul>
<li>在类的划分上，应该尽可能创建松耦合的二类</li>
<li>在类的设计上，每一个类都应该尽可能降低其他成员变量好成员方法的访问权限，如果可能的话，一个类应该设计为不变类（使用 <code>final</code> 修饰）</li>
<li>在对其他类的引用上，一个对象对其他对象的引用应当降到最低</li>
</ul>
<h2 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h2><p>创建型设计模式对类的实例化过程进行了抽象，能够将软件系统中对象的创建和对象的使用过程分离。为了使软件系统的结构更加清晰，调用者对于这些对象只需要关心它们共同的接口，而不关心其具体的实现细节，使整个系统的设计更加符合单一职责原则。</p>
<p>创建型设计模式在创建什么(<code>What</code>)，由谁创建(<code>Who</code>)，何时创建(<code>When</code>)等方面都为软件设计者提供了尽可能大的灵活性。创建型设计模式隐藏了类实例的创建细节，通过隐藏对象如何被创建的方式达到使得整个系统相对独立的目的。</p>
<p>创建型设计模式包含如下六种设计模式：</p>
<ol>
<li>简单工厂模式：定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类</li>
<li>工厂方法模式：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行</li>
<li>抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类</li>
<li>单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点</li>
<li>建造者模式：杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示</li>
<li>原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象</li>
</ol>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p><em><strong>意图：</strong></em> 定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类<br><em><strong>解决的问题：</strong></em> 解决产品对象选择的问题<br><em><strong>使用时机：</strong></em> 有明确的计划在不同条件下创建不同的产品对象实例时<br><em><strong>角色：</strong></em> 在<code>简单工厂模式</code>中包含如下几个角色：</p>
<ul>
<li>工厂角色（<code>Factory</code>）：工厂角色也就是工厂类，它是<code>简单工厂模式</code>的核心，负责创建所有的产品实例的内部逻辑。工厂类可以被客户端直接调用用来创建所需的产品实例</li>
<li>抽象产品角色（<code>Product</code>）：抽象产品角色是工厂角色所创建的所有产品的抽象父类，它封装了各个产品实例的公共方法</li>
<li>具体产品角色（<code>ConcreteProduct</code>）：具体产品角色是<code>简单工厂模式</code>的创建目标。每一个具体产品角色都是由抽象产品角色派生的，所有被创建的产品实例都属于该角色</li>
</ul>
<p><code>简单工厂模式</code>(<code>Simple Factory Pattern</code>)：又称为<code>静态工厂方法</code>(<code>Static Factory Method</code>)模式，它属于类创建型模式。在<code>简单工厂模式</code>中，可以根据输入参数的不同返回不同产品角色的实例。<code>简单工厂模式</code>专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。<code>简单工厂模式</code>中各个角色的代码实现如下：</p>
<p>工厂角色（<code>Factory</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">createProduct</span><span class="params">(String productName)</span> </span>&#123;</span><br><span class="line">        Product product = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (productName.equals(<span class="string">&quot;ProductA&quot;</span>)) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> ConcreteProductA();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (productName.equals(<span class="string">&quot;ProductB&quot;</span>)) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> ConcreteProductB();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象产品角色（<code>Product</code>）的代码的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体产品角色（<code>ConcreteProduct</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductA</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductB</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>调用者的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Product product = Factory.createProduct(<span class="string">&quot;ProductA&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>简单工厂模式</code>的主要优点如下：</p>
<ol>
<li>工厂角色包含必要的判断逻辑，可以决定在什么条件下创建哪一个产品对象的实例，客户端可以免除直接创建产品对象的职责，而仅仅使用产品对象，实现了对象创建和使用的分离</li>
<li>客户端无须知道所创建的具体产品对象的类名，只需要知道具体产品对象所对应的参数即可，对于一些复杂的产品名称，通过<code>简单工厂模式</code>可以在一定程度减少使用者的记忆量</li>
<li>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品角色，在一定程度上提高了系统的灵活性。</li>
</ol>
<p><code>简单工厂模式</code>的主要缺点如下：</p>
<ol>
<li>由于工厂角色集中了所有产品的创建逻辑，职责过重，违背<code>单一职责原则</code>的规范</li>
<li>使用<code>简单工厂模式</code>会增加系统中类的个数（引入了新的工厂角色），增加了系统的复杂度和理解难度</li>
<li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护</li>
<li><code>简单工厂模式</code>由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</li>
</ol>
<p><code>简单工厂模式</code>的使用场景：</p>
<ol>
<li>工厂角色负责创建的对象比较少，不会造成工厂方法中的业务逻辑太过复杂</li>
<li>客户端只需要知道传入工厂角色的参数，对于如何创建对象并不关心</li>
</ol>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p><em><strong>意图：</strong></em> 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行<br><em><strong>解决的问题：</strong></em> 解决产品对象选择的问题<br><em><strong>使用时机：</strong></em> 有明确的计划在不同条件下创建不同的产品对象实例时<br><em><strong>角色：</strong></em> 在<code>工厂方法模式</code>中包含如下几个角色：</p>
<ul>
<li>抽象工厂角色（<code>Factory</code>）：在抽象工厂中，声明了工厂方法用于返回产品对象</li>
<li>具体工厂角色（<code>ConcreteFactory</code>）：它是抽象工厂的子类，实现了抽象工厂中定义的的工厂方法，由客户端调用之后返回具体的产品对象</li>
<li>抽象产品角色（<code>Product</code>）：它是定义产品角色的接口，是工厂方法中所创建的产品的父类</li>
<li>具体产品角色（<code>ConcreteProduct</code>）：它实现了抽象产品的接口，是产品对象的具体实现。每一种类型的产品都由专门的具体工厂负责创建</li>
</ul>
<p><code>工厂方法模式</code>(<code>Factory Method Pattern</code>)又称为<code>工厂模式</code>，它属于类创建型模式。在<code>工厂方法模式</code>中，抽象工厂角色负责定义创建产品对象的公共接口，而具体工厂角色则负责生产具体的产品角色对象，这样做的目的是将产品对象的实例化过程延迟到具体工厂角色中完成，即通过具体工厂角色来确定究竟应该实例化哪一个具体产品角色。<code>工厂方法模式</code>中各个角色的代码实现如下：</p>
<p>抽象产品角色（<code>Product</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体产品角色（<code>ConcreteProduct</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductA</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductB</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象工厂角色（<code>Factory</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Product <span class="title">createProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体工厂角色（<code>ConcreteFactory</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactoryA</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactoryB</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用者的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Factory factoryA = <span class="keyword">new</span> ConcreteFactoryA();</span><br><span class="line">Product productA = factoryA.createProduct();</span><br><span class="line"></span><br><span class="line">Factory factoryB = <span class="keyword">new</span> ConcreteFactoryB();</span><br><span class="line">Product productB = factoryB.createProduct();</span><br></pre></td></tr></table></figure>

<p>当软件系统中引入新的产品时，<code>简单工厂模式</code>由于需要通过所传入的参数来创建不同的产品对象，这会要求我们对已有的工厂角色进行修改，在一定程度上违背了<code>开闭原则</code>的规范。而且，由于<code>简单工厂模式</code>中只存在一个工厂角色，该工厂角色位于产品对象创建的最核心位置，它需要知道每一个产品对象的创建细节，并根据条件决定创建哪一个产品对象，在一定程度上造成了工厂角色的职责过于繁重，而且产品对象与工厂角色之间高度耦合，影响了软件系统的灵活性和可扩展性。</p>
<p><code>工厂方法模式</code>弥补了<code>简单工厂模式</code>在上述方面的不足。与<code>简单工厂模式</code>不同的是，在<code>工厂方法模式</code>中不再提供一个统一的工厂角色用于创建所有的产品对象，取而代之的是针对不同的产品提供不同的工厂角色。</p>
<p><code>工厂方法模式</code>的主要优点如下：</p>
<ol>
<li>在<code>工厂方法模式</code>中，工厂方法用来创建客户端所需要的产品对象，同时还向客户端隐藏了哪种具体产品角色将被实例化这一细节，客户端只需要关心所需产品对象对应的工厂，而无须关心创建细节，甚至无须知道具体产品对象的类名；</li>
<li>基于工厂角色和产品角色的多态性设计是<code>工厂方法模式的关键</code>。它能够让工厂角色可以自主确定创建何种产品对象，且创建对象的细节完全封装在具体工厂内部；</li>
<li>使用<code>工厂方法模式</code>的另一个优点是在系统中加入新产品角色时，无须修改抽象工厂角色和抽象产品角色提供的接口，无须修改客户端，也无须修改其他的具体工厂角色和具体产品角色，而只要添加一个具体工厂角色和具体产品角色就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li>
</ol>
<p><code>工厂方法模式</code>的主要缺点如下：</p>
<ol>
<li>在添加新产品时，需要编写新的具体产品角色类，而且还要提供与之对应的具体工厂角色类，造成系统中类的个数将成对的增加，在一定程度上增加了系统的复杂度；</li>
<li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度。</li>
</ol>
<p><code>工厂方法模式</code>的使用场景如下：</p>
<ol>
<li>客户端不需要知道它所需要的对象的类。在<code>工厂方法模式</code>中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；</li>
<li>抽象工厂角色通过其子类（具体工厂角色）来指定创建哪个产品对象。在<code>工厂方法模式</code>中，对于抽象工厂角色只需要提供一个创建产品对象的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和<code>里氏代换原则</code>，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li>
</ol>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p><em><strong>意图：</strong></em> 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类<br><em><strong>解决的问题：</strong></em> 主要解决接口选择的问题<br><em><strong>使用时机：</strong></em> 系统的产品有多于一个的产品族，而系统只消费其中某一族的产品<br><em><strong>角色：</strong></em> 在<code>抽象工厂模式</code>中包含如下几个角色：</p>
<ul>
<li>抽象工厂（<code>Abstract Factory</code>）：它声明了一组用于创建一族的产品的方法，每一个方法对应一种产品</li>
<li>具体工厂（<code>Concrete Factory</code>）：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中</li>
<li>具体产品（<code>Concrete Product</code>）：它定义了具体工厂生成的具体产品对象，实现了抽象产品接口中的公共方法</li>
<li>抽象产品（<code>Abstract Product</code>）：它为每种产品声明接口，在抽象产品中声明了产品所具有的公共方法</li>
</ul>
<p><code>抽象工厂模式</code>(<code>Abstract Factory Pattern</code>)提供了一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。在<code>抽象工厂模式</code>中，每一个具体工厂都提供了多个工厂方法用于创建多种不同类型的产品。这些产品构成了<code>抽象产品族</code>。<code>抽象工厂模式</code>中各个角色的代码实现如下：</p>
<blockquote>
<p><code>抽象产品族</code>是由同一个<code>工厂角色</code>生产的，位于不同<code>产品等级结构</code>中的一组产品。<code>产品等级结构</code>指的是产品的继承结构。</p>
</blockquote>
<p>抽象工厂（<code>Abstract Factory</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> AbstractProductA <span class="title">createAbstractProductA</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> AbstractProductB <span class="title">createAbstractProductB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体工厂（<code>Concrete Factory</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AbstractProductA <span class="title">createAbstractProductA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteAbstractProductA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AbstractProductB <span class="title">createAbstractProductB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteAbstractProductB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象产品（<code>Abstract Product</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractProductA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体产品（<code>Concrete Product</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductB</span> <span class="keyword">implements</span> <span class="title">AbstractProductB</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>抽象工厂模式</code>的主要优点如下：</p>
<ol>
<li><code>抽象工厂模式</code>隔离了具体类的生成，使得客户端并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为</li>
<li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象</li>
<li>增加新的产品族很方便，无须修改已有系统，符合<code>开闭原则</code>的规范</li>
</ol>
<p><code>抽象工厂模式</code>的主要缺点如下：</p>
<p>增加新的产品等级结构比较麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了<code>开闭原则</code>的规范。</p>
<p><code>抽象工厂模式</code>的使用场景：</p>
<ol>
<li>一个系统不依赖于产品类实例如何被创建、组合和表达的细节，用户无须关心对象的创建过程，将对象的创建和使用解耦</li>
<li>系统中有多于一个的产品族，而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族</li>
<li>属于同一个产品族的产品在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束，如同一操作系统下的按钮和文本框，按钮与文本框之间没有直接关系，但它们都是属于某一操作系统的，此时具有一个共同的约束条件：操作系统的类型</li>
<li>产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构</li>
</ol>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p><em><strong>意图：</strong></em> 保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br><em><strong>解决的问题：</strong></em> 一个全局使用的类频繁地创建与销毁。<br><em><strong>使用时机：</strong></em> 当您想控制实例数目，节省系统资源的时候。<br><em><strong>角色：</strong></em> 在<code>单例模式</code>中包含如下角色：</p>
<ul>
<li>单例对象（<code>Singleton</code>）：<code>单例模式</code>中唯一的角色，负责单例对象的创建，并提供全局的接口对外提供该对象</li>
</ul>
<p><code>单例模式</code>(<code>Singleton Pattern</code>)确保系统中某一个类有且只有一个实例，且能够自行实例化并向整个系统提供这个实例。<code>单例模式</code>中各个角色的代码实现如下：</p>
<p><code>单例模式</code>有多种实现方式。如果只是在单线程环境下使用，那么可以考虑使用如下实现方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == INSTANCE) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述方式是<code>单例模式</code>最基本的实现。由于没有考虑线程同步的问题，所以只能在单线程环境下使用。单例类可以在 <code>getInstance()</code> 被调用时得到初始化。如果需要在多线程环境下使用<code>单例模式</code>，就需要考虑线程同步的问题，而且由于多线程环境下对象初始化的时机问题，我们使用<code>双重校验锁</code>的方式实现<code>单例模式</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == INSTANCE) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == INSTANCE) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述方式在保证多线程下对象同步的同时，通过使用<code>双重校验锁</code>的机制保证了多线程环境下对象初始化时机的问题。使用静态内部类的方式也可以达到同样的目的，而且实现难度和效率更为高效：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonClassHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonClassHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>单例模式</code>提供了一种对唯一对象实例的受控访问，可以严格控制调用者对该实例的访问。而对于那些资源开销开销较大的资源来说，确保系统中只有一个对象实例对外提供服务，可以在一定程度上节省系统资源。但是，在单例模式中，由于单例类既要充当<code>工厂角色</code>提供工厂方法，又要充当<code>产品角色</code>提供产品业务，在一定程度上违背了<code>单一职责原则</code>。对于 <code>Java</code> 语言来说，由于<code>垃圾回收机制</code>的存在，如果单例对象长时间不活跃，那么会存在被<code>垃圾回收器</code>回收的风险。当再次使用对象时会被重新初始化，从而造成对象数据的丢失。</p>
<p><code>单例模式</code>的主要优点如下：</p>
<ol>
<li><code>单例模式</code>提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户端怎样以及何时访问它</li>
<li>由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，<code>单例模式</code>无疑可以提高系统的性能</li>
<li>允许可变数目的实例。基于<code>单例模式</code>我们可以进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例，既节省系统资源，又解决了单例对象共享过多有损性能的问题</li>
</ol>
<p><code>单例模式</code>的主要缺点如下：</p>
<ol>
<li>由于<code>单例模式</code>中没有抽象层，因此单例类的扩展有很大的困难</li>
<li>单例类的职责过重，在一定程度上违背了<code>单一职责原则</code>。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到了一起</li>
<li><code>Java</code> 语言的运行时环境提供了自动垃圾回收的技术，因此，如果实例化的共享对象长时间不被利用，系统会认为它是垃圾对象，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致共享的单例对象状态的丢失</li>
</ol>
<p><code>单例模式</code>的使用场景：</p>
<ol>
<li>系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象</li>
<li>客户端调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例</li>
</ol>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p><em><strong>意图：</strong></em> 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象<br><em><strong>解决的问题：</strong></em> 在运行期建立和删除原型<br><em><strong>角色：</strong></em> <code>原型模式</code>中有如下几个角色：</p>
<ul>
<li>抽象原型角色（<code>Protocol Type</code>）：它是声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类也可以是接口，甚至还可以是具体实现类</li>
<li>具体原型角色（<code>Concrete Protocol Type</code>）：它实现了抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象</li>
<li>客户类（<code>Client</code>）：让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象</li>
</ul>
<p><code>原型模式</code>（<code>Prototype Pattern</code>）用于创建重复的对象，同时又能保证性能，它提供了一种创建对象的最佳方式。<code>原型模式</code>实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。<code>原型模式</code>中各个角色的代码实现如下：</p>
<p>抽象原型角色（<code>Protocol Type</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolType</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ProtocolType <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ProtocolType protocolType = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            protocolType = (ProtocolType) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            protocolType = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> protocolType;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体原型角色（<code>Concrete Protocol Type</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProtocolType</span> <span class="keyword">extends</span> <span class="title">ProtocolType</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用者的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProtocolType concreteProtocolType = <span class="keyword">new</span> ConcreteProtocolType();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            ProtocolType protocolType = concreteProtocolType.clone();</span><br><span class="line">            protocolType.doSomething();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>java</code> 语言中，数据类型分为<code>值类型</code>（基本数据类型）和<code>引用类型</code>。<code>Java</code> 中的对象克隆分为如下两种形式：</p>
<ul>
<li>浅克隆：在<code>浅克隆</code>中，如果原型对象的成员变量是<code>值类型</code>，将复制一份给克隆对象。如果原型对象的成员变量是<code>引用类型</code>，则将引用对象的地址复制一份给克隆对象（即：原型对象和克隆对象的成员变量指向相同的内存地址）。换句话说，在<code>浅克隆</code>中，当对象被复制时只复制它本身和其中包含的<code>值类型</code>的成员变量，而引用类型的成员变量并没有复制；</li>
<li>深克隆：在<code>深克隆</code>中，无论原型对象的成员变量是<code>值类型</code>还是<code>引用类型</code>，都将复制一份给克隆对象。<code>深克隆</code>将原型对象的所有引用对象也复制一份给克隆对象（即：在<code>深克隆</code>中，对了对象本身被克隆意外，对象所包含的所有成员变量也会被克隆）。</li>
</ul>
<p><code>原型模式</code>的主要优点如下：</p>
<ol>
<li>当需要创建的新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率</li>
<li>扩展性较好，由于在<code>原型模式</code>中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响</li>
<li><code>原型模式</code>提供了简化的创建结构，<code>工厂方法模式</code>常常需要有一个与产品类等级结构相同的工厂等级结构，而<code>原型模式</code>就不需要这样，<code>原型模式</code>中产品的克隆是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品</li>
<li>可以使用深克隆的方式保存对象的状态，使用原型模式将对象克隆一份并将其状态保存起来，以便在需要的时候使用（如恢复到某一历史状态），可辅助实现撤销操作</li>
</ol>
<p><code>原型模式</code>的主要缺点如下：</p>
<ol>
<li>需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了<code>开闭原则</code></li>
<li>在实现<code>深克隆</code>时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现<code>深克隆</code>，每一层对象对应的类都必须支持<code>深克隆</code>，实现起来可能会比较麻烦</li>
</ol>
<p><code>原型模式</code>的使用场景</p>
<ol>
<li>创建新对象成本较大（如初始化需要占用较长的时间，占用太多的 <code>CPU</code> 资源或网络资源），新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改</li>
<li>如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用<code>原型模式</code>配合<code>备忘录模式</code>来实现</li>
<li>需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新的实例可能比使用构造函数创建一个新实例更加方便</li>
</ol>
<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p><em><strong>意图：</strong></em> 将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示<br><em><strong>解决的问题：</strong></em> 主要解决在软件系统中，有时候面临着<code>一个复杂对象</code>的创建工作，其通常由各个部分的子对象用一定的业务构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的业务却相对稳定<br><em><strong>角色：</strong></em> <code>建造者模式</code>中有如下角色：</p>
<ul>
<li>抽象建造者（<code>Builder</code>）：他为创建一个产品角色的各个组成部分指定抽象接口，在该接口中一般声明两类方法：<ul>
<li>用于构建各个组成部分的方法，一般使用 <code>buildXXX()</code></li>
<li>用于返回构建结果的方法，一般使用 <code>getProduct()</code></li>
</ul>
</li>
<li>产品角色（<code>Product</code>）：它是被构建的复杂对象，包含多个组成部分，具体建造者创建该产品的内部表示并定义它的装配过程</li>
<li>具体建造者（<code>ConcreteBuilder</code>）：它实现了 <code>Builder</code> 的接口，实现各个组成部分的具体构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法用于返回创建好的复杂对象</li>
<li>指挥者（<code>Director</code>）：指挥者又称导演类，它负责安排复杂对象的建造顺序，指挥者与抽象建造者之间存在关联关系，可以在其产品构造方法（一般使用 <code>getProduct()</code> 表示）调用具体建造者的部件构造和装配方法，完成复杂对象的建造</li>
</ul>
<p><code>建造者模式</code>（<code>Builder Pattern</code>）又称为<code>生成器模式</code>，其定义是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建出不同的表示。其目的是通过使用多个简单的对象来构建一个复杂的对象。它将客户端与包含多个组成部分的复杂对象的创建过程分离，客户端无需知道复杂对象的内部组成部分与装配方式，只需要知道所需建造者的类型即可。<code>建造者模式</code>中各个角色的代码实现如下：</p>
<p>抽象建造者（<code>Builder</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">(String A)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">(String B)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">(String C)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体建造者（<code>ConcreteBuilder</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">(String A)</span> </span>&#123;</span><br><span class="line">        product.setPartA(A);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">(String B)</span> </span>&#123;</span><br><span class="line">        product.setPartB(B);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">(String C)</span> </span>&#123;</span><br><span class="line">        product.setPartC(C);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>产品角色（<code>Product</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String partA;</span><br><span class="line">    <span class="keyword">private</span> String partB;</span><br><span class="line">    <span class="keyword">private</span> String partC;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartA</span><span class="params">(String partA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partA = partA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartB</span><span class="params">(String partB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partB = partB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartC</span><span class="params">(String partC)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partC = partC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Product&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;partA=&#x27;&quot;</span> + partA + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, partB=&#x27;&quot;</span> + partB + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, partC=&#x27;&quot;</span> + partC + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指挥者（<code>Director</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        builder.buildPartA(<span class="string">&quot;part A&quot;</span>);</span><br><span class="line">        builder.buildPartB(<span class="string">&quot;part B&quot;</span>);</span><br><span class="line">        builder.buildPartC(<span class="string">&quot;part C&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> builder.getProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用者代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Builder builder = <span class="keyword">new</span> ConcreteBuilder();</span><br><span class="line">Director director = <span class="keyword">new</span> Director(builder);</span><br><span class="line">Product product = director.getProduct();</span><br></pre></td></tr></table></figure>

<p><code>建造者模式</code>的主要优点如下：</p>
<ol>
<li>在<code>建造者模式</code>中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象</li>
<li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。由于指挥者类针对抽象建造者编程，增加新的具体建造者无须修改原有类库的代码，系统扩展方便，符合<code>开闭原则</code></li>
<li>可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程</li>
</ol>
<p><code>建造者模式</code>的主要缺点如下：</p>
<ol>
<li><code>建造者模式</code>所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，例如很多组成部分都不相同，不适合使用<code>建造者模式</code>，因此其使用范围受到一定的限制</li>
<li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加系统的理解难度和运行成本</li>
</ol>
<p><code>建造者模式</code>使用场景：</p>
<ol>
<li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性</li>
<li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序</li>
<li>对象的创建过程独立于创建该对象的类。在<code>建造者模式中</code>通过引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类和客户类中</li>
<li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品</li>
</ol>
<h2 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h2><p>结构型设计模式(<code>Structural Pattern</code>)描述如何将类或者对象结合在一起形成更大的结构。结构型设计模式可以分为类结构型模式和对象结构型模式：</p>
<ul>
<li>类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系</li>
<li>对象结构型模式关心类与对象的组合，通过关联关系使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。</li>
</ul>
<p>根据<code>合成复用原则</code>，在系统中尽量使用关联关系来替代继承关系，因此大部分结构型模式都是对象结构型模式。</p>
<p><code>结构型设计模式</code>包含如下几种设计模式：</p>
<ol>
<li>适配器模式：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作</li>
<li>桥接模式：将抽象部分与实现部分分离，使它们都可以独立的变化</li>
<li>组合模式：将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性</li>
<li>装饰模式：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活</li>
<li>外观模式：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</li>
<li>享元模式：运用共享技术有效地支持大量细粒度的对象</li>
<li>代理模式：为其他对象提供一种代理以控制对这个对象的访问</li>
</ol>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p><em><strong>意图：</strong></em> 将一个类的接口转换成客户端希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作<br><em><strong>解决的问题：</strong></em> 主要解决在软件系统中，常常要将一些<code>现存的对象</code>放到新的环境中，而新环境要求的接口是现对象不能满足的<br><em><strong>角色：</strong></em> <code>适配器模式</code>中包含如下几个角色：</p>
<ul>
<li>目标抽象类（<code>Target</code>）： 目标抽象类定义客户端所需接口，可以是一个抽象类或接口，也可以是具体类</li>
<li>适配器类（<code>Adapter</code>）：适配器可以调用另一个接口，作为一个转换器，对 <code>Adaptee</code> 和 <code>Target</code> 进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承 <code>Target</code> 并关联一个 <code>Adaptee</code> 对象使二者产生联系</li>
<li>适配者类（<code>Adaptee</code>）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码</li>
</ul>
<p><code>适配器模式</code>(<code>Adapter Pattern</code>) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(<code>Wrapper</code>)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。<code>适配器模式</code>中各个角色的代码实现如下：</p>
<p>目标抽象类（<code>Target</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>适配者类（<code>Adaptee</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomethingByOtherWay</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>适配器类（<code>Adapter</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doSomethingByOtherWay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方式代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Target target = <span class="keyword">new</span> Adapter();</span><br><span class="line">        target.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论是对象适配器模式还是类适配器模式都具有如下优点：</p>
<ul>
<li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构</li>
<li>增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用</li>
<li>灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合<code>开闭原则</code></li>
</ul>
<p>具体来说，类适配器模式还有如下优点：</p>
<ul>
<li>由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强</li>
</ul>
<p>对象适配器模式还有如下优点：</p>
<ul>
<li>一个对象适配器可以把多个不同的适配者适配到同一个目标</li>
<li>可以适配一个适配者的子类，由于适配器和适配者之间是关联关系，根据<code>里氏代换原则</code>，适配者的子类也可通过该适配器进行适配</li>
</ul>
<p>类适配器模式的缺点如下：</p>
<ul>
<li>对于 <code>Java</code> 这种不支持多重类继承的语言，一次最多只能适配一个适配者类，不能同时适配多个适配者</li>
<li>适配者类不能为最终类，如在 <code>Java</code> 中不能为 <code>final</code> 类</li>
<li>在 <code>Java</code> 语言中，类适配器模式中的目标抽象类只能为接口，不能为类，其使用有一定的局限性</li>
</ul>
<p>对象适配器模式的缺点如下：</p>
<ul>
<li>与类适配器模式相比，要在适配器中置换适配者类的某些方法比较麻烦。如果一定要置换掉适配者类的一个或多个方法，可以先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。</li>
</ul>
<p><code>适配器模式</code>使用场景：</p>
<ul>
<li>系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码</li>
<li>想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作</li>
</ul>
<h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p><em><strong>意图：</strong></em> 将抽象部分与实现部分分离，使它们都可以独立的变化<br><em><strong>解决的问题：</strong></em> 在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活<br><em><strong>角色：</strong></em> <code>桥接模式</code>中存在如下角色：</p>
<ul>
<li>抽象类（<code>Abstraction</code>）：用于定义抽象类的接口，它一般是抽象类而不是接口，其中定义了一个 <code>Implementor</code>（实现类接口）类型的对象并可以维护该对象，它与 <code>Implementor</code> 之间具有关联关系，它既可以包含抽象业务方法，也可以包含具体业务方法</li>
<li>扩充抽象类（<code>RefinedAbstraction</code>）：扩充由 <code>Abstraction</code> 定义的接口，通常情况下它不再是抽象类而是具体类，它实现了在 <code>Abstraction</code> 中声明的抽象业务方法，在 <code>RefinedAbstraction</code> 中可以调用在 <code>Implementor</code> 中定义的业务方法</li>
<li>实现类接口（<code>Implementor</code>）：定义实现类的接口，这个接口不一定要与 <code>Abstraction</code> 的接口完全一致，事实上这两个接口可以完全不同，一般而言，<code>Implementor</code> 接口仅提供基本操作，而 <code>Abstraction</code> 定义的接口可能会做更多更复杂的操作。<code>Implementor</code> 接口对这些基本操作进行了声明，而具体实现交给其子类。通过关联关系，在 <code>Abstraction</code> 中不仅拥有自己的方法，还可以调用到 <code>Implementor</code> 中定义的方法，使用关联关系来替代继承关系</li>
<li>具体实现类（<code>ConcreteImplementor</code>）：具体实现 <code>Implementor</code> 接口，在不同的 <code>ConcreteImplementor</code> 中提供基本操作的不同实现，在程序运行时，<code>ConcreteImplementor</code> 对象将替换其父类对象，提供给抽象类具体的业务操作方法</li>
</ul>
<p><code>桥接模式</code>(<code>Bridge Pattern</code>)将抽象部分与它的实现部分分离，使它们都可以独立地变化。<code>桥接模式</code>中各个角色的代码实现如下：</p>
<p>抽象类（<code>Abstraction</code>）的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Implementor implementor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Abstraction</span><span class="params">(Implementor implementor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.implementor = implementor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Implementor <span class="title">getImplementor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> implementor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩充抽象类（<code>RefinedAbstraction</code>）的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RefinedAbstraction</span><span class="params">(Implementor implementor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(implementor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getImplementor().doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类接口（<code>Implementor</code>）的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体实现类（<code>ConcreteImplementor</code>）的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementor</span> <span class="keyword">implements</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>桥接模式</code>的主要优点如下：</p>
<ul>
<li>分离抽象接口及其实现部分。桥接模式使用<code>对象间的关联关系</code>解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自维度的变化，也就是说抽象和实现不再在同一个继承层次结构中，而是<code>子类化</code>它们，使它们各自都具有自己的子类，以便任何组合子类，从而获得多维度组合对象</li>
<li>在很多情况下，<code>桥接模式</code>可以取代多层继承方案，多层继承方案违背了<code>单一职责原则</code>，复用性较差，且类的个数非常多，桥接模式是比多层继承方案更好的解决方法，它极大减少了子类的个数</li>
<li><code>桥接模式</code>提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合<code>开闭原则</code></li>
</ul>
<p><code>桥接模式</code>的主要缺点如下：</p>
<ul>
<li><code>桥接模式</code>的使用会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程</li>
<li><code>桥接模式</code>要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性，如何正确识别两个独立维度也需要一定的经验积累</li>
</ul>
<p><code>桥接模式</code>的使用场景：</p>
<ul>
<li>如果一个系统需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，通过桥接模式可以使它们在抽象层建立一个关联关系</li>
<li><code>抽象部分</code>和<code>实现部分</code>可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合</li>
<li>一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立进行扩展</li>
<li>对于那些不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统，<code>桥接模式</code>尤为适用</li>
</ul>
<h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p><em><strong>意图：</strong></em> 将对象组合成树形结构以表示<code>部分-整体</code>的层次结构。<code>组合模式</code>使得用户对单个对象和组合对象的使用具有一致性<br><em><strong>解决的问题：</strong></em> 它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户端可以向处理简单元素一样来处理复杂元素，从而使得客户端与复杂元素的内部结构解耦<br><em><strong>角色：</strong></em> <code>组合模式</code>有如下角色：</p>
<ul>
<li>抽象构件（<code>Component</code>）：它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法，如增加子构件、删除子构件、获取子构件等</li>
<li>叶子构件（<code>Leaf</code>）：它在组合结构中表示叶子节点对象，叶子节点没有子节点，它实现了在抽象构件中定义的行为。对于那些访问及管理子构件的方法，可以通过异常等方式进行处理</li>
<li>容器构件（<code>Composite</code>）：它在组合结构中表示容器节点对象，容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点，它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子节点的业务方法</li>
</ul>
<p><code>组合模式</code>（<code>Composite Pattern</code>）对单个对象(叶子构件)和组合对象(容器构件)具有一致性，它将对象组织到树结构中，可以用来描述整体与部分的关系。同时它也模糊了简单元素(叶子组件)和复杂元素(容器组件)的概念，使得客户端能够像处理简单元素一样来处理复杂元素，从而使客户程序能够与复杂元素的内部结构解耦。<code>组合模式</code>中各个角色的关系代码实现如下：</p>
<p>抽象构件（<code>Component</code>）的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Employee employee)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Employee employee)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>叶子构件（<code>Leaf</code>）的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Developer</span> <span class="keyword">implements</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Developer</span><span class="params">(String name, <span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//叶子节点，该方法不适用于当前类</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//叶子节点，该方法不适用于当前类</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;Name = &quot;</span> + <span class="keyword">this</span>.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;\t\tSalary = &quot;</span> + <span class="keyword">this</span>.salary);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>容器构件（<code>Composite</code>）的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">implements</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name, <span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Employee&gt; employees = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">        employees.add(employee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">        employees.remove(employee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;Name = &quot;</span> + <span class="keyword">this</span>.name);</span><br><span class="line">        System.out.println(<span class="string">&quot;\t\tSalary = &quot;</span> + <span class="keyword">this</span>.salary);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Employee employee : employees) &#123;</span><br><span class="line">            employee.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Employee emp1 = <span class="keyword">new</span> Developer(<span class="string">&quot;员工 - 小李&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">        Employee emp2 = <span class="keyword">new</span> Developer(<span class="string">&quot;员工 - 小王&quot;</span>, <span class="number">15000</span>);</span><br><span class="line">        Employee manager1 = <span class="keyword">new</span> Manager(<span class="string">&quot;经理 - 邱东&quot;</span>, <span class="number">25000</span>);</span><br><span class="line">        manager1.add(emp1);</span><br><span class="line">        manager1.add(emp2);</span><br><span class="line">        Employee emp3 = <span class="keyword">new</span> Developer(<span class="string">&quot;员工 - 小唐&quot;</span>, <span class="number">20000</span>);</span><br><span class="line">        Manager generalManager = <span class="keyword">new</span> Manager(<span class="string">&quot;总经理 - 覃飞&quot;</span>, <span class="number">50000</span>);</span><br><span class="line">        generalManager.add(emp3);</span><br><span class="line">        generalManager.add(manager1);</span><br><span class="line">        generalManager.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>组合模式</code>的主要优点如下：</p>
<ul>
<li><code>组合模式</code>可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制</li>
<li>客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码</li>
<li>在<code>组合模式中</code>增加新的容器构件和叶子构件都很方便，无须对现有类库进行任何修改，符合<code>开闭原则</code></li>
<li><code>组合模式</code>为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子构件和容器构件的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单</li>
</ul>
<p><code>组合模式</code>的主要缺点如下：</p>
<p>在增加新构件时很难对容器中的构件类型进行限制。有时候我们希望一个容器中只能有某些特定类型的对象，例如在某个文件夹中只能包含文本文件，使用组合模式时，不能依赖类型系统来施加这些约束，因为它们都来自于相同的抽象层，在这种情况下，必须通过在运行时进行类型检查来实现，这个实现过程较为复杂</p>
<p><code>组合模式</code>的使用场景：</p>
<ul>
<li>在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们</li>
<li>在一个使用面向对象语言开发的系统中需要处理一个树形结构</li>
<li>在一个系统中能够分离出叶子构件和容器构件，而且它们的类型不固定，需要增加一些新的类型</li>
</ul>
<h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p><em><strong>意图：</strong></em> 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活<br><em><strong>解决的问题：</strong></em> 一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀<br><em><strong>角色：</strong></em> <code>装饰器模式</code>中有如下角色：</p>
<ul>
<li>抽象构件（<code>Component</code>）：它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作</li>
<li>具体构件（<code>ConcreteComponent</code>）：它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责</li>
<li>抽象装饰类（<code>Decorator</code>）：它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的</li>
<li>具体装饰类（<code>ConcreteDecorator</code>）：它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为</li>
</ul>
<p><code>装饰模式</code>(<code>Decorator Pattern</code>)旨在动态地给一个对象增加一些额外的职责(<code>Responsibility</code>)，就增加对象功能来说，<code>装饰模式</code>比生成子类实现更为灵活。其别名也可以称为包装器(<code>Wrapper</code>)，与<code>适配器模式</code>的别名相同，但它们适用于不同的场合。<code>装饰器模式</code>中各个角色的代码实现如下：</p>
<p>抽象构件（<code>Component</code>）的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体构件（<code>ConcreteComponent</code>）的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象装饰类（<code>Decorator</code>）的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorated</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Decorated</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        component.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体装饰类（<code>ConcreteDecorator</code>）的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecoratorA</span> <span class="keyword">extends</span> <span class="title">Decorated</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ConcreteDecoratorA</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doSomething();</span><br><span class="line">        <span class="comment">// do other something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Component component = <span class="keyword">new</span> ConcreteComponent();</span><br><span class="line">        Component componentA = <span class="keyword">new</span> ConcreteDecoratorA(component);</span><br><span class="line">        componentA.doSomething();</span><br><span class="line"></span><br><span class="line">        Component componentB = <span class="keyword">new</span> ConcreteDecoratorB(component);</span><br><span class="line">        componentB.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>装饰模式</code>的主要优点如下：</p>
<ul>
<li>对于扩展一个对象的功能，<code>装饰模式</code>比继承更加灵活性，不会导致类的个数急剧增加</li>
<li>可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的具体装饰类，从而实现不同的行为</li>
<li>可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，得到功能更为强大的对象</li>
<li>具体构件类与具体装饰类可以独立变化，客户端可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合<code>开闭原则</code></li>
</ul>
<p><code>装饰模式</code>的主要缺点如下：</p>
<ul>
<li>使用<code>装饰模式</code>进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，大量小对象的产生势必会占用更多的系统资源，在一定程序上影响程序的性能</li>
<li><code>装饰模式</code>提供了一种比继承更加灵活机动的解决方案，但同时也意味着比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐</li>
</ul>
<p><code>装饰模式</code>的使用场景如下：</p>
<ul>
<li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责</li>
<li>当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用<code>装饰模式</code></li>
</ul>
<p>不能采用继承的情况主要有两类：</p>
<ul>
<li>系统中存在大量独立的扩展，为支持每一种扩展或者扩展之间的组合将产生大量的子类，使得子类数目呈爆炸性增长</li>
<li>类已定义为不能被继承（如 <code>Java</code> 语言中的 <code>final</code> 类）</li>
</ul>
<h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p><em><strong>意图：</strong></em> 为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用<br><em><strong>解决的问题：</strong></em> 降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口<br><em><strong>角色：</strong></em> <code>外观模式</code>有如下角色：</p>
<ul>
<li>外观角色（<code>Facade</code>）：在客户端可以调用它的方法，在<code>外观角色</code>中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理</li>
<li>子系统角色（<code>SubSystem</code>）：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已</li>
</ul>
<p><code>外观模式</code>(<code>Facade Pattern</code>)是指外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为<code>门面模式</code>，它是一种对象结构型模式。<code>外观模式</code>中各个角色的代码实现如下：</p>
<p>外观角色（<code>Facade</code>）的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SubSystemA subSystemA;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SubSystemB subSystemB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Facade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        subSystemA = <span class="keyword">new</span> SubSystemA();</span><br><span class="line">        subSystemB = <span class="keyword">new</span> SubSystemB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        subSystemA.doSomething();</span><br><span class="line">        subSystemB.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子系统角色（<code>SubSystem</code>）的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubSystemA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用者的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Facade facade = <span class="keyword">new</span> Facade();</span><br><span class="line">        facade.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>外观模式</code>的主要优点如下：</p>
<ul>
<li>它对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。通过引入<code>外观模式</code>，客户端代码将变得很简单，与之关联的对象也很少</li>
<li>它实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可</li>
<li>一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象</li>
</ul>
<p><code>外观模式</code>的主要缺点如下：</p>
<ul>
<li>不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性</li>
<li>如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了<code>开闭原则</code></li>
</ul>
<p><code>外观模式</code>的使用场景：</p>
<ul>
<li>当要为访问一系列复杂的子系统提供一个简单入口时可以使用<code>外观模式</code></li>
<li>客户端程序与多个子系统之间存在很大的依赖性。引入外观类可以将子系统与客户端解耦，从而提高子系统的独立性和可移植性</li>
<li>在层次化结构中，可以使用<code>外观模式</code>定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度</li>
</ul>
<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p><em><strong>意图：</strong></em> 运用共享技术有效地支持大量细粒度的对象<br><em><strong>解决的问题：</strong></em> 在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建<br><em><strong>角色：</strong></em> <code>享元模式</code>有如下角色：</p>
<ul>
<li>抽象享元类（<code>Flyweight</code>）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）</li>
<li>具体享元类（<code>ConcreteFlyweight</code>）：它实现了抽象享元类，其实例称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象</li>
<li>非共享具体享元类（<code>UnsharedConcreteFlyweight</code>）：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建</li>
<li>享元工厂类（<code>FlyweightFactory</code>）：享元工厂类用于创建并管理享元对象，它针对抽象享元类编程，将各种类型的具体享元对象存储在一个享元池中，享元池一般设计为一个存储<code>键值对</code>的集合（也可以是其他类型的集合），可以结合工厂模式进行设计；当用户请求一个具体享元对象时，享元工厂提供一个存储在享元池中已创建的实例或者创建一个新的实例（如果不存在的话），返回新创建的实例并将其存储在享元池中</li>
</ul>
<p><code>享元模式</code>(<code>Flyweight Pattern</code>)通过运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。<code>享元模式</code>中各个角色的代码实现如下：</p>
<p>抽象享元类（<code>Flyweight</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyweight</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">(String externalState)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体享元类（<code>ConcreteFlyweight</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyWeight</span> <span class="keyword">implements</span> <span class="title">Flyweight</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteFlyWeight</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">(String externalState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>享元工厂类（<code>FlyweightFactory</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, Flyweight&gt; allFlyWeight = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Flyweight&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Flyweight <span class="title">getFlyWeight</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (allFlyWeight.get(name) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (allFlyWeight) &#123;</span><br><span class="line">                <span class="keyword">if</span> (allFlyWeight.get(name) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Flyweight flyWeight = <span class="keyword">new</span> ConcreteFlyWeight(name);</span><br><span class="line">                    allFlyWeight.put(name, flyWeight);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allFlyWeight.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>享元模式</code>的主要优点如下：</p>
<ul>
<li>可以极大减少内存中对象的数量，使得相同或相似对象在内存中只保存一份，从而可以节约系统资源，提高系统性能</li>
<li><code>享元模式</code>的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享</li>
</ul>
<p><code>享元模式</code>的主要缺点如下：</p>
<ul>
<li><code>享元模式</code>使得系统变得复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化</li>
<li>为了使对象可以共享，<code>享元模式</code>需要将享元对象的部分状态外部化，而读取外部状态将使得运行时间变长</li>
</ul>
<p><code>享元模式</code>的使用场景：</p>
<ul>
<li>一个系统有大量相同或者相似的对象，造成内存的大量耗费</li>
<li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中</li>
<li>在使用<code>享元模式</code>时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用<code>享元模式</code></li>
</ul>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p><em><strong>意图：</strong></em> 为其他对象提供一种代理以控制对这个对象的访问<br><em><strong>解决的问题：</strong></em> 在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层<br><em><strong>角色：</strong></em> <code>代理模式</code>有如下角色：</p>
<ul>
<li>抽象主题角色（<code>Subject</code>）：它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程</li>
<li>代理主题角色（<code>Proxy</code>）：它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中，客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作</li>
<li>真实主题角色（<code>RealSubject</code>）：它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作</li>
</ul>
<p><code>代理模式</code>(<code>Proxy Pattern</code>)给某一个对象提供一个代理，并由代理对象控制对原对象的引用。<code>代理模式</code>中各个角色的代码实现如下：</p>
<p>抽象主题角色（<code>Subject</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理主题角色（<code>Proxy</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        subject.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真实主题角色（<code>RealSubject</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用者代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject subject = <span class="keyword">new</span> Proxy();</span><br><span class="line">        subject.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>代理模式</code>的优点如下：</p>
<ul>
<li>能够协调调用者和被调用者，在一定程度上降低了系统的耦合度</li>
<li>客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合<code>开闭原则</code>，系统具有较好的灵活性和可扩展性</li>
</ul>
<p>此外，不同类型的代理模式也具有独特的优点，例如：</p>
<ul>
<li>远程代理为位于两个不同地址空间对象的访问提供了一种实现机制，可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高系统的整体运行效率</li>
<li>虚拟代理通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销</li>
<li>缓冲代理为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间</li>
<li>保护代理可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限</li>
</ul>
<p><code>代理模式</code>的主要缺点如下：</p>
<ul>
<li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，例如保护代理</li>
<li>实现<code>代理模式</code>需要额外的工作，而且有些<code>代理模式</code>的实现过程较为复杂，例如远程代理</li>
</ul>
<p><code>代理模式</code>的使用场景如下：</p>
<p><code>代理模式</code>的类型较多，不同类型的<code>代理模式</code>有不同的优缺点，它们应用于不同的场合</p>
<ul>
<li>当客户端对象需要访问远程主机中的对象时可以使用远程代理</li>
<li>当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用虚拟代理，例如一个对象需要很长时间才能完成加载时</li>
<li>当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用缓冲代理。通过使用缓冲代理，系统无须在客户端每一次访问时都重新执行操作，只需直接从临时缓冲区获取操作结果即可</li>
<li>当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时可以使用保护代理</li>
<li>当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智能引用代理</li>
</ul>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><p>行为型模式(<code>Behavioral Pattern</code>)是对在不同的对象之间划分责任和算法的抽象化。行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。</p>
<p>通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。</p>
<p>行为型模式分为类行为型模式和对象行为型模式两种：</p>
<ul>
<li>类行为型模式：类的行为型模式使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责</li>
<li>对象行为型模式：对象的行为型模式则使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据<code>合成复用原则</code>，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式</li>
</ul>
<p>行为型模式包含如下设计模式：</p>
<ol>
<li>责任链模式：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止</li>
<li>命令模式：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化</li>
<li>解释器模式：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子</li>
<li>迭代器模式：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示</li>
<li>中介者模式：一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互</li>
<li>备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态</li>
<li>观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</li>
<li>状态模式：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类</li>
<li>策略模式：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换</li>
<li>模板方法模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</li>
<li>访问者模式：主要将数据结构与数据操作分离</li>
</ol>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p><em><strong>意图：</strong></em> 避免请求的发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止<br><em><strong>解决的问题：</strong></em> 职责连上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了<br><em><strong>角色：</strong></em> <code>责任链模式</code>中有如下角色：</p>
<ul>
<li>抽象处理者（<code>Handler</code>）：它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象，作为其对下家的引用。通过该引用，处理者可以连成一条链</li>
<li>具体处理者（<code>ConcreteHandler</code>）：它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中下一个对象，以便请求的转发</li>
</ul>
<p><code>责任链模式</code>(<code>Chain of Responsibility Pattern</code>)避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。职责链模式是一种对象行为型模式。<code>责任链模式</code>中各个角色的代码实现如下：</p>
<p>抽象处理者（<code>Handler</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Handler successor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuccessor</span><span class="params">(Handler successor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(String request)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体处理者（<code>ConcreteHandler</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(String request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (满足请求条件) &#123;</span><br><span class="line">            <span class="comment">// 处理请求</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 转发请求</span></span><br><span class="line">            <span class="keyword">this</span>.successor.handleRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>职责链模式可分为纯的职责链模式和不纯的职责链模式两种：</p>
<ul>
<li>纯的职责链模式</li>
</ul>
<p>一个纯的职责链模式要求一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家，不允许出现某一个具体处理者对象在承担了一部分或全部责任后又将责任向下传递的情况。而且在纯的职责链模式中，要求一个请求必须被某一个处理者对象所接收，不能出现某个请求未被任何一个处理者对象处理的情况。在前面的采购单审批实例中应用的是纯的职责链模式。</p>
<ul>
<li>不纯的职责链模式</li>
</ul>
<p>在一个不纯的职责链模式中允许某个请求被一个具体处理者部分处理后再向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求，而且一个请求可以最终不被任何处理者对象所接收。</p>
<p><code>职责链模式</code>的主要优点如下：</p>
<ul>
<li><code>职责链模式</code>使得一个对象无须知道是其他哪一个对象处理其请求，对象仅需知道该请求会被处理即可，接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构，由客户端负责链的创建，降低了系统的耦合度</li>
<li>请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，可简化对象的相互连接</li>
<li>在给对象分派职责时，职责链可以给我们更多的灵活性，可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责</li>
<li>在系统中增加一个新的具体请求处理者时无须修改原有系统的代码，只需要在客户端重新建链即可，从这一点来看是符合<code>开闭原则</code>的</li>
</ul>
<p><code>职责链模式</code>的主要缺点如下：</p>
<ul>
<li>由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；一个请求也可能因职责链没有被正确配置而得不到处理</li>
<li>对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便</li>
<li>如果建链不当，可能会造成循环调用，将导致系统陷入死循环</li>
</ul>
<p><code>责任链模式</code>的使用场景如下：</p>
<ul>
<li>有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的</li>
<li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求</li>
<li>可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序</li>
</ul>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p><em><strong>意图：</strong></em> 将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化<br><em><strong>解决的问题：</strong></em> 在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适<br><em><strong>角色：</strong></em> <code>命令模式</code>中有如下角色：</p>
<ul>
<li>抽象命令类（<code>Command</code>）：抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的 <code>execute()</code> 等方法，通过这些方法可以调用请求接收者的相关操作</li>
<li>具体命令类（<code>ConcreteCommand</code>）：具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。在实现 <code>execute()</code> 方法时，将调用接收者对象的相关操作</li>
<li>调用者（<code>Invoker</code>）：调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的 <code>execute()</code> 方法，从而实现间接调用请求接收者的相关操作</li>
<li>接收者（<code>Receiver</code>）：接收者执行与请求相关的操作，它具体实现对请求的业务处理</li>
</ul>
<p><code>命令模式</code>(<code>Command Pattern</code>)将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式。<code>命令模式</code>中各个角色的代码实现如下：</p>
<p>抽象命令类（<code>Command</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体命令类（<code>ConcreteCommand</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommand</span><span class="params">(Receiver receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用者（<code>Invoker</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Invoker</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接收者（<code>Receiver</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Receiver receiver = <span class="keyword">new</span> Receiver();</span><br><span class="line">        Command command = <span class="keyword">new</span> ConcreteCommand(receiver);</span><br><span class="line">        Invoker invoker = <span class="keyword">new</span> Invoker(command);</span><br><span class="line">        invoker.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>命令模式</code>的主要优点如下：</p>
<ul>
<li>降低系统的耦合度。由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦，相同的请求者可以对应不同的接收者，同样，相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性</li>
<li>新的命令可以很容易地加入到系统中。由于增加新的具体命令类不会影响到其他类，因此增加新的具体命令类很容易，无须修改原有系统源代码，甚至客户类代码，满足<code>开闭原则</code>的要求</li>
<li>可以比较容易地设计一个命令队列或宏命令（组合命令）</li>
<li>为请求的撤销和恢复操作提供了一种设计和实现方案</li>
</ul>
<p><code>命令模式</code>的主要缺点如下：</p>
<p>使用<code>命令模式</code>可能会导致某些系统有过多的具体命令类。因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，因此在某些系统中可能需要提供大量的具体命令类，这将影响命令模式的使用。</p>
<p><code>命令模式</code>的使用场景如下：</p>
<ul>
<li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。请求调用者无须知道接收者的存在，也无须知道接收者是谁，接收者也无须关心何时被调用</li>
<li>系统需要在不同的时间指定请求、将请求排队和执行请求。一个命令对象和请求的初始调用者可以有不同的生命期，换言之，最初的请求发出者可能已经不在了，而命令对象本身仍然是活动的，可以通过该命令对象去调用请求接收者，而无须关心请求调用者的存在性，可以通过请求日志文件等机制来具体实现</li>
<li>系统需要支持命令的撤销操作和恢复操作。</li>
<li>系统需要将一组操作组合在一起形成宏命令</li>
</ul>
<h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><p><em><strong>意图：</strong></em> 给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子<br><em><strong>解决的问题：</strong></em> 对于一些固定文法构建一个解释句子的解释器<br><em><strong>角色：</strong></em> <code>解释器模式</code>中存在如下角色：</p>
<ul>
<li>抽象表达式（<code>AbstractExpression</code>）：在抽象表达式中声明了抽象的解释操作，它是所有终结符表达式和非终结符表达式的公共父类</li>
<li>终结符表达式（<code>TerminalExpression</code>）：终结符表达式是抽象表达式的子类，它实现了与文法中的终结符相关联的解释操作，在句子中的每一个终结符都是该类的一个实例。通常在一个解释器模式中只有少数几个终结符表达式类，它们的实例可以通过非终结符表达式组成较为复杂的句子</li>
<li>非终结符表达式（<code>NonterminalExpression</code>）：非终结符表达式也是抽象表达式的子类，它实现了文法中非终结符的解释操作，由于在非终结符表达式中可以包含终结符表达式，也可以继续包含非终结符表达式，因此其解释操作一般通过递归的方式来完成</li>
<li>环境类（<code>Context</code>）：环境类又称为上下文类，它用于存储解释器之外的一些全局信息，通常它临时存储了需要解释的语句</li>
</ul>
<p><code>解释器模式</code>(<code>Interpreter Pattern</code>)定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的<code>语言</code>是指使用规定格式和语法的代码。解释器模式是一种类行为型模式。<code>解释器模式</code>中各个角色的代码实现如下：</p>
<p>抽象表达式（<code>AbstractExpression</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">interpret</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终结符表达式（<code>TerminalExpression</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TerminalExpression</span> <span class="keyword">extends</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interpret</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非终结符表达式（<code>NonterminalExpression</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonterminalExpression</span> <span class="keyword">extends</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AbstractExpression[] expression;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NonterminalExpression</span><span class="params">(AbstractExpression... expression)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.expression = expression;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interpret</span><span class="params">(Context ctx)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>环境类（<code>Context</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String expression = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">char</span>[] charArray = expression.toCharArray();</span><br><span class="line">        Context ctx = <span class="keyword">new</span> Context();</span><br><span class="line">        Stack&lt;AbstractExpression&gt; stack = <span class="keyword">new</span> Stack&lt;AbstractExpression&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; charArray.length; i++) &#123;</span><br><span class="line">            <span class="comment">//进行语法判断，递归调用</span></span><br><span class="line">        &#125;</span><br><span class="line">        AbstractExpression exp = stack.pop();</span><br><span class="line">        exp.interpret(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>解释器模式</code>的主要优点如下：</p>
<ul>
<li>易于改变和扩展文法。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法</li>
<li>每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言</li>
<li>实现文法较为容易。在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码</li>
<li>增加新的解释表达式较为方便。如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合<code>开闭原则</code></li>
</ul>
<p><code>解释器模式</code>的主要缺点如下：</p>
<ul>
<li>对于复杂文法难以维护。在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护，此时可以考虑使用语法分析程序等方式来取代解释器模式</li>
<li>执行效率较低。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦</li>
</ul>
<p><code>解释器模式</code>适用于以下场景：</p>
<ul>
<li>可以将一个需要解释执行的语言中的句子表示为一个抽象语法树</li>
<li>一些重复出现的问题可以用一种简单的语言来进行表达</li>
<li>一个语言的文法较为简单</li>
<li>执行效率不是关键问题</li>
</ul>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p><em><strong>意图：</strong></em> 提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示<br><em><strong>解决的问题：</strong></em> 不同的方式来遍历整个整合对象<br><em><strong>角色：</strong></em> <code>迭代器模式</code>中有如下角色：</p>
<ul>
<li>抽象迭代器（<code>Iterator</code>）：它定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法，例如：用于获取第一个元素的 <code>first()</code>方法，用于访问下一个元素的 <code>next()</code> 方法，用于判断是否还有下一个元素的 <code>hasNext()</code> 方法，用于获取当前元素的 <code>currentItem()</code> 方法等，在具体迭代器中将实现这些方法</li>
<li>具体迭代器（<code>ConcreteIterator</code>）：它实现了抽象迭代器接口，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录在聚合对象中所处的当前位置，在具体实现时，游标通常是一个表示位置的非负整数</li>
<li>抽象聚合类（<code>Aggregate</code>）：它用于存储和管理元素对象，声明一个 <code>createIterator()</code> 方法用于创建一个迭代器对象，充当抽象迭代器工厂角色</li>
<li>具体聚合类（<code>ConcreteAggregate</code>）：它实现了在抽象聚合类中声明的 <code>createIterator()</code> 方法，该方法返回一个与该具体聚合类对应的具体迭代器 <code>ConcreteIterator</code> 实例</li>
</ul>
<p><code>迭代器模式</code>(<code>Iterator Pattern</code>)提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标(<code>Cursor</code>)。迭代器模式是一种对象行为型模式。<code>迭代器模式</code>中各个角色的代码实现如下：</p>
<p>抽象迭代器（<code>Iterator</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代方法：移动到第一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代方法：移动到下一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代方法：是否为最后一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代方法：返还当前元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">currentItem</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体迭代器（<code>ConcreteIterator</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="comment">//持有被迭代的具体的聚合对象</span></span><br><span class="line">    <span class="keyword">private</span> ConcreteAggregate agg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内部索引，记录当前迭代到的索引位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录当前聚集对象的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteIterator</span><span class="params">(ConcreteAggregate agg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.agg = agg;</span><br><span class="line">        <span class="keyword">this</span>.size = agg.size();</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代方法：返还当前元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">currentItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> agg.getElement(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代方法：移动到第一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代方法：是否为最后一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (index &gt;= size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代方法：移动到下一个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index &lt; size) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>抽象聚合类（<code>Aggregate</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工厂方法，创建相应迭代子对象的接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Iterator <span class="title">createIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体聚合类（<code>ConcreteAggregate</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span> <span class="keyword">extends</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object[] objArray = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，传入聚合对象的具体内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteAggregate</span><span class="params">(Object[] objArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.objArray = objArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取值方法：向外界提供聚集元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getElement</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index &lt; objArray.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> objArray[index];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取值方法：向外界提供聚集的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> objArray.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>调用方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object[] objArray = &#123;<span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>, <span class="string">&quot;Four&quot;</span>, <span class="string">&quot;Five&quot;</span>, <span class="string">&quot;Six&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//创建聚合对象</span></span><br><span class="line">        Aggregate agg = <span class="keyword">new</span> ConcreteAggregate(objArray);</span><br><span class="line">        <span class="comment">//循环输出聚合对象中的值</span></span><br><span class="line">        Iterator it = agg.createIterator();</span><br><span class="line">        <span class="keyword">while</span> (!it.isDone()) &#123;</span><br><span class="line">            System.out.println(it.currentItem());</span><br><span class="line">            it.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Client client = <span class="keyword">new</span> Client();</span><br><span class="line">        client.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>迭代器模式</code>的主要优点如下：</p>
<ul>
<li>它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式</li>
<li>迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计</li>
<li>在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足<code>开闭原则</code>的要求</li>
</ul>
<p><code>迭代器模式</code>的主要缺点如下：</p>
<ul>
<li>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性</li>
<li>抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展，例如 <code>JDK</code> 内置迭代器 <code>Iterator</code> 就无法实现逆向遍历，如果需要实现逆向遍历，只能通过其子类 <code>ListIterator</code> 等来实现，而 <code>ListIterator</code> 迭代器无法用于操作 <code>Set</code> 类型的聚合对象。在自定义迭代器时，创建一个考虑全面的抽象迭代器并不是件很容易的事情</li>
</ul>
<p><code>迭代器模式</code>的使用场景：</p>
<ul>
<li>访问一个聚合对象的内容而无须暴露它的内部表示。将聚合对象的访问与内部数据的存储分离，使得访问聚合对象时无须了解其内部实现细节</li>
<li>需要为一个聚合对象提供多种遍历方式</li>
<li>为遍历不同的聚合结构提供一个统一的接口，在该接口的实现类中为不同的聚合结构提供不同的遍历方式，而客户端可以一致性地操作该接口</li>
</ul>
<h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><p><em><strong>意图：</strong></em> 用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互<br><em><strong>解决的问题：</strong></em> 对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理<br><em><strong>角色：</strong></em> <code>中介者模式</code>中有如下角色：</p>
<ul>
<li>抽象中介者（<code>Mediator</code>）：它定义一个接口，该接口用于与各同事对象之间进行通信</li>
<li>具体中介者（<code>ConcreteMediator</code>）：它是抽象中介者的子类，通过协调各个同事对象来实现协作行为，它维持了对各个同事对象的引用</li>
<li>抽象同事类（<code>Colleague</code>）：它定义各个同事类公有的方法，并声明了一些抽象方法来供子类实现，同时它维持了一个对抽象中介者类的引用，其子类可以通过该引用来与中介者通信</li>
<li>具体同事类（<code>ConcreteColleague</code>）：它是抽象同事类的子类；每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信；在具体同事类中实现了在抽象同事类中声明的抽象方法</li>
</ul>
<p><code>中介者模式</code>(<code>Mediator Pattern</code>)：用一个中介对象（中介者）来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。<code>中介者模式</code>中各个角色的代码实现如下：</p>
<p>抽象中介者（<code>Mediator</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Colleague colleagueA;</span><br><span class="line">    <span class="keyword">private</span> Colleague colleagueB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">executeToA</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">executeToB</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColleagueA</span><span class="params">(Colleague colleagueA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.colleagueA = colleagueA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColleagueB</span><span class="params">(Colleague colleagueB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.colleagueB = colleagueB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体中介者（<code>ConcreteMediator</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeToA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mediator executeToA ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeToB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mediator executeToB ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象同事类（<code>Colleague</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体同事类（<code>ConcreteColleague</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColleagueA</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Mediator mediator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ColleagueA</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ColleagueA print ... &quot;</span>);</span><br><span class="line">        mediator.executeToB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>调用代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mediator mediator = <span class="keyword">new</span> ConcreteMediator();</span><br><span class="line">        Colleague colleagueA = <span class="keyword">new</span> ColleagueA(mediator);</span><br><span class="line">        Colleague colleagueB = <span class="keyword">new</span> ColleagueB(mediator);</span><br><span class="line">        mediator.setColleagueA(colleagueA);</span><br><span class="line">        mediator.setColleagueB(colleagueB);</span><br><span class="line">        colleagueA.print();</span><br><span class="line">        colleagueB.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>中介者模式</code>的主要优点如下：</p>
<ul>
<li><code>中介者模式</code>简化了对象之间的交互，它用中介者和同事的一对多交互代替了原来同事之间的多对多交互，一对多关系更容易理解、维护和扩展，将原本难以理解的网状结构转换成相对简单的星型结构</li>
<li><code>中介者模式</code>可将各同事对象解耦。中介者有利于各同事之间的松耦合，我们可以独立的改变和复用每一个同事和中介者，增加新的中介者和新的同事类都比较方便，更好地符合<code>开闭原则</code></li>
<li>可以减少子类生成，中介者将原本分布于多个对象间的行为集中在一起，改变这些行为只需生成新的中介者子类即可，这使各个同事类可被重用，无须对同事类进行扩展</li>
</ul>
<p><code>中介者模式</code>的主要缺点如下：</p>
<p>在具体中介者类中包含了大量同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。</p>
<p><code>中介者模式</code>使用场景如下：</p>
<ul>
<li>系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解</li>
<li>一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象</li>
<li>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象交互的公共行为，如果需要改变行为则可以增加新的具体中介者类</li>
</ul>
<h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><p><em><strong>意图：</strong></em> 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态<br><em><strong>解决的问题：</strong></em> 所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态<br><em><strong>角色：</strong></em> <code>备忘录模式</code>中有如下角色：</p>
<ul>
<li>原发器（<code>Originator</code>）：它是一个普通类，可以创建一个备忘录，并存储它的当前内部状态，也可以使用备忘录来恢复其内部状态，一般将需要保存内部状态的类设计为原发器</li>
<li>备忘录（<code>Memento</code>）：存储原发器的内部状态，根据原发器来决定保存哪些内部状态。备忘录的设计一般可以参考原发器的设计，根据实际需要确定备忘录类中的属性。需要注意的是，除了原发器本身与负责人类之外，备忘录对象不能直接供其他类使用，原发器的设计在不同的编程语言中实现机制会有所不同</li>
<li>负责人（<code>Caretaker</code>）：负责人又称为管理者，它负责保存备忘录，但是不能对备忘录的内容进行操作或检查。在负责人类中可以存储一个或多个备忘录对象，它只负责存储对象，而不能修改对象，也无须知道对象的实现细节</li>
</ul>
<p><code>备忘录模式</code>(<code>Memento Pattern</code>)：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。它是一种对象行为型模式，其别名为 <code>Token</code>。<code>备忘录模式</code>中各个角色的代码实现如下：</p>
<p>原发器（<code>Originator</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String state = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">createMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Memento(<span class="keyword">this</span>.state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(memento.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>备忘录（<code>Memento</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String state = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>负责人（<code>Caretaker</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Caretaker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Memento memento;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">getMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.memento = memento;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Originator originator = <span class="keyword">new</span> Originator();</span><br><span class="line">        originator.setState(<span class="string">&quot;状态1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;初始状态:&quot;</span> + originator.getState());</span><br><span class="line">        Caretaker caretaker = <span class="keyword">new</span> Caretaker();</span><br><span class="line">        caretaker.setMemento(originator.createMemento());</span><br><span class="line">        originator.setState(<span class="string">&quot;状态2&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;改变后状态:&quot;</span> + originator.getState());</span><br><span class="line">        originator.restoreMemento(caretaker.getMemento());</span><br><span class="line">        System.out.println(<span class="string">&quot;恢复后状态:&quot;</span> + originator.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>备忘录模式</code>的主要优点如下：</p>
<ul>
<li>它提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原</li>
<li>备忘录实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码所改动。备忘录保存了原发器的状态，采用列表、堆栈等集合来存储备忘录对象可以实现多次撤销操作</li>
</ul>
<p><code>备忘录模式</code>的主要缺点如下：</p>
<p>资源消耗过大，如果需要保存的原发器类的成员变量太多，就不可避免需要占用大量的存储空间，每保存一次对象的状态都需要消耗一定的系统资源。</p>
<p><code>备忘录模式</code>的主要使用场景：</p>
<ul>
<li>保存一个对象在某一个时刻的全部状态或部分状态，这样以后需要时它能够恢复到先前的状态，实现撤销操作</li>
<li>防止外界对象破坏一个对象历史状态的封装性，避免将对象历史状态的实现细节暴露给外界对象</li>
</ul>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p><em><strong>意图：</strong></em> 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新<br><em><strong>解决的问题：</strong></em> 一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作<br><em><strong>角色：</strong></em> <code>观察者模式</code>中有如下角色：</p>
<ul>
<li>目标（<code>Subject</code>）：目标又称为主题，它是指被观察的对象。在目标中定义了一个观察者集合，一个观察目标可以接受任意数量的观察者来观察，它提供一系列方法来增加和删除观察者对象，同时它定义了通知方法 <code>notify()</code>。目标类可以是接口，也可以是抽象类或具体类</li>
<li>具体目标（<code>ConcreteSubject</code>）：具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有的话）。如果无须扩展目标类，则具体目标类可以省略</li>
<li>观察者（<code>Observer</code>）：观察者将对观察目标的改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法 <code>update()</code>，因此又称为抽象观察者</li>
<li>具体观察者（<code>ConcreteObserver</code>）：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者 <code>Observer</code> 中定义的 <code>update()</code> 方法。通常在实现时，可以调用具体目标类的 <code>attach()</code> 方法将自己添加到目标类的集合中或通过 <code>detach()</code> 方法将自己从目标类的集合中删除</li>
</ul>
<p><code>观察者模式</code>(<code>Observer Pattern</code>)：定义对象之间的一种一对多的依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式是一种对象行为型模式。<code>观察者模式</code>中各个角色的代码实现如下：</p>
<p>目标（<code>Subject</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体目标（<code>ConcreteSubject</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察者（<code>Observer</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体观察者（<code>ConcreteObserver</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcrereObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用者代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject subject = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">        Observer observer = <span class="keyword">new</span> ConcrereObserver();</span><br><span class="line">        subject.attach(observer);</span><br><span class="line">        subject.notify(<span class="string">&quot;message&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>观察者模式</code>的主要优点如下：</p>
<ul>
<li><code>观察者模式</code>可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色</li>
<li><code>观察者模式</code>在观察目标和观察者之间建立一个抽象的耦合。观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。由于观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次</li>
<li><code>观察者模式</code>支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度</li>
<li><code>观察者模式</code>符合<code>开闭原则</code>的要求，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便</li>
</ul>
<p><code>观察者模式</code>的主要缺点如下：</p>
<ul>
<li>如果一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会花费很多时间</li>
<li>如果在观察者和观察目标之间存在循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃</li>
<li><code>观察者模式</code>没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化</li>
</ul>
<p><code>观察者模式</code>的使用场景如下：</p>
<ul>
<li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两个方面封装在独立的对象中使它们可以各自独立地改变和复用</li>
<li>一个对象的改变将导致一个或多个其他对象也发生改变，而并不知道具体有多少对象将发生改变，也不知道这些对象是谁</li>
<li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制</li>
</ul>
<h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p><em><strong>意图：</strong></em> 允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类<br><em><strong>解决的问题：</strong></em> 对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为<br><em><strong>角色：</strong></em> <code>状态模式</code>中有如下角色：</p>
<ul>
<li>环境类（<code>Context</code>）：环境类又称为上下文类，它是拥有多种状态的对象。由于环境类的状态存在多样性且在不同状态下对象的行为有所不同，因此将状态独立出去形成单独的状态类。在环境类中维护一个抽象状态类 <code>State</code> 的实例，这个实例定义当前状态，在具体实现时，它是一个 <code>State</code> 子类的对象</li>
<li>抽象状态类（<code>State</code>）：它用于定义一个接口以封装与环境类的一个特定状态相关的行为，在抽象状态类中声明了各种不同状态对应的方法，而在其子类中实现类这些方法，由于不同状态下对象的行为可能不同，因此在不同子类中方法的实现可能存在不同，相同的方法可以写在抽象状态类中</li>
<li>具体状态类（<code>ConcreteState</code>）：它是抽象状态类的子类，每一个子类实现一个与环境类的一个状态相关的行为，每一个具体状态类对应环境的一个具体状态，不同的具体状态类其行为有所不同</li>
</ul>
<p><code>状态模式</code>(<code>State Pattern</code>)允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。状态模式是一种对象行为型模式。<code>状态模式</code>中各个角色的代码实现如下：</p>
<p>环境类（<code>Context</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.change(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象状态类（<code>State</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体状态类（<code>ConcreteState</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStateA</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is ConcreteStateA&quot;</span>);</span><br><span class="line">        context.setState(<span class="keyword">new</span> ConcreteStateB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStateB</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is ConcreteStateB&quot;</span>);</span><br><span class="line">        context.setState(<span class="keyword">new</span> ConcreteStateA());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        State state = <span class="keyword">new</span> ConcreteStateA();</span><br><span class="line">        Context context = <span class="keyword">new</span> Context(state);</span><br><span class="line">        <span class="comment">//初始状态是A</span></span><br><span class="line">        context.change();</span><br><span class="line">        <span class="comment">//转换一次后变成 B</span></span><br><span class="line">        context.change();</span><br><span class="line">        <span class="comment">//再转换一次后又变成 A</span></span><br><span class="line">        context.change();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>状态模式</code>的主要优点如下：</p>
<ul>
<li>封装了状态的转换规则，在状态模式中可以将状态的转换代码封装在环境类或者具体状态类中，可以对状态转换代码进行集中管理，而不是分散在一个个业务方法中</li>
<li>将所有与某个状态有关的行为放到一个类中，只需要注入一个不同的状态对象即可使环境对象拥有不同的行为</li>
<li>允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块，状态模式可以让我们避免使用庞大的条件语句来将业务方法和状态转换代码交织在一起</li>
<li>可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数</li>
</ul>
<p><code>状态模式</code>的主要缺点如下：</p>
<ul>
<li>状态模式的使用必然会增加系统中类和对象的个数，导致系统运行开销增大</li>
<li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，增加系统设计的难度</li>
<li>状态模式对<code>开闭原则</code>的支持并不太好，增加新的状态类需要修改那些负责状态转换的源代码，否则无法转换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码</li>
</ul>
<p><code>状态模式</code>的使用场景如下：</p>
<ul>
<li>对象的行为依赖于它的状态（如某些属性值），状态的改变将导致行为的变化</li>
<li>在代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，并且导致客户类与类库之间的耦合增强</li>
</ul>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p><em><strong>意图：</strong></em> 定义一系列的算法，把它们一个个封装起来, 并且使它们可相互替换<br><em><strong>解决的问题：</strong></em> 在有多种算法相似的情况下，使用 <code>if...else</code> 所带来的复杂和难以维护<br><em><strong>角色：</strong></em> <code>策略模式</code>有如下角色：</p>
<ul>
<li>环境类（<code>Context</code>）：环境类是使用算法的角色，它在解决某个问题（即实现某个方法）时可以采用多种策略。在环境类中维持一个对抽象策略类的引用实例，用于定义所采用的策略</li>
<li>抽象策略类（<code>Strategy</code>）：它为所支持的算法声明了抽象方法，是所有策略类的父类，它可以是抽象类或具体类，也可以是接口。环境类通过抽象策略类中声明的方法在运行时调用具体策略类中实现的算法</li>
<li>具体策略类（<code>ConcreteStrategy</code>）：它实现了在抽象策略类中声明的算法，在运行时，具体策略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务处理</li>
</ul>
<p><code>策略模式</code>(<code>Strategy Pattern</code>)定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客户而变化。策略模式是一种对象行为型模式。<code>策略模式</code>中各个角色的代码实现如下：</p>
<p>环境类（<code>Context</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        strategy.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象策略类（<code>Strategy</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体策略类（<code>ConcreteStrategy</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体策略 A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体策略 B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----执行策略 A-----&quot;</span>);</span><br><span class="line">        context = <span class="keyword">new</span> Context(<span class="keyword">new</span> ConcreteStrategyA());</span><br><span class="line">        context.execute();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----执行策略 B-----&quot;</span>);</span><br><span class="line">        context = <span class="keyword">new</span> Context(<span class="keyword">new</span> ConcreteStrategyB());</span><br><span class="line">        context.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>策略模式</code>的主要优点如下：</p>
<ul>
<li><code>策略模式</code>提供了对<code>开闭原则</code>的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为</li>
<li><code>策略模式</code>提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族，恰当使用继承可以把公共的代码移到抽象策略类中，从而避免重复的代码</li>
<li><code>策略模式</code>提供了一种可以替换继承关系的办法。如果不使用策略模式，那么使用算法的环境类就可能会有一些子类，每一个子类提供一种不同的算法。但是，这样一来算法的使用就和算法本身混在一起，不符合<code>单一职责原则</code>，决定使用哪一种算法的逻辑和该算法本身混合在一起，从而不可能再独立演化；而且使用继承无法实现算法或行为在程序运行时的动态切换</li>
<li>使用<code>策略模式</code>可以避免多重条件选择语句。多重条件选择语句不易维护，它把采取哪一种算法或行为的逻辑与算法或行为本身的实现逻辑混合在一起，将它们全部硬编码(<code>Hard Coding</code>)在一个庞大的多重条件选择语句中，比直接继承环境类的办法还要原始和落后</li>
<li><code>策略模式</code>提供了一种算法的复用机制，由于将算法单独提取出来封装在策略类中，因此不同的环境类可以方便地复用这些策略类</li>
</ul>
<p><code>策略模式</code>的主要缺点如下：</p>
<ul>
<li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法。换言之，策略模式只适用于客户端知道所有的算法或行为的情况</li>
<li>策略模式将造成系统产生很多具体策略类，任何细小的变化都将导致系统要增加一个新的具体策略类</li>
<li>无法同时在客户端使用多个策略类，也就是说，在使用策略模式时，客户端每次只能使用一个策略类，不支持使用一个策略类完成部分功能后再使用另一个策略类来完成剩余功能的情况</li>
</ul>
<p><code>策略模式</code>的使用场景如下：</p>
<ul>
<li>一个系统需要动态地在几种算法中选择一种，那么可以将这些算法封装到一个个的具体算法类中，而这些具体算法类都是一个抽象算法类的子类。换言之，这些具体算法类均有统一的接口，根据<code>里氏代换原则</code>和面向对象的多态性，客户端可以选择使用任何一个具体算法类，并只需要维持一个数据类型是抽象算法类的对象</li>
<li>一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重条件选择语句来实现。此时，使用策略模式，把这些行为转移到相应的具体策略类里面，就可以避免使用难以维护的多重条件选择语句</li>
<li>不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法与相关的数据结构，可以提高算法的保密性与安全性</li>
</ul>
<h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p><em><strong>意图：</strong></em> 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤<br><em><strong>解决的问题：</strong></em> 一些方法通用，却在每一个子类都重新写了这一方法<br><em><strong>角色：</strong></em> <code>模板方法模式</code>中有如下角色：</p>
<ul>
<li>抽象类（<code>AbstractClass</code>）：在抽象类中定义了一系列基本操作( <code>Primitive Operations</code>)，这些基本操作可以是具体的，也可以是抽象的，每一个基本操作对应算法的一个步骤，在其子类中可以重定义或实现这些步骤。同时，在抽象类中实现了一个模板方法(<code>Template Method</code>)，用于定义一个算法的框架，模板方法不仅可以调用在抽象类中实现的基本方法，也可以调用在抽象类的子类中实现的基本方法，还可以调用其他对象中的方法</li>
<li>具体子类（<code>ConcreteClass</code>）：它是抽象类的子类，用于实现在父类中声明的抽象基本操作以完成子类特定算法的步骤，也可以覆盖在父类中已经实现的具体基本操作</li>
</ul>
<p><code>模板方法模式</code>（<code>Template Method Pattern</code>）定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<code>模板方法模式</code>中各个角色的代码实现如下：</p>
<p>抽象类（<code>AbstractClass</code>）的代码实现；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomethingA</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomethingB</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (满足执行 A 的条件)&#123;</span><br><span class="line">            doSomethingA();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            doSomething();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体子类（<code>ConcreteClass</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteClassA</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doSomethingA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行 ConcreteClassA 的 A 操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doSomethingB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行 ConcreteClassA 的 B 操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteClassB</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doSomethingA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行 ConcreteClassB 的 A 操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doSomethingB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行 ConcreteClassB 的 B 操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用者代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractClass concreteClassA = <span class="keyword">new</span> ConcreteClassA();</span><br><span class="line">        concreteClassA.doSomething();</span><br><span class="line">        AbstractClass concreteClassB = <span class="keyword">new</span> ConcreteClassB();</span><br><span class="line">        concreteClassB.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>模板方法模式</code>的主要优点如下：</p>
<ul>
<li>在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序</li>
<li>模板方法模式是一种代码复用技术，它在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为，它鼓励我们恰当使用继承来实现代码复用</li>
<li>可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行</li>
<li>在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合<code>单一职责原则</code>和<code>开闭原则</code></li>
</ul>
<p><code>模板方法模式</code>的主要缺点如下：</p>
<p>需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象，此时，可结合桥接模式来进行设计。</p>
<p><code>模板方法模式</code>的使用场景：</p>
<ul>
<li>对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法和父类具体方法，而一些可以改变的细节由其子类来实现。即：一次性实现一个算法的不变部分，并将可变的行为留给子类来实现</li>
<li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复</li>
<li>需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制</li>
</ul>
<h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><p><em><strong>意图：</strong></em> 主要将数据结构与数据操作分离<br><em><strong>解决的问题：</strong></em> 稳定的数据结构和易变的操作耦合问题<br><em><strong>角色：</strong></em> <code>访问者模式</code>中有如下角色：</p>
<ul>
<li>抽象访问者（<code>Vistor</code>）：抽象访问者为对象结构中每一个具体元素类 <code>ConcreteElement</code> 声明一个访问操作，从这个操作的名称或参数类型可以清楚知道需要访问的具体元素的类型，具体访问者需要实现这些操作方法，定义对这些元素的访问操作</li>
<li>具体访问者（<code>ConcreteVisitor</code>）：具体访问者实现了每个由抽象访问者声明的操作，每一个操作用于访问对象结构中一种类型的元素</li>
<li>抽象元素（<code>Element</code>）：抽象元素一般是抽象类或者接口，它定义一个 <code>accept()</code>方法，该方法通常以一个抽象访问者作为参数</li>
<li>具体元素（<code>ConcreteElement</code>）：具体元素实现了 <code>accept()</code>方法，在 <code>accept()</code>方法中调用访问者的访问方法以便完成对一个元素的操作</li>
<li>对象结构（<code>ObjectStructure</code>）：对象结构是一个元素的集合，它用于存放元素对象，并且提供了遍历其内部元素的方法。它可以结合组合模式来实现，也可以是一个简单的集合对象，如一个 <code>List</code> 对象或一个 <code>Set</code> 对象</li>
</ul>
<p><code>访问者模式</code>(<code>Visitor Pattern</code>)：提供一个作用于某对象结构中的各元素的操作表示，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。访问者模式是一种对象行为型模式。<code>访问者模式</code>中各个角色的代码实现如下：</p>
<p>抽象访问者（<code>Vistor</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB able)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA able)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体访问者（<code>ConcreteVisitor</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitorA</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementB elementB)</span> </span>&#123;</span><br><span class="line">        elementB.operate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA elementA)</span> </span>&#123;</span><br><span class="line">        elementA.operate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象元素（<code>Element</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体元素（<code>ConcreteElement</code>）的代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteElementA</span> <span class="keyword">implements</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteElementA ....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteElementB</span> <span class="keyword">implements</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteElementB ....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用者代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Visitor visitor = <span class="keyword">new</span> ConcreteVisitorA();</span><br><span class="line">        List&lt;Element&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> ConcreteElementA());</span><br><span class="line">        list.add(<span class="keyword">new</span> ConcreteElementB());</span><br><span class="line">        <span class="keyword">for</span> (Element element : list) &#123;</span><br><span class="line">            element.accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>访问者模式</code>的主要优点如下：</p>
<ul>
<li>增加新的访问操作很方便。使用<code>访问者模式</code>，增加新的访问操作就意味着增加一个新的具体访问者类，实现简单，无须修改源代码，符合<code>开闭原则</code></li>
<li>将有关元素对象的访问行为集中到一个访问者对象中，而不是分散在一个个的元素类中。类的职责更加清晰，有利于对象结构中元素对象的复用，相同的对象结构可以供多个不同的访问者访问</li>
<li>让用户能够在不修改现有元素类层次结构的情况下，定义作用于该层次结构的操作</li>
</ul>
<p><code>访问者模式</code>的主要缺点如下：</p>
<ul>
<li>增加新的元素类很困难。在访问者模式中，每增加一个新的元素类都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作，这违背了<code>开闭原则</code>的要求</li>
<li>破坏封装。<code>访问者模式</code>要求访问者对象访问并调用每一个元素对象的操作，这意味着元素对象有时候必须暴露一些自己的内部操作和内部状态，否则无法供访问者访问</li>
</ul>
<p><code>访问模式</code>的使用场景如下：</p>
<ul>
<li>一个对象结构包含多个类型的对象，希望对这些对象实施一些依赖其具体类型的操作。在访问者中针对每一种具体的类型都提供了一个访问操作，不同类型的对象可以有不同的访问操作</li>
<li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作<code>污染</code>这些对象的类，也不希望在增加新操作时修改这些类。访问者模式使得我们可以将相关的访问操作集中起来定义在访问者类中，对象结构可以被多个不同的访问者类所使用，将对象本身与对象的访问操作分离</li>
<li>对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
