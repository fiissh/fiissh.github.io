<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android Studio 或 IntelliJ IDEA VM options</title>
    <url>/Android%20Studio%20%E6%88%96%20IntelliJ%20IDEA%20VM%20options.html</url>
    <content><![CDATA[<p>基于 64G 物理内存的 <code>Android Studio</code> 或者 <code>IntelliJ IDEA</code> 内存配置优化：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> custom Android Studio VM options, see https://developer.android.com/studio/intro/studio-config.html</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 控制内存garbage方式</span></span><br><span class="line">-server</span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始化的内存大小</span></span><br><span class="line">-Xms4096m</span><br><span class="line"><span class="meta">#</span><span class="bash"> 最大内存数</span></span><br><span class="line">-Xmx16384m</span><br><span class="line"><span class="meta">#</span><span class="bash"> PermSize 永久区的大小</span></span><br><span class="line">-XX:PermSize=2048m</span><br><span class="line">-XX:MaxPermSize=4096m</span><br><span class="line"><span class="meta">#</span><span class="bash"> 代码内存容量</span></span><br><span class="line">-XX:ReservedCodeCacheSize=2048m</span><br><span class="line">-XX:+UseCompressedOops</span><br><span class="line">-Dfile.encoding=UTF-8</span><br><span class="line"><span class="meta">#</span><span class="bash">-XX:+UseConcMarkSweepGC</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用并行收集算法</span></span><br><span class="line">-XX:+UseParNewGC</span><br><span class="line">-XX:SoftRefLRUPolicyMSPerMB=512</span><br><span class="line">-XX:CICompilerCount=8</span><br><span class="line">-Dsun.io.useCanonCaches=false</span><br><span class="line">-Dsun.io.useCanonPrefixCache=false</span><br><span class="line">-Djava.net.preferIPv4Stack=true</span><br><span class="line">-Djdk.http.auth.tunneling.disabledSchemes=&quot;&quot;</span><br><span class="line">-Djna.nosys=true</span><br><span class="line">-Djna.boot.library.path=</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:-OmitStackTraceInFastThrow</span><br><span class="line">-Djdk.attach.allowAttachSelf</span><br><span class="line">-Dkotlinx.coroutines.debug=off</span><br><span class="line">-Djdk.module.illegalAccess.silent=true</span><br><span class="line">-ea</span><br><span class="line">-da</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>IntelliJ IDEA</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>VM options</tag>
        <tag>idea.vmoptions</tag>
      </tags>
  </entry>
  <entry>
    <title>OutOfMemoryError:pthread_create failed 异常分析</title>
    <url>//2021/OutOfMemoryError-caused-by-pthread-create-failed.html</url>
    <content><![CDATA[<p><img src="./images/android.jpeg"></p>
<p>线上出现一些 <code>OutOfMemoryError</code>，经过分析崩溃数据，发现出现 <code>OOM</code> 时进程的可用空间还是非常大的。</p>
<p>从崩溃的堆栈信息中可以分析出引发该 <code>OOM</code> 的主要与 <code>OkHttp</code> 有关系，而业务场景中都是普通的数据请求（<code>JSON</code>），并没有使用 <code>Bitmap</code> 这一类的较大内存占用的资源。更何况，进程的可用内存空间还是很充足的。</p>
<p>虽然堆栈信息不尽相同，但是最终从大量堆栈 <code>LOG</code> 中分析出有价值的信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: pthread_create (1040KB stack) failed: Try again</span><br><span class="line">at java.lang.Thread.nativeCreate(Native Method)</span><br><span class="line">at java.lang.Thread.start(Thread.java:<span class="number">733</span>)</span><br><span class="line">at tech.fiissh.base.utils.c.u(SourceFile:<span class="number">7</span>)</span><br><span class="line">at tech.fiissh.base.common.e.c.a(SourceFile:<span class="number">40</span>)</span><br><span class="line">at tech.fiissh.base.common.e.c.a(SourceFile:<span class="number">156</span>)</span><br><span class="line">at tech.fiissh.base.common.e.b.a(SourceFile:<span class="number">30</span>)</span><br><span class="line">at tech.fiissh.base.common.e.b.a$<span class="number">1.</span>handleMessage(SourceFile:<span class="number">6</span>)</span><br><span class="line">at android.os.Handler.dispatchMessage(Handler.java:<span class="number">105</span>)</span><br><span class="line">at android.os.Looper.loop(Looper.java:<span class="number">164</span>)</span><br><span class="line">at android.app.ActivityThread.main(ActivityThread.java:<span class="number">6942</span>)</span><br><span class="line">at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:<span class="number">327</span>)</span><br><span class="line">at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:<span class="number">1374</span>)</span><br><span class="line"></span><br><span class="line">java.lang.OutOfMemoryErrorat java.lang.String.&lt;init&gt;(String.java:<span class="number">255</span>)</span><br><span class="line">at libcore.io.IoUtils$FileReader.toString(IoUtils.java:<span class="number">272</span>)</span><br><span class="line">at libcore.io.IoUtils.readFileAsString(IoUtils.java:<span class="number">114</span>)</span><br><span class="line">at com.android.org.conscrypt.CertPinManager.readPinFile(CertPinManager.java:<span class="number">111</span>)</span><br><span class="line">at com.android.org.conscrypt.CertPinManager.rebuild(CertPinManager.java:<span class="number">85</span>)</span><br><span class="line">at com.android.org.conscrypt.CertPinManager.&lt;init&gt;(CertPinManager.java:<span class="number">49</span>)</span><br><span class="line">at com.android.org.conscrypt.TrustManagerImpl.&lt;init&gt;(TrustManagerImpl.java:<span class="number">137</span>)</span><br><span class="line">at com.android.org.conscrypt.TrustManagerImpl.&lt;init&gt;(TrustManagerImpl.java:<span class="number">97</span>)</span><br><span class="line">at com.android.org.conscrypt.TrustManagerFactoryImpl.engineGetTrustManagers(TrustManagerFactoryImpl.java:<span class="number">80</span>)</span><br><span class="line">at javax.net.ssl.TrustManagerFactory.getTrustManagers(TrustManagerFactory.java:<span class="number">219</span>)</span><br><span class="line">at tech.fiissh.thrid.okhttp.internal.Util.platformTrustManager(Util.java:<span class="number">670</span>)</span><br><span class="line">at tech.fiissh.thrid.okhttp.OkHttpClient.&lt;init&gt;(OkHttpClient.java:<span class="number">256</span>)</span><br><span class="line">at tech.fiissh.thrid.okhttp.OkHttpClient$Builder.build(OkHttpClient.java:<span class="number">1035</span>)</span><br><span class="line">at tech.fiissh.base.common.net.e.b.&lt;init&gt;(OkHttpStack.java:<span class="number">73</span>)</span><br><span class="line">at tech.fiissh.base.common.net.g.&lt;init&gt;(NetworkDispatcher.java:<span class="number">51</span>)</span><br><span class="line">at tech.fiissh.base.common.net.i$<span class="number">1.</span>run(RequestQueue.java:<span class="number">110</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1112</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">587</span>)</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">841</span>)</span><br></pre></td></tr></table></figure>

<p>经过与源码文件进行比较，<code>OkHttpStack</code> 第73行的方法实际上是通过 <code>OkHttpClient.Builder</code> 来实例化一个 <code>OkHttpClient</code> 对象。</p>
<p>通常情况下我们所理解的 <code>OOM</code> 是由于进程的可用堆内存不够（即 <code>Runtime.getRuntime().maxMemory()</code> 小于需要申请的内存大小）的情况下系统会抛出 <code>OutOfMemoryError</code>。其报错信息中详细的记录了我们的内存分配需求和可用堆内存的大小信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Failed to allocate a XXX <span class="keyword">byte</span> allocation with XXX free bytes and XXXKB until OOM</span><br></pre></td></tr></table></figure>

<p>通过对 <code>pthread_create</code> 关键字的搜索，最终在 <a href="https://cs.android.com/android/platform/superproject/+/master:art/runtime/thread.cc">thread.cc</a> 中找到了抛出该异常的位置，并且通过对 <code>Thread::CreateNativeThread</code> 函数的分析发现，在创建线程时，系统会先判断当前线程数是否超过了系统对线程数的限制，如果超过该限制则抛出 <code>java.lang.OutOfMemoryError:pthread_create (XXXXKB stack) failed</code> 异常。</p>
<p>那么，问题的根源在哪里？通过对代码的分析，发现每次发起一个网络请求的时候都会创建一个 <code>OkHttpClient</code>，而每个 <code>OkHttpClient</code> 对象都会初始化一个线程池（线程的生命周期又较长），如果在短时间内发起多次请求，那么线程池会被创建多个，而线程数也会随之增加。解决的方案则是将 <code>OkHttpClient</code> 通过单例的方式对外提供。</p>
<p>针对上述线程创建的问题，可以参考 <a href="https://juejin.im/entry/59f7ea06f265da43143ffee4">不可思议的OOM</a>，作者针对出现类似问题的场景做了深入分析。</p>
<p>关于 <code>HTTPClient</code> 的问题，可以参考 <a href="https://www.jianshu.com/p/3b232d9f38c2">OkHttp竟然玩出OOM？</a>，作者针对为什么创建多个线程池的场景进行了深入的分析。</p>
]]></content>
      <categories>
        <category>Exception</category>
      </categories>
      <tags>
        <tag>OutOfMemoryError</tag>
      </tags>
  </entry>
</search>
