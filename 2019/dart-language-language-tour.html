<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/index.html/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/index.html/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/index.html/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/index.html/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="9KsIJJsvbiRMsjTEbN5fANhynVSesariRWUHacVYOD4">
  <meta name="baidu-site-verification" content="95yTtcGSv8">

<link rel="stylesheet" href="/index.html/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"fiissh.tech","root":"/index.html/","images":"/index.html/images","scheme":"Mist","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/index.html/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/index.html/js/config.js"></script>
<meta name="description" content="本文主要针对 Dart 语言的语法规则以及常用概念进行介绍，主要目标是快速了解 Dart 的主要特性。 本文中介绍的 Dart 语言特性是基于 Dart 2.1.0。由于肥肥本身从事于 Android 开发多年，使用 Java 作为主要开发语言，所以在整理、撰写本文时会选择性的忽略一些语言特性的介绍。 本文是基于官网文档 A Tour of the Dart Language以及 Dart 翻译小">
<meta property="og:type" content="article">
<meta property="og:title" content="Flutter 开发（00）：Dart 语言语法预览">
<meta property="og:url" content="https://fiissh.tech/index.html/2019/dart-language-language-tour.html">
<meta property="og:site_name" content="肥言肥语">
<meta property="og:description" content="本文主要针对 Dart 语言的语法规则以及常用概念进行介绍，主要目标是快速了解 Dart 的主要特性。 本文中介绍的 Dart 语言特性是基于 Dart 2.1.0。由于肥肥本身从事于 Android 开发多年，使用 Java 作为主要开发语言，所以在整理、撰写本文时会选择性的忽略一些语言特性的介绍。 本文是基于官网文档 A Tour of the Dart Language以及 Dart 翻译小">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-02-21T07:14:40.000Z">
<meta property="article:modified_time" content="2019-02-21T07:14:40.000Z">
<meta property="article:author" content="肥肥鱼">
<meta property="article:tag" content="Dart 语法预览">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://fiissh.tech/index.html/2019/dart-language-language-tour.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://fiissh.tech/index.html/2019/dart-language-language-tour.html","path":"/2019/dart-language-language-tour.html","title":"Flutter 开发（00）：Dart 语言语法预览"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Flutter 开发（00）：Dart 语言语法预览 | 肥言肥语</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-65174745-4"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-65174745-4","only_pageview":false}</script>
  <script src="/index.html/js/third-party/analytics/google-analytics.js"></script>

  <script src="/index.html/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?2ed36102ffe08627252774ba00c82600"></script>



  <noscript>
    <link rel="stylesheet" href="/index.html/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/index.html/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">肥言肥语</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">肥肥鱼胡说八道的地方</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/index.html/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-archives"><a href="/index.html/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.</span> <span class="nav-text">关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">2.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">内置类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.1.</span> <span class="nav-text">数字类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.2.</span> <span class="nav-text">字符串类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.3.</span> <span class="nav-text">布尔类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.4.</span> <span class="nav-text">数组类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.5.</span> <span class="nav-text">哈希类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Runes"><span class="nav-number">3.6.</span> <span class="nav-text">Runes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Symbols"><span class="nav-number">3.7.</span> <span class="nav-text">Symbols</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0"><span class="nav-number">4.1.</span> <span class="nav-text">可选参数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%80%89%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0"><span class="nav-number">4.1.1.</span> <span class="nav-text">可选命名参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%80%89%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="nav-number">4.1.2.</span> <span class="nav-text">可选位置参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%80%BC"><span class="nav-number">4.1.3.</span> <span class="nav-text">默认参数值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="nav-number">4.2.</span> <span class="nav-text">入口函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E6%96%B9%E6%B3%95"><span class="nav-number">4.3.</span> <span class="nav-text">匿名方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">4.4.</span> <span class="nav-text">静态作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AD%E5%8C%85%E8%AF%AD%E6%B3%95"><span class="nav-number">4.5.</span> <span class="nav-text">闭包语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">4.6.</span> <span class="nav-text">返回值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">5.</span> <span class="nav-text">操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">5.1.</span> <span class="nav-text">算术操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%89%E5%BC%8F%E4%B8%8E%E4%B8%8D%E7%AD%89%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">5.2.</span> <span class="nav-text">等式与不等式操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">5.3.</span> <span class="nav-text">类型判断操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">5.4.</span> <span class="nav-text">赋值操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">5.5.</span> <span class="nav-text">逻辑操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E7%A7%BB%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">5.6.</span> <span class="nav-text">位移操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">5.7.</span> <span class="nav-text">条件表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A7%E8%81%94%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">5.8.</span> <span class="nav-text">级联操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">5.9.</span> <span class="nav-text">其他操作符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">6.</span> <span class="nav-text">流程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#if-else-%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="nav-number">6.1.</span> <span class="nav-text">if-else 条件判断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for-%E5%BE%AA%E7%8E%AF"><span class="nav-number">6.2.</span> <span class="nav-text">for 循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#while-%E5%92%8C-do-while-%E5%BE%AA%E7%8E%AF"><span class="nav-number">6.3.</span> <span class="nav-text">while 和 do-while 循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#break-%E5%92%8C-continue"><span class="nav-number">6.4.</span> <span class="nav-text">break 和 continue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#switch-%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="nav-number">6.5.</span> <span class="nav-text">switch 条件判断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#assert"><span class="nav-number">6.6.</span> <span class="nav-text">assert</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">7.</span> <span class="nav-text">异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#throw"><span class="nav-number">7.1.</span> <span class="nav-text">throw</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#catch-%E6%88%96-on"><span class="nav-number">7.2.</span> <span class="nav-text">catch 或 on</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#finally"><span class="nav-number">7.3.</span> <span class="nav-text">finally</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-number">8.</span> <span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%AE%9E%E4%BE%8B"><span class="nav-number">8.1.</span> <span class="nav-text">变量实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">8.2.</span> <span class="nav-text">构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">8.2.1.</span> <span class="nav-text">默认构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">8.2.2.</span> <span class="nav-text">命名构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="nav-number">8.2.3.</span> <span class="nav-text">初始化列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">8.2.4.</span> <span class="nav-text">重定向构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">8.2.5.</span> <span class="nav-text">常量构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">8.2.6.</span> <span class="nav-text">工厂方法构造函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95-1"><span class="nav-number">8.3.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="nav-number">8.3.1.</span> <span class="nav-text">实例方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getter-%E5%92%8C-setter-%E6%96%B9%E6%B3%95"><span class="nav-number">8.3.2.</span> <span class="nav-text">getter 和 setter 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="nav-number">8.3.3.</span> <span class="nav-text">抽象方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E5%A4%8D%E5%86%99%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">8.3.4.</span> <span class="nav-text">可复写的操作符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">8.4.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="nav-number">8.5.</span> <span class="nav-text">实现接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E7%B1%BB"><span class="nav-number">8.6.</span> <span class="nav-text">扩展类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="nav-number">8.7.</span> <span class="nav-text">枚举类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E7%B1%BB%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-number">8.8.</span> <span class="nav-text">扩展类的功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">8.9.</span> <span class="nav-text">静态变量和静态方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="nav-number">8.9.1.</span> <span class="nav-text">静态变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">8.9.2.</span> <span class="nav-text">静态方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">9.</span> <span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B"><span class="nav-number">9.1.</span> <span class="nav-text">在构造函数中使用泛型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B"><span class="nav-number">9.2.</span> <span class="nav-text">限制泛型类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="nav-number">9.3.</span> <span class="nav-text">泛型方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%93%E5%92%8C%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">10.</span> <span class="nav-text">库和可见性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%BA%93"><span class="nav-number">10.1.</span> <span class="nav-text">使用库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E5%BA%93%E5%89%8D%E7%BC%80"><span class="nav-number">10.2.</span> <span class="nav-text">指定库前缀</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BC%E5%85%A5%E5%BA%93%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86"><span class="nav-number">10.3.</span> <span class="nav-text">导入库的一部分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E5%BA%93"><span class="nav-number">10.4.</span> <span class="nav-text">延迟加载库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E6%94%AF%E6%8C%81"><span class="nav-number">11.</span> <span class="nav-text">异步支持</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="nav-number">11.1.</span> <span class="nav-text">声明异步方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-await-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">11.2.</span> <span class="nav-text">使用 await 表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5-for-%E5%BE%AA%E7%8E%AF"><span class="nav-number">11.3.</span> <span class="nav-text">异步 for 循环</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Callable-classes"><span class="nav-number">12.</span> <span class="nav-text">Callable classes</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B"><span class="nav-number">12.1.</span> <span class="nav-text">协程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Typedefs"><span class="nav-number">12.2.</span> <span class="nav-text">Typedefs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Metadata"><span class="nav-number">12.3.</span> <span class="nav-text">Metadata</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A"><span class="nav-number">13.</span> <span class="nav-text">注释</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="肥肥鱼"
      src="/index.html/images/homercat.png">
  <p class="site-author-name" itemprop="name">肥肥鱼</p>
  <div class="site-description" itemprop="description">fiissh.zhao，肥肥鱼，Android SDK 开发</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/index.html/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/index.html/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/index.html/tags/">
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/fiissh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fiissh" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fiissh.zhao@gmail.com" title="E-Mail → mailto:fiissh.zhao@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fiissh.tech/index.html/2019/dart-language-language-tour.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/index.html/images/homercat.png">
      <meta itemprop="name" content="肥肥鱼">
      <meta itemprop="description" content="fiissh.zhao，肥肥鱼，Android SDK 开发">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肥言肥语">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Flutter 开发（00）：Dart 语言语法预览
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-21 15:14:40" itemprop="dateCreated datePublished" datetime="2019-02-21T15:14:40+08:00">2019-02-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/index.html/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>本文主要针对 <code>Dart</code> 语言的语法规则以及常用概念进行介绍，主要目标是快速了解 <code>Dart</code> 的主要特性。</p>
<p>本文中介绍的 <code>Dart</code> 语言特性是基于 <code>Dart 2.1.0</code>。由于肥肥本身从事于 <code>Android</code> 开发多年，使用 <code>Java</code> 作为主要开发语言，所以在整理、撰写本文时会选择性的忽略一些语言特性的介绍。</p>
<p>本文是基于官网文档 <a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/language/language-tour">A Tour of the Dart Language</a>以及 <a target="_blank" rel="noopener" href="http://dart.goodev.org/">Dart 翻译小组</a>翻译的 <a target="_blank" rel="noopener" href="http://dart.goodev.org/guides/language/language-tour">Dart 语法概览</a> 文档。</p>
<p>感谢先驱们对 <code>Dart</code> 社区做出的贡献，更感谢 <a target="_blank" rel="noopener" href="http://dart.goodev.org/">Dart 翻译小组</a>所付出的辛苦和贡献。</p>
<p>在 <code>Dart</code> 中一些重要的概念如下：</p>
<ul>
<li>所有的东西都是对象，所有的对象都是类的实例。即使数字、方法、<code>null</code> 也都是对象。所有的对象都继承自 <code>Object</code> 类</li>
<li>指定静态类型表明你的意图，并使检查类型检查成为可能</li>
<li><code>Dart</code> 在运行前解析所有的代码，可以使用些小技巧，例如：通过使用类型或编译时常量，来捕捉错误或使代码运行的更快</li>
<li><code>Dart</code> 支持顶级的函数，也支持类或对象的静态和实例方法。也可以在函数内部嵌套函数或本地函数</li>
<li><code>Dart</code> 支持顶级的变量，也支持类或对象的静态变量和实例变量(也被称作字段或属性)</li>
<li><code>Dart</code> 没有 <code>public</code>、<code>protected</code>、<code>private</code> 等关键字，如果一个标识符以 <code>_</code> 开头则表示私有</li>
<li>标识符以小写字母或下划线 <code>_</code> 开头，后面跟着字符和数字的任意组合</li>
<li><code>Dart</code> 中，明确区分表达式和语句</li>
<li><code>Dart tools</code> 会报告两种类型的问题：警告(<code>warnings</code>)和错误(<code>errors</code>)。警告仅标志着你的代码可能不会工作，但并不会阻止程序执行；错误可能是编译时错误，也可能是运行时错误。编译时错误会阻止程序执行；运行时错误会在程序执行时抛出异常</li>
<li><code>Dart</code> 有两种运行时模式：生产模式和检查模式。推荐在开发和 <code>debug</code> 时使用检查模式，生产环境中生产模式。生产模式是 <code>Dart</code> 程序默认的运行时模式</li>
</ul>
<span id="more"></span>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p><code>Dart</code> 语言中有三种类型的关键字：</p>
<ul>
<li>内置关键字：内置关键字的主要用作是方便 <code>JavaScript</code> 的代码向 <code>Dart</code> 移植，见下表<font color="red">红色字体</font>所示关键字</li>
<li>异步相关的关键字：<code>Dart 1.0</code> 之后为了支持异步特性而增加的关键字，见下表<font color="green">绿色字体</font>所示关键字</li>
<li>保留关键字：上述两种关键字之外的其他关键字为保留关键字，见下表<font color="blue">蓝色色字体</font>所示关键字</li>
</ul>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">关键字</th>
<th align="center">关键字</th>
<th align="center">关键字</th>
<th align="center">关键字</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><font color="red">abstract</font></td>
<td align="center"><font color="blue">continue</font></td>
<td align="center"><font color="blue">false</font></td>
<td align="center"><font color="blue">new</font></td>
<td align="center"><font color="blue">this</font></td>
</tr>
<tr>
<td align="center"><font color="red">as</font></td>
<td align="center"><font color="blue">default</font></td>
<td align="center"><font color="blue">final</font></td>
<td align="center"><font color="blue">null</font></td>
<td align="center"><font color="blue">throw</font></td>
</tr>
<tr>
<td align="center"><font color="blue">assert</font></td>
<td align="center"><font color="red">deferred</font></td>
<td align="center"><font color="blue">finally</font></td>
<td align="center"><font color="red">operator</font></td>
<td align="center"><font color="blue">true</font></td>
</tr>
<tr>
<td align="center"><font color="green">async</font></td>
<td align="center"><font color="blue">do</font></td>
<td align="center"><font color="blue">for</font></td>
<td align="center"><font color="red">part</font></td>
<td align="center"><font color="blue">try</font></td>
</tr>
<tr>
<td align="center"><font color="green">async*</font></td>
<td align="center"><font color="red">dynamic</font></td>
<td align="center"><font color="red">get</font></td>
<td align="center"><font color="blue">rethrow</font></td>
<td align="center"><font color="red">typedef</font></td>
</tr>
<tr>
<td align="center"><font color="green">await</font></td>
<td align="center"><font color="blue">else</font></td>
<td align="center"><font color="blue">if</font></td>
<td align="center"><font color="blue">return</font></td>
<td align="center"><font color="blue">var</font></td>
</tr>
<tr>
<td align="center"><font color="blue">break</font></td>
<td align="center"><font color="blue">enum</font></td>
<td align="center"><font color="red">implements</font></td>
<td align="center"><font color="red">set</font></td>
<td align="center"><font color="blue">void</font></td>
</tr>
<tr>
<td align="center"><font color="blue">case</font></td>
<td align="center"><font color="red">export</font></td>
<td align="center"><font color="red">import</font></td>
<td align="center"><font color="red">static</font></td>
<td align="center"><font color="blue">while</font></td>
</tr>
<tr>
<td align="center"><font color="blue">catch</font></td>
<td align="center"><font color="red">external</font></td>
<td align="center"><font color="blue">in</font></td>
<td align="center"><font color="blue">super</font></td>
<td align="center"><font color="blue">with</font></td>
</tr>
<tr>
<td align="center"><font color="blue">class</font></td>
<td align="center"><font color="blue">extends</font></td>
<td align="center"><font color="blue">is</font></td>
<td align="center"><font color="blue">switch</font></td>
<td align="center"><font color="green">yield</font></td>
</tr>
<tr>
<td align="center"><font color="blue">const</font></td>
<td align="center"><font color="red">factory1</font></td>
<td align="center"><font color="red">library</font></td>
<td align="center"><font color="green">sync*</font></td>
<td align="center"><font color="green">yield*</font></td>
</tr>
</tbody></table>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>可以使用 <code>var</code> 声明一个变量，编译器会自动推导其变量类型：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;fiissh.zhao&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上述代码表示，一个名字为 <code>name</code> 的变量引用了一个内容为 <code>fiissh.zhao</code> 的 <code>String</code> 对象。</p>
<p>相应的，我们可以使用具体的类型来声明一个变量：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> name = <span class="string">&#x27;fiissh.zhao&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果一个变量声明之后，我们将不会对变量产生修改，那么可以使用 <code>final</code> 或 <code>const</code> 关键字修饰变量：</p>
<ul>
<li>一个使用 <code>final</code> 修饰的变量只能被赋值一次</li>
<li>一个使用 <code>const</code> 修饰的变量指的是编译时常量</li>
</ul>
<blockquote>
<p>默认的，<code>Dart</code> 中没有初始化的变量将获得默认值 <code>null</code>。这与 <code>Java</code> 中的 <code>Object</code> 类型的对象的默认值是一样的。需要注意的是，与 <code>Java</code> 相比，<code>Dart</code> 中所有的对象（包括数字、方法以及 <code>null</code>）都继承自 <code>Object</code> 类。<br><code>Dart</code> 中 <code>final</code> 的用法与 <code>Java</code> 中的 <code>final</code> 的用法相似，都是表示一个不可变的变量。<code>Dart</code> 中 <code>const</code> 的用法则与 <code>Java</code> 中的 <code>static final</code> 的用法相似，用于表示一个常量。关于 <code>final</code> 和 <code>const</code> 的使用此处不做过多介绍。</p>
</blockquote>
<h2 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h2><p><code>Dart</code> 支持如下内置类型：</p>
<ul>
<li>数字类型</li>
<li>字符串类型</li>
<li>布尔类型</li>
<li>数组类型</li>
<li>哈希类型</li>
<li><code>runes</code></li>
<li><code>symbols</code></li>
</ul>
<h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><p><code>Dart</code> 支持如下两种类型的数字：</p>
<ul>
<li><code>int</code>：整型数值，其取值范围为 $ -2^{53} $ 到 $ 2^{53} $ 之间</li>
<li><code>double</code>：64位双精度浮点数，符合 <code>IEEE 754</code> 标准</li>
</ul>
<blockquote>
<p><code>int</code> 和 <code>double</code> 都是 <code>num</code> 的子类。<code>num</code> 类定义了基本的操作。如果 <code>num</code> 中定义的操作不能满足需求，则可以考虑使用 <code>dart:math</code> 库。<br><code>String</code> 类型的数据与 <code>num</code> 类型的相互转换可以通过 <code>num</code> 的 <code>parse</code> 方法和 <code>toString</code> 方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String -&gt; int</span></span><br><span class="line"><span class="keyword">var</span> one = <span class="built_in">int</span>.parse(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// String -&gt; double</span></span><br><span class="line"><span class="keyword">var</span> onePointOne = <span class="built_in">double</span>.parse(<span class="string">&#x27;1.1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// int -&gt; String</span></span><br><span class="line"><span class="built_in">String</span> oneAsString = <span class="number">1.</span>toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// double -&gt; String</span></span><br><span class="line"><span class="built_in">String</span> piAsString = <span class="number">3.14159</span>.toStringAsFixed(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>与 <code>Java</code> 一样，<code>int</code> 类型的数据的可以支持位移操作：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>((<span class="number">3</span> &lt;&lt; <span class="number">1</span>) == <span class="number">6</span>);  <span class="comment">// 0011 &lt;&lt; 1 == 0110</span></span><br><span class="line"><span class="keyword">assert</span>((<span class="number">3</span> &gt;&gt; <span class="number">1</span>) == <span class="number">1</span>);  <span class="comment">// 0011 &gt;&gt; 1 == 0001</span></span><br><span class="line"><span class="keyword">assert</span>((<span class="number">3</span> | <span class="number">4</span>)  == <span class="number">7</span>);  <span class="comment">// 0011 | 0100 == 0111</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>assert</code> 表示断言。断言只在检查模式下有效，而在生产模式则无效。</p>
</blockquote>
<p>使用 <code>const</code> 修饰的数值类型，其数学运算的结果也是 <code>const</code> 类型的：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> msPerSecond = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> secondsUntilRetry = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> msUntilRetry = secondsUntilRetry * msPerSecond;</span><br></pre></td></tr></table></figure>

<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p><code>Dart</code> 中字符串使用 <code>UTF-16</code> 编码，可以使用单引号（<code>&#39;&#39;</code>）或者双引号（<code>&quot;&quot;</code>）来初始化：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&#x27;Single quotes work well for string literals.&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">&quot;Double quotes work just as well.&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> s3 = <span class="string">&#x27;It\&#x27;s easy to escape the string delimiter.&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> s4 = <span class="string">&quot;It&#x27;s even easier to use the other delimiter.&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>如果需要在字符串中使用表达式，可以使用 <code>$&#123;expression&#125;</code>。如果表达式的结果是一个非字符串对象，那么可以使用 <code>toString</code> 来获取字符串：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;string interpolation&#x27;</span>;</span><br><span class="line"><span class="keyword">assert</span>(<span class="string">&#x27;Dart has <span class="subst">$s</span>, which is very handy.&#x27;</span> ==</span><br><span class="line">       <span class="string">&#x27;Dart has string interpolation, &#x27;</span> +</span><br><span class="line">       <span class="string">&#x27;which is very handy.&#x27;</span>);</span><br><span class="line"><span class="keyword">assert</span>(<span class="string">&#x27;That deserves all caps. &#x27;</span> +</span><br><span class="line">       <span class="string">&#x27;<span class="subst">$&#123;s.toUpperCase()&#125;</span> is very handy!&#x27;</span> ==</span><br><span class="line">       <span class="string">&#x27;That deserves all caps. &#x27;</span> +</span><br><span class="line">       <span class="string">&#x27;STRING INTERPOLATION is very handy!&#x27;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，<code>==</code> 操作符判断两个对象的内容是否一样。如果两个字符串包含一样的字符编码序列， 则他们是相等的。使用 <code>+</code> 操作符可以把多个字符串拼接为一个字符串。而且，如果字符串中使用的表达式仅仅是一个标识符，那么可以省略 <code>&#123;&#125;</code></p>
</blockquote>
<p>使用三个单引号（<code>&#39;&#39;&#39;</code>）或者双引号（<code>&quot;&quot;&quot;</code>）可以创建一个多行的字符串对象：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">You can create</span></span><br><span class="line"><span class="string">multi-line strings like this one.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">&quot;&quot;&quot;This is also a</span></span><br><span class="line"><span class="string">multi-line string.&quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>通过提供一个 <code>r</code> 前缀可以创建一个<code>原始 raw</code> 字符串：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">r&quot;In a raw string, even \n isn&#x27;t special.&quot;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于<code>原始 raw</code> 字符串，将会在 <code>Runes</code> 相关的章节中介绍。</p>
</blockquote>
<p>与 <code>num</code> 类型相似的，如果使用 <code>const</code> 修饰 <code>Strings</code> 类型，其运算结果也是 <code>const</code> 类型：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> aConstNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> aConstBool = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">const</span> aConstString = <span class="string">&#x27;a constant string&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> validConstString = <span class="string">&#x27;<span class="subst">$aConstNum</span> <span class="subst">$aConstBool</span> <span class="subst">$aConstString</span>&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p><code>Dart</code> 使用 <code>bool</code> 类型的子类型 <code>true</code> 和 <code>false</code> 表示布尔类型的数据，而且他们都是 <code>const</code> 类型的。</p>
<p>在 <code>Dart</code> 中，只有 <code>true</code> 对象才被真正认定为 <code>true</code>，其他的所有的对象都是 <code>false</code>。</p>
<h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p><code>Dart</code> 中使用的数组对象是 <code>List</code>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span> , <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>与 <code>Java</code> 中的数组一样，<code>Dart</code> 中的 <code>List</code> 下标索引也是从 0 开始的，而且索引数据的方式也与数组类似：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(i == <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>如果在 <code>List</code> 的初始化时使用 <code>const</code> 修饰，那么可以创建一个不变的 <code>List</code> 对象：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="keyword">const</span> [<span class="number">1</span> , <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<h3 id="哈希类型"><a href="#哈希类型" class="headerlink" title="哈希类型"></a>哈希类型</h3><p><code>Dart</code> 中使用的键值类型是 <code>Map</code>：</p>
<ul>
<li>键和值可以是任何类型的对象</li>
<li>每个键只能出现一次，而值则可以出现多次</li>
</ul>
<p>可以使用如下两种方式声明一个 <code>Map</code> 对象：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gifts = &#123;</span><br><span class="line"><span class="comment">// Keys      Values</span></span><br><span class="line">  <span class="string">&#x27;first&#x27;</span> : <span class="string">&#x27;partridge&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;second&#x27;</span>: <span class="string">&#x27;turtledoves&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;fifth&#x27;</span> : <span class="string">&#x27;golden rings&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gifts = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">gifts[<span class="string">&#x27;first&#x27;</span>] = <span class="string">&#x27;partridge&#x27;</span>;</span><br><span class="line">gifts[<span class="string">&#x27;second&#x27;</span>] = <span class="string">&#x27;turtledoves&#x27;</span>;</span><br><span class="line">gifts[<span class="string">&#x27;fifth&#x27;</span>] = <span class="string">&#x27;golden rings&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>相应的，可以通过如下方式读取 <code>Map</code> 中的对象：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> object = gifts[<span class="string">&#x27;first&#x27;</span>];</span><br></pre></td></tr></table></figure>

<p>如果在 <code>Map</code> 的初始化时使用 <code>const</code> 修饰，那么可以创建一个不变的 <code>Map</code> 对象：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> constantMap = <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="number">2</span>: <span class="string">&#x27;helium&#x27;</span>,</span><br><span class="line">  <span class="number">10</span>: <span class="string">&#x27;neon&#x27;</span>,</span><br><span class="line">  <span class="number">18</span>: <span class="string">&#x27;argon&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Runes"><a href="#Runes" class="headerlink" title="Runes"></a>Runes</h3><p>在 <code>Dart</code> 中，<code>runes</code> 代表字符串的 <code>UTF-32</code> 编码。</p>
<blockquote>
<p><code>Unicode</code> 为每一个字符、标点符号、表情符号等都定义了 一个唯一的数值。 由于 <code>Dart</code> 字符串是 <code>UTF-16</code> 字符编码，，所以如果在字符串中表达 <code>32-bit Unicode</code>（即 <code>UTF-32</code> 编码） 值就需要 新的语法了。</p>
</blockquote>
<p>通常使用 <code>\uXXXX</code> 的方式来表示 <code>Unicode</code> 编码（<code>XXXX</code> 表示4个16进制的数）。 例如，心形符号 (♥) 是 <code>\u2665</code>。对于那么不是4个数值的情况， 把编码值放到大括号中即可。 例如，笑脸 <code>emoji</code> (😆) 是 <code>\u&#123;1f600&#125;</code>。</p>
<p><code>String</code> 类有一些属性可以提取 <code>runes</code> 信息。 <code>codeUnitAt</code> 和 <code>codeUnit</code> 属性返回 <code>UTF-16</code> 编码。</p>
<p>下列实例演示了 <code>runes</code>、<code>UTF-16</code> 编码 和 <code>UTF-32</code> 编码之间的关系：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> clapping = <span class="string">&#x27;\u&#123;1f44f&#125;&#x27;</span>;</span><br><span class="line">  <span class="built_in">print</span>(clapping);</span><br><span class="line">  <span class="built_in">print</span>(clapping.codeUnits);</span><br><span class="line">  <span class="built_in">print</span>(clapping.runes.toList());</span><br><span class="line"></span><br><span class="line">  Runes input = <span class="keyword">new</span> Runes(</span><br><span class="line">      <span class="string">&#x27;\u2665  \u&#123;1f605&#125;  \u&#123;1f60e&#125;  \u&#123;1f47b&#125;  \u&#123;1f596&#125;  \u&#123;1f44d&#125;&#x27;</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="keyword">new</span> <span class="built_in">String</span>.fromCharCodes(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行之后输出：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">👏</span><br><span class="line">[55357, 56399]</span><br><span class="line">[128079]</span><br><span class="line">♥  😅  😎  👻  🖖  👍</span><br></pre></td></tr></table></figure>

<h3 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h3><p>在 <code>Dart</code> 中，一个 <code>Symbol</code> 对象表示程序中声明的操作符和标识符。在标识符前面增加一个 <code>#</code> 用于表示 <code>Symbol</code> 对象：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#radix</span><br><span class="line">#bar</span><br></pre></td></tr></table></figure>

<p>在 <code>Dart</code>中，<code>Symbol</code> 是使用较少的特性。在混淆之后的代码中，由于使用 <code>Symbol</code> 的名字不会改变，这使得我们可以方便的使用名字来引用标识符。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>在 <code>Dart</code> 中，方法是 <code>Function</code> 对象，这也就意味着我们可以给方法赋值，甚至可以把方法作为参数进行传递。</p>
<p>方法的定义方式如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isNoble(<span class="built_in">int</span> atomicNumber) &#123;</span><br><span class="line">  <span class="keyword">return</span> _nobleGases[atomicNumber] != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，我们也可以忽略方法返回值和参数列表的类型定义：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isNoble(atomicNumber) &#123;</span><br><span class="line">  <span class="keyword">return</span> _nobleGases[atomicNumber] != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于只有一个表达式的方法，你可以选择 使用缩写语法来定义：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isNoble(<span class="built_in">int</span> atomicNumber) =&gt; _nobleGases[atomicNumber] != <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>这个 <code>=&gt;</code> 语法是 <code>&#123; return expr; &#125;</code> 形式的缩写。</p>
<p>方法可以有两种类型的参数：必需的和可选的。 必需的参数在参数列表前面，后面是可选参数。</p>
<h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>可选参数可以是命名参数或者基于位置的参数，但是这两种参数不能同时当做可选参数。</p>
<h4 id="可选命名参数"><a href="#可选命名参数" class="headerlink" title="可选命名参数"></a>可选命名参数</h4><p>调用方法的时候，我们可以使用 <code>param_name:value</code> 的形式来指定命名参数：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enableFlags(bold: <span class="keyword">true</span>, hidden: <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<p>在定义方法的时候，可以使用 <code>&#123;param_1,param_2,param_3,...&#125;</code> 的形式来指定命名参数：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enableFlags(&#123;<span class="built_in">bool</span> bold, <span class="built_in">bool</span> hidden&#125;) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可选位置参数"><a href="#可选位置参数" class="headerlink" title="可选位置参数"></a>可选位置参数</h4><p>把一些方法的参数放到 <code>[]</code> 中就可以变成可选位置参数：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> say(<span class="built_in">String</span> from, <span class="built_in">String</span> msg, [<span class="built_in">String</span> device]) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">&#x27;<span class="subst">$from</span> says <span class="subst">$msg</span>&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (device != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">&#x27;<span class="subst">$result</span> with a <span class="subst">$device</span>&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是不使用可选位置参数调用上述方法的示例：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>(say(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Howdy&#x27;</span>) == <span class="string">&#x27;Bob says Howdy&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>下面是使用可选位置参数调用上述方法的示例：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>(say(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Howdy&#x27;</span>, <span class="string">&#x27;smoke signal&#x27;</span>) == <span class="string">&#x27;Bob says Howdy with a smoke signal&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h4><p>在定义方法的时候，可以使用 <code>=</code> 来定义可选参数的默认值。默认值只能是 <code>const</code> 类型（编译时常量）。如果没有提供默认值，那么参数默认为 <code>null</code>。</p>
<p>下面是为可选命名参数设置默认值的示例：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> enableFlags(&#123;<span class="built_in">bool</span> bold = <span class="keyword">false</span>, <span class="built_in">bool</span> hidden = <span class="keyword">false</span>&#125;) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是为可选位置参数设置默认值的示例：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> say(<span class="built_in">String</span> from, <span class="built_in">String</span> msg,</span><br><span class="line">    [<span class="built_in">String</span> device = <span class="string">&#x27;carrier pigeon&#x27;</span>, <span class="built_in">String</span> mood]) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">&#x27;<span class="subst">$from</span> says <span class="subst">$msg</span>&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (device != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">&#x27;<span class="subst">$result</span> with a <span class="subst">$device</span>&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (mood != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">&#x27;<span class="subst">$result</span> (in a <span class="subst">$mood</span> mood)&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面示例是当方法中使用了 <code>List</code> 或 <code>Map</code> 时设置默认值的方式：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> doStuff(</span><br><span class="line">    &#123;<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">const</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; gifts = <span class="keyword">const</span> &#123;</span><br><span class="line">      <span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;paper&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;second&#x27;</span>: <span class="string">&#x27;cotton&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;third&#x27;</span>: <span class="string">&#x27;leather&#x27;</span></span><br><span class="line">    &#125;&#125;) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;list:  <span class="subst">$list</span>&#x27;</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;gifts: <span class="subst">$gifts</span>&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h3><p>每一个 <code>Dart</code> 应用程序都有一个顶级的 <code>main()</code> 方法的入口才能运行。<code>main()</code> 方法的返回值为 <code>void</code> 并且有一个可选的 <code>List&lt;String&gt;</code> 参数：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello <span class="subst">$i</span>&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名方法"><a href="#匿名方法" class="headerlink" title="匿名方法"></a>匿名方法</h3><p>在 <code>Dart</code> 中。大部分方法是有名字的，例如 <code>main()</code> 方法。但是我们也可以创建一个匿名方法（也称为 <code>lambda</code> 或者 <code>closure</code> 闭包）：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">([[<span class="built_in">Type</span>] param1[, …]]) &#123;</span><br><span class="line">  codeBlock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>与非匿名方法类似的，我们可以在括号之间定义一些参数，参数之间使用逗号分隔，而大括号之间则是方法体。</p>
<p>下面的代码定义了一个参数为 <code>i</code>（该参数没有指定类型）的匿名方法。<code>list</code> 中的每个元素都会调用这个函数来 打印出来，同时来计算了每个元素在 <code>list</code> 中的索引位置：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="string">&#x27;apples&#x27;</span>, <span class="string">&#x27;oranges&#x27;</span>, <span class="string">&#x27;grapes&#x27;</span>, <span class="string">&#x27;bananas&#x27;</span>, <span class="string">&#x27;plums&#x27;</span>];</span><br><span class="line">list.forEach((i) &#123;</span><br><span class="line">  <span class="built_in">print</span>(list.indexOf(i).toString() + <span class="string">&#x27;: &#x27;</span> + i);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="静态作用域"><a href="#静态作用域" class="headerlink" title="静态作用域"></a>静态作用域</h3><p>由于 <code>Dart</code> 是静态语言，所以变量的作用域在写代码的时候就已经确定了。通常情况下，大括号中定义的变量只能在大括号中访问，其作用域与 <code>Java</code> 类似。</p>
<p>下面是作用域的一个示例：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> topLevel = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> insideMain = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  myFunction() &#123;</span><br><span class="line">    <span class="keyword">var</span> insideFunction = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    nestedFunction() &#123;</span><br><span class="line">      <span class="keyword">var</span> insideNestedFunction = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">assert</span>(topLevel);</span><br><span class="line">      <span class="keyword">assert</span>(insideMain);</span><br><span class="line">      <span class="keyword">assert</span>(insideFunction);</span><br><span class="line">      <span class="keyword">assert</span>(insideNestedFunction);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，<code>nestedFunction()</code> 可以访问所有的变量，包含顶级变量。</p>
</blockquote>
<h3 id="闭包语法"><a href="#闭包语法" class="headerlink" title="闭包语法"></a>闭包语法</h3><p>一个闭包是一个方法对象，不管该对象在何处被调用，该对象都可以访问其作用域内的变量。方法可以封闭定义在其作用域内的变量：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span> makeAdder(<span class="built_in">num</span> addBy) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">num</span> i) =&gt; addBy + i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="comment">// Create a function that adds 2.</span></span><br><span class="line">  <span class="keyword">var</span> add2 = makeAdder(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a function that adds 4.</span></span><br><span class="line">  <span class="keyword">var</span> add4 = makeAdder(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">assert</span>(add2(<span class="number">3</span>) == <span class="number">5</span>);</span><br><span class="line">  <span class="keyword">assert</span>(add4(<span class="number">3</span>) == <span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>makeAdder()</code> 捕获到了变量 <code>addBy</code>，不管我们在何处执行 <code>makeAdder()</code> 方法所返回的方法（<code>(num i) =&gt; addBy + i</code>），都可以使用 <code>addBy</code> 参数。</p>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>在 <code>Dart</code> 中，所有的方法都有返回值。如果没有指定返回值，则默认把 <code>return null;</code> 作为方法最后一行的语句执行。</p>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>下表展示了 <code>Dart</code> 中定义的操作符：</p>
<table>
<thead>
<tr>
<th>描述</th>
<th>操作符</th>
</tr>
</thead>
<tbody><tr>
<td>unary postfix</td>
<td><code>expr++</code>、<code>expr--</code>，<code>()</code>、<code>[]</code>、<code>.</code>、<code>?.</code></td>
</tr>
<tr>
<td>unary prefix</td>
<td><code>-expr</code>、<code>!expr</code>、<code>~expr</code>、<code>++expr</code>、<code>--expr</code></td>
</tr>
<tr>
<td>multiplicative</td>
<td><code>*</code>、<code>/</code>、<code>%</code>、<code>~/</code></td>
</tr>
<tr>
<td>additive</td>
<td><code>+</code>、<code>-</code></td>
</tr>
<tr>
<td>shift</td>
<td><code>&lt;&lt;</code>、<code>&gt;&gt;</code></td>
</tr>
<tr>
<td>bitwise AND</td>
<td><code>&amp;</code></td>
</tr>
<tr>
<td>bitwise XOR</td>
<td><code>^</code></td>
</tr>
<tr>
<td>bitwise OR</td>
<td>`</td>
</tr>
<tr>
<td>relational and type test</td>
<td><code>&gt;=</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&lt;</code>、<code>as</code>、<code>is</code>、<code>is!</code></td>
</tr>
<tr>
<td>equality</td>
<td><code>==</code>、<code>!=</code></td>
</tr>
<tr>
<td>logical AND</td>
<td><code>&amp;&amp;</code></td>
</tr>
<tr>
<td>logical OR</td>
<td>`</td>
</tr>
<tr>
<td>if null</td>
<td><code>??</code></td>
</tr>
<tr>
<td>conditional</td>
<td><code>expr1 ? expr2 : expr3</code></td>
</tr>
<tr>
<td>cascade</td>
<td><code>..</code></td>
</tr>
<tr>
<td>assignment</td>
<td><code>=</code>、<code>*=</code>、<code>/=</code>、<code>~/=</code>、<code>%=</code>、<code>+=</code>、<code>-=</code>、<code>&lt;&lt;=</code>、<code>&gt;&gt;=</code>、<code>&amp;=</code>、<code>^=</code>、`</td>
</tr>
</tbody></table>
<p>上述表格所列的操作符都是按照优先级顺序从左到右，从上到下的方式来列出的，上面和左边的操作符优先级要高于下面和右边的。</p>
<p>例如 <code>%</code> 操作符优先级高于 <code>==</code>，而 <code>==</code> 高于 <code>&amp;&amp;</code>。所以下面的代码结果是一样的：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1: Parens improve readability.</span></span><br><span class="line"><span class="keyword">if</span> ((n % i == <span class="number">0</span>) &amp;&amp; (d % i == <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2: Harder to read, but equivalent.</span></span><br><span class="line"><span class="keyword">if</span> (n % i == <span class="number">0</span> &amp;&amp; d % i == <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="算术操作符"><a href="#算术操作符" class="headerlink" title="算术操作符"></a>算术操作符</h3><p><code>Dart</code> 支持常见的算术操作符：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td>加号</td>
</tr>
<tr>
<td><code>-</code></td>
<td>减号</td>
</tr>
<tr>
<td><code>-expr</code></td>
<td>负号</td>
</tr>
<tr>
<td><code>*</code></td>
<td>乘号</td>
</tr>
<tr>
<td><code>/</code></td>
<td>除号</td>
</tr>
<tr>
<td><code>~/</code></td>
<td>除号（返回值为0）</td>
</tr>
<tr>
<td><code>%</code></td>
<td>取模</td>
</tr>
<tr>
<td><code>++</code></td>
<td>自增操作</td>
</tr>
<tr>
<td><code>--</code></td>
<td>自减操作</td>
</tr>
</tbody></table>
<blockquote>
<p>需要注意的是，<code>++</code> 和 <code>--</code> 操作符在变量的前后位置不一样，其运算过程不一样。例如 <code>++var</code> 和 <code>var++</code> 运算，其表达式都等同于 <code>var = var +1</code>。但是 <code>++var</code> 运算时先执行 <code>var + 1</code> 然后再执行运算，而 <code>var++</code> 则正好相反，是先执行运算操作，然后再执行 <code>var + 1</code> 操作。这与 <code>Java</code> 中的自增自减运算是一致的。</p>
</blockquote>
<h3 id="等式与不等式操作符"><a href="#等式与不等式操作符" class="headerlink" title="等式与不等式操作符"></a>等式与不等式操作符</h3><p><code>Dart</code> 支持常见的等式与不等式操作符：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>==</code></td>
<td>相等</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>不相等</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于</td>
</tr>
</tbody></table>
<p>如果需要比较两个对象是否为同样的内容，使用 <code>==</code> 操作符。下面是 == 操作符工作原理解释：</p>
<ul>
<li>如果 <code>x</code> 或 <code>y</code> 是 <code>null</code>，如果两个都是 <code>null</code> 则返回 <code>true</code>，如果 只有一个是 <code>null</code> 返回 <code>false</code></li>
<li>返回如下函数的返回值 <code>x.==(y)</code></li>
</ul>
<blockquote>
<p>在某些情况下，如果我们需要判断两个对象是否是同一个对象，则使用 <code>identical()</code> 方法。</p>
</blockquote>
<h3 id="类型判断操作符"><a href="#类型判断操作符" class="headerlink" title="类型判断操作符"></a>类型判断操作符</h3><p><code>Dart</code> 支持如下类型判断操作符：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>as</code></td>
<td>类型转换</td>
</tr>
<tr>
<td><code>is</code></td>
<td>如果对象是指定的类型返回 <code>true</code></td>
</tr>
<tr>
<td><code>is!</code></td>
<td>如果对象是指定的类型返回 <code>false</code></td>
</tr>
</tbody></table>
<p>只有当 <code>obj</code> 实现了 <code>T</code> 的接口， <code>obj is T</code> 才会返回 <code>true</code>。例如 <code>obj is Object</code> 总是返回 <code>true</code>。</p>
<p>使用 <code>as</code> 操作符把对象转换为特定的类型。一般情况下，你可以把它当做用 <code>is</code> 判定类型然后调用所判定对象的方法的缩写形式。例如下面的示例：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (emp <span class="keyword">is</span> Person) &#123; <span class="comment">// Type check</span></span><br><span class="line">  emp.firstName = <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>as</code> 操作符可以简化上面的代码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(emp <span class="keyword">as</span> Person).firstName = <span class="string">&#x27;Bob&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，上述两个代码片段是有区别的，如果 <code>emp</code> 为 <code>null</code> 或者不是 <code>Person</code> 类型，第一个代码片段的 <code>if</code> 判断就不会成立，<code>emp.firstName = &#39;Bob&#39;;</code> 则不会被执行。而第二个代码片段则会抛出一个异常。</p>
</blockquote>
<h3 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h3><p><code>Dart</code> 支持使用 <code>=</code> 和 <code>??=</code> 进行赋值操作。<code>??=</code> 的作用是为值为 <code>null</code> 的对象赋值：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = value;   <span class="comment">// 给 a 变量赋值</span></span><br><span class="line">b ??= value; <span class="comment">// 如果 b 是 null，则赋值给b，如果不是 null，则 b 的值保持不变</span></span><br></pre></td></tr></table></figure>

<p><code>Dart</code> 中还支持如下复合赋值操作符：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>–=</code></td>
<td><code>a -= b</code> 等同于 <code>a = a-b</code></td>
</tr>
<tr>
<td><code>/=</code></td>
<td><code>a /= b</code> 等同于 <code>a = a/b</code></td>
</tr>
<tr>
<td><code>%=</code></td>
<td><code>a %= b</code> 等同于 <code>a = a%b</code></td>
</tr>
<tr>
<td><code>&gt;&gt;=</code></td>
<td><code>a &gt;&gt;= b</code> 等同于 <code>a = a&gt;&gt;b</code></td>
</tr>
<tr>
<td><code>^=</code></td>
<td><code>a %^= b</code> 等同于 <code>a = a^b</code></td>
</tr>
<tr>
<td><code>+=</code></td>
<td><code>a += b</code> 等同于 <code>a = a+b</code></td>
</tr>
<tr>
<td><code>*=</code></td>
<td><code>a *= b</code> 等同于 <code>a = a*b</code></td>
</tr>
<tr>
<td><code>~/=</code></td>
<td><code>a ~/= b</code> 等同于 <code>a = a~/b</code></td>
</tr>
<tr>
<td><code>&lt;&lt;=</code></td>
<td><code>a &lt;&lt;= b</code> 等同于 <code>a = a&lt;&lt;b</code></td>
</tr>
<tr>
<td><code>&amp;=</code></td>
<td><code>a &amp;= b</code> 等同于 <code>a = a&amp;b</code></td>
</tr>
<tr>
<td>`</td>
<td>=`</td>
</tr>
</tbody></table>
<blockquote>
<p>复合赋值操作符是作用于左侧操作数的。表达式 <code>a op= b</code> 等同于 <code>a op= b</code>。即 <code>a += b</code> 等同于 <code>a = a+b</code></p>
</blockquote>
<h3 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><p><code>Dart</code> 中支持如下逻辑操作符：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>!expr</code></td>
<td>对表达式结果取反（<code>true</code> 变为 <code>false</code> ，<code>false</code> 变为 <code>true</code>）</td>
</tr>
<tr>
<td>`</td>
<td></td>
</tr>
<tr>
<td><code>&amp;&amp;</code></td>
<td>逻辑 <code>AND</code> （逻辑与）</td>
</tr>
</tbody></table>
<h3 id="位移操作符"><a href="#位移操作符" class="headerlink" title="位移操作符"></a>位移操作符</h3><p><code>Dart</code> 中支持如下位移操作符：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;</code></td>
<td>按位 <code>AND</code> （按位与）</td>
</tr>
<tr>
<td>`</td>
<td>`</td>
</tr>
<tr>
<td><code>^</code></td>
<td>按位 <code>!OR</code> 按位异或</td>
</tr>
<tr>
<td><code>~expr</code></td>
<td>按位非</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>左移</td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>右移</td>
</tr>
</tbody></table>
<h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><p><code>Dart</code> 中支持 <code>if-else</code> 条件表达式。另外，<code>Dart</code> 还提供额外的两种条件表达式写法用于代替 <code>if-else</code> 表达式：</p>
<ul>
<li><code>condition ? expr1 : expr2</code>：如果 <code>condition</code> 是 <code>true</code>，执行 <code>expr1</code> (并返回执行的结果)；否则执行 <code>expr2</code> 并返回其结果</li>
<li><code>expr1 ?? expr2</code>：如果 <code>expr1</code> 是 <code>non-null</code>，返回其值；否则执行 <code>expr2</code> 并返回其结果</li>
</ul>
<h3 id="级联操作符"><a href="#级联操作符" class="headerlink" title="级联操作符"></a>级联操作符</h3><p>在 <code>Dart</code> 中，级联操作符（<code>..</code>）允许我们在同一个对象上连续调用多个函数以及访问成员变量。使用级联操作符可以避免创建临时变量：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">querySelector</span>(<span class="string">&#x27;#button&#x27;</span>) <span class="comment">// Get an object.</span></span><br><span class="line">  ..text = <span class="string">&#x27;Confirm&#x27;</span>   <span class="comment">// Use its members.</span></span><br><span class="line">  ..classes.add(<span class="string">&#x27;important&#x27;</span>)</span><br><span class="line">  ..onClick.listen((e) =&gt; <span class="built_in">window</span>.alert(<span class="string">&#x27;Confirmed!&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>第一个方法 <code>querySelector()</code> 返回了一个 <code>selector</code> 对象。后面的级联操作符都是调用这个对象的成员，并忽略每个操作 所返回的值。</p>
<p>下面的代码在功能上等同于上述代码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">querySelector</span>(<span class="string">&#x27;#button&#x27;</span>);</span><br><span class="line">button.text = <span class="string">&#x27;Confirm&#x27;</span>;</span><br><span class="line">button.classes.add(<span class="string">&#x27;important&#x27;</span>);</span><br><span class="line">button.onClick.listen((e) =&gt; <span class="built_in">window</span>.alert(<span class="string">&#x27;Confirmed!&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>下面的示例展示了级联调用的嵌套使用情况：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> addressBook = (<span class="keyword">new</span> AddressBookBuilder()</span><br><span class="line">      ..name = <span class="string">&#x27;jenny&#x27;</span></span><br><span class="line">      ..email = <span class="string">&#x27;jenny@example.com&#x27;</span></span><br><span class="line">      ..phone = (<span class="keyword">new</span> PhoneNumberBuilder()</span><br><span class="line">            ..number = <span class="string">&#x27;415-555-0100&#x27;</span></span><br><span class="line">            ..label = <span class="string">&#x27;home&#x27;</span>)</span><br><span class="line">          .build())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<h3 id="其他操作符"><a href="#其他操作符" class="headerlink" title="其他操作符"></a>其他操作符</h3><p><code>Dart</code> 中还有一些其他的操作符：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>名称</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>()</code></td>
<td>使用方法</td>
<td>代表调用一个方法</td>
</tr>
<tr>
<td><code>[]</code></td>
<td>访问 <code>List</code></td>
<td>访问 <code>List</code> 中特定位置的元素</td>
</tr>
<tr>
<td><code>.</code></td>
<td>访问元素</td>
<td><code>foo.bar</code> 代表访问 <code>foo</code> 中的元素 <code>bar</code></td>
</tr>
<tr>
<td><code>?.</code></td>
<td>条件成员访问</td>
<td>与 <code>.</code> 类似，但是左边的操作对象不能为 <code>null</code></td>
</tr>
</tbody></table>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p><code>Dart</code> 中支持如下几种流程控制语法：</p>
<ul>
<li><code>if-else</code> 条件判断</li>
<li><code>for</code> 循环</li>
<li><code>while</code> 和 <code>do-while</code> 循环</li>
<li><code>break</code> 和 <code>continue</code></li>
<li><code>switch</code> 条件判断</li>
<li><code>assert</code> 断言</li>
</ul>
<h3 id="if-else-条件判断"><a href="#if-else-条件判断" class="headerlink" title="if-else 条件判断"></a>if-else 条件判断</h3><p><code>Dart</code> 中支持 <code>if</code> 语句以及可选的 <code>else</code> 语句：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isRaining()) &#123;</span><br><span class="line">  you.bringRainCoat();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (isSnowing()) &#123;</span><br><span class="line">  you.wearJacket();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  car.putTopDown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p><code>Dart</code> 中支持如下 <code>for</code> 循环语句：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="keyword">new</span> <span class="built_in">StringBuffer</span>(<span class="string">&quot;Dart is fun&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  message.write(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要遍历的对象实现了 <code>Iterable</code> 接口，则可以使用 <code>forEach()</code> 方法。如果没必要当前遍历的索引，则使用 <code>forEach()</code> 方法是个非常好的选择：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">candidates.forEach((candidate) =&gt; candidate.interview());</span><br></pre></td></tr></table></figure>

<p><code>List</code> 和 <code>Set</code> 等实现了 <code>Iterable</code> 接口的类还支持 <code>for-in</code> 形式的遍历：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> collection = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">in</span> collection) &#123;</span><br><span class="line">  <span class="built_in">print</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="while-和-do-while-循环"><a href="#while-和-do-while-循环" class="headerlink" title="while 和 do-while 循环"></a>while 和 do-while 循环</h3><p><code>Dart</code> 中，<code>while</code> 循环在执行循环之前先判断条件是否满足：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!isDone()) &#123;</span><br><span class="line">  doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 <code>do-while</code> 是先执行循环再判断条件是否满足：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  printLine();</span><br><span class="line">&#125; <span class="keyword">while</span> (!atEndOfPage());</span><br></pre></td></tr></table></figure>

<h3 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a>break 和 continue</h3><p><code>Dart</code> 中可以实现 <code>break</code> 来中断当前的循环：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (shutDownRequested()) <span class="keyword">break</span>;</span><br><span class="line">  processIncomingRequests();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 <code>continue</code> 则是中断当前循环并进入下一次循环：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; candidates.length; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> candidate = candidates[i];</span><br><span class="line">  <span class="keyword">if</span> (candidate.yearsExperience &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  candidate.interview();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述代码在实现了 <code>Iterable</code> 接口的对象上可以采用如下写法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">candidates.where((c) =&gt; c.yearsExperience &gt;= <span class="number">5</span>)</span><br><span class="line">          .forEach((c) =&gt; c.interview());</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="switch-条件判断"><a href="#switch-条件判断" class="headerlink" title="switch 条件判断"></a>switch 条件判断</h3><p>在 <code>Dart</code> 中可以使用<code>switch</code> 语句比较 <code>integer</code>、<code>string</code>、或者编译时常量。比较的对象必须都是同一个类的实例，<code>class</code> 必须没有覆写 <code>==</code> 操作符：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> command = <span class="string">&#x27;OPEN&#x27;</span>;</span><br><span class="line"><span class="keyword">switch</span> (command) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;CLOSED&#x27;</span>:</span><br><span class="line">    executeClosed();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;PENDING&#x27;</span>:</span><br><span class="line">    executePending();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;APPROVED&#x27;</span>:</span><br><span class="line">    executeApproved();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;DENIED&#x27;</span>:</span><br><span class="line">    executeDenied();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;OPEN&#x27;</span>:</span><br><span class="line">    executeOpen();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    executeUnknown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>每个非空的 <code>case</code> 语句都必须有一个 <code>break</code> 语句。另外还可以通过 <code>continue</code>、<code>throw</code> 或者 <code>return</code> 来结束非空 <code>case</code> 语句。当没有 <code>case</code> 语句匹配的时候，可以使用 <code>default</code> 语句来匹配这种默认情况。</p>
</blockquote>
<p>如果你需要实现这种继续到下一个 <code>case</code> 语句中继续执行，则可以 使用 <code>continue</code> 语句跳转到对应的标签（<code>label</code>）处继续执行：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> command = <span class="string">&#x27;CLOSED&#x27;</span>;</span><br><span class="line"><span class="keyword">switch</span> (command) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;CLOSED&#x27;</span>:</span><br><span class="line">    executeClosed();</span><br><span class="line">    <span class="keyword">continue</span> nowClosed;</span><br><span class="line">    <span class="comment">// Continues executing at the nowClosed label.</span></span><br><span class="line"></span><br><span class="line">nowClosed:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;NOW_CLOSED&#x27;</span>:</span><br><span class="line">    <span class="comment">// Runs for both CLOSED and NOW_CLOSED.</span></span><br><span class="line">    executeNowClosed();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，每个 <code>case</code> 语句都可以有局部变量，局部变量只有在这个语句内可见。</p>
</blockquote>
<h3 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h3><p>在 <code>Dart</code> 中，如果条件表达式结果不满足需要，则可以使用 <code>assert</code> 语句俩打断代码的执行：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Make sure the variable has a non-null value.</span></span><br><span class="line"><span class="keyword">assert</span>(text != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make sure the value is less than 100.</span></span><br><span class="line"><span class="keyword">assert</span>(number &lt; <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make sure this is an https URL.</span></span><br><span class="line"><span class="keyword">assert</span>(urlString.startsWith(<span class="string">&#x27;https&#x27;</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是， 断言只在检查模式下运行有效，如果在生产模式运行，则断言不会执行。</p>
</blockquote>
<p><code>assert</code> 方法的参数可以为任何返回布尔值的表达式或者方法。如果返回的值为 <code>true</code>， 断言执行通过，执行结束。如果返回值为 <code>false</code>， 断言执行失败，会抛出一个 <code>AssertionError</code> 异常。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>在 <code>Dart</code> 代码中可以通过抛出异常和捕获异常以达到处理某些错误的目的。<code>Dart</code> 中提供了 <code>Exception</code> 和 <code>Error</code> 类型用于表示异常。我们可以抛出已有的异常类型，也可以自定义异常类型。与 <code>Java</code> 不同的是，<code>Dart</code> 中可以抛出任何 <code>non-null</code> 对象为异常。</p>
<h3 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h3><p>在 <code>Dart</code> 中使用关键字 <code>throw</code> 抛出一个 <code>FormatException</code> 异常：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> FormatException(<span class="string">&#x27;Expected at least 1 section&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>或者抛出一个 <code>String</code> 类型的异常：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="string">&#x27;Out of llamas!&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="catch-或-on"><a href="#catch-或-on" class="headerlink" title="catch 或 on"></a>catch 或 on</h3><p>在 <code>Dart</code> 中可以使用 <code>catch</code> 或者 <code>on</code> 处理异常。<code>on</code> 用于指定异常类型，<code>catch</code> 用于捕获异常对象：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; <span class="keyword">on</span> OutOfLlamasException &#123;</span><br><span class="line">  <span class="comment">// A specific exception</span></span><br><span class="line">  buyMoreLlamas();</span><br><span class="line">&#125; <span class="keyword">on</span> Exception <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// Anything else that is an exception</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Unknown exception: <span class="subst">$e</span>&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// No specified type, handles all</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Something really unknown: <span class="subst">$e</span>&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>catch</code> 后面可以有一个或者两个参数，第一个参数表示抛出的异常对象，第二个参数表示堆栈信息（<code>StackTrace</code>）对象。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; <span class="keyword">on</span> OutOfLlamasException &#123;</span><br><span class="line">  <span class="comment">// A specific exception</span></span><br><span class="line">  buyMoreLlamas();</span><br><span class="line">&#125; <span class="keyword">on</span> Exception <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// Anything else that is an exception</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Unknown exception: <span class="subst">$e</span>&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e, s) &#123;</span><br><span class="line">  <span class="comment">// No specified type, handles all</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Something really unknown: <span class="subst">$e</span>&#x27;</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Stack trace:\n <span class="subst">$s</span>&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以使用 <code>rethrow</code> 关键字把异常重新抛出：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> foo = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> misbehave() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    foo = <span class="string">&quot;You can&#x27;t change a final variable&#x27;s value.&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;misbehave() partially handled <span class="subst">$&#123;e.runtimeType&#125;</span>.&#x27;</span>);</span><br><span class="line">    <span class="keyword">rethrow</span>; <span class="comment">// Allow callers to see the exception.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    misbehave();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;main() finished handling <span class="subst">$&#123;e.runtimeType&#125;</span>.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p>为了确保在抛出异常时（或者没有抛出异常），某些逻辑能够正常执行，可以使用 <code>finally</code> 关键字来确保代码的正常执行：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Error: <span class="subst">$e</span>&#x27;</span>);  <span class="comment">// Handle the exception first.</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  cleanLlamaStalls();  <span class="comment">// Then clean up.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果省略了 <code>catch</code>，则会在 <code>finally</code> 执行完毕之后将异常抛出：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// Always clean up, even if an exception is thrown.</span></span><br><span class="line">  cleanLlamaStalls();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>与 <code>Java</code> 类似的，<code>Dart</code> 中的类也都是派生于 <code>Object</code> 超类，并且是单一继承结构的。</p>
<p>在 <code>Dart</code> 中通过使用 <code>new</code> 关键字和构造函数来创建一个新的对象（构造函数名字可以为 <code>ClassName</code> 或者 <code>ClassName.identifier</code>）：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonData = JSON.decode(<span class="string">&#x27;&#123;&quot;x&quot;:1, &quot;y&quot;:2&#125;&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a Point using Point().</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a Point using Point.fromJson().</span></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Point.fromJson(jsonData);</span><br></pre></td></tr></table></figure>

<p>对象的成员包括方法和数据 (方法和实例变量)。当你调用一个函数的时候，你是在一个对象上调用该函数需要访问对象的方法和数据。</p>
<p>使用点(<code>.</code>)来引用对象的变量或者方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the value of the instance variable y.</span></span><br><span class="line">p.y = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the value of y.</span></span><br><span class="line"><span class="keyword">assert</span>(p.y == <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke distanceTo() on p.</span></span><br><span class="line"><span class="built_in">num</span> distance = p.distanceTo(<span class="keyword">new</span> Point(<span class="number">4</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure>

<p>或者使用 <code>?.</code> 来替代 <code>.</code> 以避免当左边对象为 <code>null</code> 时抛出异常：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If p is non-null, set its y value to 4.</span></span><br><span class="line">p?.y = <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>有些类提供了常量构造函数。使用常量构造函数可以创建编译时常量，要使用常量构造函数只需要用 <code>const</code> 替代 <code>new</code> 即可：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">const</span> ImmutablePoint(<span class="number">2</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 <code>Dart</code> 中，两个一样的编译时常量其实是同一个对象。也就是说 <code>var a = const ImmutablePoint(1, 1);</code> 和 <code>var b = const ImmutablePoint(1, 1);</code> 中 <code>a</code> 和 <code>b</code> 实际上是同一个对象（即 <code>assert(identical(a, b));</code> 为 <code>true</code>）。</p>
</blockquote>
<p>可以使用 <code>Object</code> 的 <code>runtimeType</code> 属性来判断实例的类型，该属性返回一个 <code>Type</code> 对象：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The type of a is <span class="subst">$&#123;p.runtimeType&#125;</span>&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="变量实例"><a href="#变量实例" class="headerlink" title="变量实例"></a>变量实例</h3><p>在 <code>Dart</code> 中，所有类的实例变量或默认初始化为 <code>null</code>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x; <span class="comment">// Declare instance variable x, initially null.</span></span><br><span class="line">  <span class="built_in">num</span> y; <span class="comment">// Declare y, initially null.</span></span><br><span class="line">  <span class="built_in">num</span> z = <span class="number">0</span>; <span class="comment">// Declare z, initially 0.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个实例变量会自动生成一个隐式的 <code>getter</code> 方法，对于非 <code>final</code> 变量还会自动生成一个隐式的 <code>setter</code> 方法。下属代码是可以正常运行的：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> point = <span class="keyword">new</span> Point();</span><br><span class="line">  point.x = <span class="number">4</span>;          <span class="comment">// Use the setter method for x.</span></span><br><span class="line">  <span class="keyword">assert</span>(point.x == <span class="number">4</span>); <span class="comment">// Use the getter method for x.</span></span><br><span class="line">  <span class="keyword">assert</span>(point.y == <span class="keyword">null</span>); <span class="comment">// Values default to null.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>定义一个和类名字一样的方法就定义了一个构造函数：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="built_in">num</span> x, <span class="built_in">num</span> y) &#123;</span><br><span class="line">    <span class="comment">// There&#x27;s a better way to do this, stay tuned.</span></span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于把构造函数参数赋值给实例变量的场景太常见了，<code>Dart</code> 提供了一个语法糖来简化这个操作：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Syntactic sugar for setting x and y</span></span><br><span class="line">  <span class="comment">// before the constructor body runs.</span></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><p>如果我们没有定义构造函数，则会有个默认构造函数。默认构造函数没有参数，并且会调用超类的没有参数的构造函数。</p>
<p>需要注意的是，在 <code>Dart</code> 中子类不会继承父类的构造函数。子类如果没有定义构造函数，那么就只有一个默认构造函数。如果需要调用父类的构造函数，则需要我们在子类中手动调用。在构造函数参数后使用冒号 (<code>:</code>) 可以调用 超类构造函数：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> firstName;</span><br><span class="line"></span><br><span class="line">  Person.fromJson(<span class="built_in">Map</span> data) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;in Person&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Person does not have a default constructor;</span></span><br><span class="line">  <span class="comment">// you must call super.fromJson(data).</span></span><br><span class="line">  Employee.fromJson(<span class="built_in">Map</span> data) : <span class="keyword">super</span>.fromJson(data) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;in Employee&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> emp = <span class="keyword">new</span> Employee.fromJson(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prints:</span></span><br><span class="line">  <span class="comment">// in Person</span></span><br><span class="line">  <span class="comment">// in Employee</span></span><br><span class="line">  <span class="keyword">if</span> (emp <span class="keyword">is</span> Person) &#123;</span><br><span class="line">    <span class="comment">// Type check</span></span><br><span class="line">    emp.firstName = <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  (emp <span class="keyword">as</span> Person).firstName = <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="命名构造函数"><a href="#命名构造函数" class="headerlink" title="命名构造函数"></a>命名构造函数</h4><p>使用命名构造函数可以为一个类实现多个构造函数：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Named constructor</span></span><br><span class="line">  Point.fromJson(<span class="built_in">Map</span> json) &#123;</span><br><span class="line">    x = json[<span class="string">&#x27;x&#x27;</span>];</span><br><span class="line">    y = json[<span class="string">&#x27;y&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><p>在构造函数体执行之前除了可以调用超类构造函数之外，还可以初始化实例参数。使用逗号（<code>,</code>）分隔初始化表达式：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initializer list sets instance variables before</span></span><br><span class="line">  <span class="comment">// the constructor body runs.</span></span><br><span class="line">  Point.fromJson(<span class="built_in">Map</span> jsonMap)</span><br><span class="line">      : x = jsonMap[<span class="string">&#x27;x&#x27;</span>],</span><br><span class="line">        y = jsonMap[<span class="string">&#x27;y&#x27;</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;In Point.fromJson(): (<span class="subst">$x</span>, <span class="subst">$y</span>)&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化列表非常适合用来设置 <code>final</code> 变量的值。下面示例代码中初始化列表设置了三个 <code>final</code> 变量的值：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:math&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> x;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> y;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> distanceFromOrigin;</span><br><span class="line"></span><br><span class="line">  Point(x, y)</span><br><span class="line">      : x = x,</span><br><span class="line">        y = y,</span><br><span class="line">        distanceFromOrigin = sqrt(x * x + y * y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">print</span>(p.distanceFromOrigin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重定向构造函数"><a href="#重定向构造函数" class="headerlink" title="重定向构造函数"></a>重定向构造函数</h4><p>如果需要在一个构造函数中调用类中的其他构造函数，那么可以使用冒号（<code>:</code>）调用其他的构造函数：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The main constructor for this class.</span></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Delegates to the main constructor.</span></span><br><span class="line">  Point.alongXAxis(<span class="built_in">num</span> x) : <span class="keyword">this</span>(x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="常量构造函数"><a href="#常量构造函数" class="headerlink" title="常量构造函数"></a>常量构造函数</h4><p>如果我们的类是一个状态不变的对象，我们可以把这些对象定义为编译时常量。通过对构造函数使用 <code>const</code> 关键字并把所有的变量声明为 <code>final</code> 来实现：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImmutablePoint</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> x;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> y;</span><br><span class="line">  <span class="keyword">const</span> ImmutablePoint(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> ImmutablePoint origin =</span><br><span class="line">      <span class="keyword">const</span> ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="工厂方法构造函数"><a href="#工厂方法构造函数" class="headerlink" title="工厂方法构造函数"></a>工厂方法构造函数</h4><p>如果一个构造函数并不总是返回一个新的对象，则使用 <code>factory</code> 来定义这个构造函数。例如，一个工厂构造函数可能从缓存中获取一个实例并返回，或者返回一个子类型的实例：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">bool</span> mute = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// _cache is library-private, thanks to the _ in front</span></span><br><span class="line">  <span class="comment">// of its name.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Logger&gt; _cache =</span><br><span class="line">      &lt;<span class="built_in">String</span>, Logger&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> Logger(<span class="built_in">String</span> name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_cache.containsKey(name)) &#123;</span><br><span class="line">      <span class="keyword">return</span> _cache[name];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> logger = <span class="keyword">new</span> Logger._internal(name);</span><br><span class="line">      _cache[name] = logger;</span><br><span class="line">      <span class="keyword">return</span> logger;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Logger._internal(<span class="keyword">this</span>.name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> log(<span class="built_in">String</span> msg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mute) &#123;</span><br><span class="line">      <span class="built_in">print</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，通过 <code>new</code> 关键字来调用工厂构造函数：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logger = <span class="keyword">new</span> Logger(<span class="string">&#x27;UI&#x27;</span>);</span><br><span class="line">logger.log(<span class="string">&#x27;Button clicked&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><p>对象的实例方法可以访问 <code>this</code>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:math&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">num</span> distanceTo(Point other) &#123;</span><br><span class="line">    <span class="keyword">var</span> dx = x - other.x;</span><br><span class="line">    <span class="keyword">var</span> dy = y - other.y;</span><br><span class="line">    <span class="keyword">return</span> sqrt(dx * dx + dy * dy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="getter-和-setter-方法"><a href="#getter-和-setter-方法" class="headerlink" title="getter 和 setter 方法"></a>getter 和 setter 方法</h4><p><code>getter</code> 和 <code>setter</code> 方法是用来设置和访问对象属性的特殊函数。每个实例变量都有一个隐式的 <code>getter</code> 方法，每一个非 <code>final</code> 变量都有一个隐式的 <code>setter</code> 方法。我们可以通过使用 <code>get</code> 和 <code>set</code> 关键字来定义 <code>getter</code> 和 <code>setter</code> 方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> left;</span><br><span class="line">  <span class="built_in">num</span> top;</span><br><span class="line">  <span class="built_in">num</span> width;</span><br><span class="line">  <span class="built_in">num</span> height;</span><br><span class="line"></span><br><span class="line">  Rectangle(<span class="keyword">this</span>.left, <span class="keyword">this</span>.top, <span class="keyword">this</span>.width, <span class="keyword">this</span>.height);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Define two calculated properties: right and bottom.</span></span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> right             =&gt; left + width;</span><br><span class="line">      <span class="keyword">set</span> right(<span class="built_in">num</span> value)  =&gt; left = value - width;</span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> bottom            =&gt; top + height;</span><br><span class="line">      <span class="keyword">set</span> bottom(<span class="built_in">num</span> value) =&gt; top = value - height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> rect = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>, <span class="number">20</span>, <span class="number">15</span>);</span><br><span class="line">  <span class="keyword">assert</span>(rect.left == <span class="number">3</span>);</span><br><span class="line">  rect.right = <span class="number">12</span>;</span><br><span class="line">  <span class="keyword">assert</span>(rect.left == <span class="number">-8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h4><p>在 <code>Dart</code> 中，实例函数、<code>getter</code> 和 <code>setter</code> 方法可以是抽象函数。抽象函数是只定义函数接口但是没有具体实现的函数：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Doer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...Define instance variables and methods...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> doSomething(); <span class="comment">// Define an abstract method.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EffectiveDoer</span> <span class="keyword">extends</span> <span class="title">Doer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> doSomething() &#123;</span><br><span class="line">    <span class="comment">// ...Provide an implementation, so the method is not abstract here...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可复写的操作符"><a href="#可复写的操作符" class="headerlink" title="可复写的操作符"></a>可复写的操作符</h4><p>下表中的操作符可以进行复写：</p>
<p>| — | — | — | — |<br>| <code>&lt;</code> | <code>+</code> | <code>[]</code> | <code>|</code> |<br>| <code>&lt;</code>| <code>/</code> | <code>^</code>| <code>[]=</code> |<br>| <code>&lt;=</code> | <code>~/</code> | <code>&amp;</code> | <code>~</code> |<br>| <code>&gt;=</code> | <code>*</code>| <code>&lt;&lt;</code> | <code>==</code> |<br>| <code>-</code> | <code>%</code> | <code>&gt;&gt;</code> |  |</p>
<p>下面是覆写了 <code>+</code> 和 <code>-</code> 操作符的示例：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> x;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> y;</span><br><span class="line">  <span class="keyword">const</span> Vector(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Overrides + (a + b).</span></span></span><br><span class="line">  Vector <span class="keyword">operator</span> +(Vector v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vector(x + v.x, y + v.y);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Overrides - (a - b).</span></span></span><br><span class="line">  Vector <span class="keyword">operator</span> -(Vector v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Vector(x - v.x, y - v.y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">final</span> v = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">final</span> w = <span class="keyword">new</span> Vector(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// v == (2, 3)</span></span><br><span class="line">  <span class="keyword">assert</span>(v.x == <span class="number">2</span> &amp;&amp; v.y == <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// v + w == (4, 5)</span></span><br><span class="line">  <span class="keyword">assert</span>((v + w).x == <span class="number">4</span> &amp;&amp; (v + w).y == <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// v - w == (0, 1)</span></span><br><span class="line">  <span class="keyword">assert</span>((v - w).x == <span class="number">0</span> &amp;&amp; (v - w).y == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>在 <code>Dart</code> 中，<code>abstract</code> 关键字用于修饰一个抽象类。抽象类通常用来定义接口以及部分实现，如果我们希望我们的抽象类是可实例化的，那么需要定义一个工厂构造函数：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractContainer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...Define constructors, fields, methods...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> updateChildren(); <span class="comment">// Abstract method.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 <code>Java</code> 中抽象类一样，在 <code>Dart</code> 中抽象类是不能实例化的。如果我们在一个普通类中定义了一个抽象函数，则是可以实例化的：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecializedContainer</span> <span class="keyword">extends</span> <span class="title">AbstractContainer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...Define more constructors, fields, methods...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> updateChildren() &#123;</span><br><span class="line">    <span class="comment">// ...Implement updateChildren()...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Abstract method causes a warning but</span></span><br><span class="line">  <span class="comment">// doesn&#x27;t prevent instantiation.</span></span><br><span class="line">  <span class="keyword">void</span> doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>一个类可以通过 <code>implements</code> 关键字来实现一个或者多个接口， 并实现每个接口：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// In the interface, but visible only in this library.</span></span><br><span class="line">  <span class="keyword">final</span> _name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not in the interface, since this is a constructor.</span></span><br><span class="line">  Person(<span class="keyword">this</span>._name);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// In the interface.</span></span><br><span class="line">  <span class="built_in">String</span> greet(who) =&gt; <span class="string">&#x27;Hello, <span class="subst">$who</span>. I am <span class="subst">$_name</span>.&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// An implementation of the Person interface.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Imposter</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We have to define this, but we don&#x27;t use it.</span></span><br><span class="line">  <span class="keyword">final</span> _name = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> greet(who) =&gt; <span class="string">&#x27;Hi <span class="subst">$who</span>. Do you know who I am?&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greetBob(Person person) =&gt; person.greet(<span class="string">&#x27;bob&#x27;</span>);</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(greetBob(<span class="keyword">new</span> Person(<span class="string">&#x27;kathy&#x27;</span>)));</span><br><span class="line">  <span class="built_in">print</span>(greetBob(<span class="keyword">new</span> Imposter()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩展类"><a href="#扩展类" class="headerlink" title="扩展类"></a>扩展类</h3><p>通过使用 <code>extends</code> 实现从父类派生一个子类的目的：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;</span><br><span class="line">    _illuminateDisplay();</span><br><span class="line">    _activateIrSensor();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartTelevision</span> <span class="keyword">extends</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;</span><br><span class="line">    <span class="keyword">super</span>.turnOn();</span><br><span class="line">    _bootNetworkInterface();</span><br><span class="line">    _initializeMemory();</span><br><span class="line">    _upgradeApps();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>super</code> 关键字用于访问父类对象</p>
</blockquote>
<p>子类可以覆写实例方法，<code>getter</code> 和 <code>setter</code> 方法。下面是覆写 <code>Object</code> 类的 <code>noSuchMethod()</code> 方法的例子，如果调用了对象上不存在的方法，则就会触发 <code>noSuchMethod()</code> 方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> noSuchMethod(Invocation mirror) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>@override</code> 注解表明该方法是复写的父类方法。</p>
</blockquote>
<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>枚举类是一种特殊类型的类，主要用来表示一个数量固定的常量集。我们可以使用 <code>enum</code> 来定义一个枚举类：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">  red,</span><br><span class="line">  green,</span><br><span class="line">  blue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类中的每个值都有一个 <code>index</code> 的 <code>getter</code> 方法，该方法返回该值在枚举类型定义中的位置（从 0 开始。枚举的 <code>values</code> 常量则可以返回所有的枚举值。</p>
<h3 id="扩展类的功能"><a href="#扩展类的功能" class="headerlink" title="扩展类的功能"></a>扩展类的功能</h3><p><code>mixin</code> 是一种在多类继承中重用一个类代码的方法。使用 <code>with</code> 关键字后面为一个或者多个 <code>mixin</code> 名字来使用 <code>mixin</code>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Musician</span> <span class="keyword">extends</span> <span class="title">Performer</span> <span class="title">with</span> <span class="title">Musical</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Maestro</span> <span class="keyword">extends</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">Musical</span>, <span class="title">Aggressive</span>, <span class="title">Demented</span> </span>&#123;</span><br><span class="line">  Maestro(<span class="built_in">String</span> maestroName) &#123;</span><br><span class="line">    name = maestroName;</span><br><span class="line">    canConduct = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个类继承 <code>Object</code>，该类没有构造函数，不能调用 <code>super</code> ，则该类就是一个 <code>mixin</code>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Musical</span> </span>&#123;</span><br><span class="line">  <span class="built_in">bool</span> canPlayPiano = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">bool</span> canCompose = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">bool</span> canConduct = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> entertainMe() &#123;</span><br><span class="line">    <span class="keyword">if</span> (canPlayPiano) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;Playing piano&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (canConduct) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;Waving hands&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;Humming to self&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态变量和静态方法"><a href="#静态变量和静态方法" class="headerlink" title="静态变量和静态方法"></a>静态变量和静态方法</h3><p>在 <code>Dart</code> 中，可以使用 <code>static</code> 关键字来实现类级别的变量和方法，它们分别被称为静态变量和静态方法。</p>
<h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><p>静态变量在第一次使用的时候才被初始化。静态变量对于类级别的状态是非常有用的：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> red = <span class="keyword">const</span> Color(<span class="string">&#x27;red&#x27;</span>); <span class="comment">// A constant static variable.</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;      <span class="comment">// An instance variable.</span></span><br><span class="line">  <span class="keyword">const</span> Color(<span class="keyword">this</span>.name); <span class="comment">// A constant constructor.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(Color.red.name == <span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>静态方法可以当做编译时常量使用。例如，我们可以把静态方法当做常量构造函数的参数来使用。静态方法的示例如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:math&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">num</span> distanceBetween(Point a, Point b) &#123;</span><br><span class="line">    <span class="keyword">var</span> dx = a.x - b.x;</span><br><span class="line">    <span class="keyword">var</span> dy = a.y - b.y;</span><br><span class="line">    <span class="keyword">return</span> sqrt(dx * dx + dy * dy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">var</span> b = <span class="keyword">new</span> Point(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">var</span> distance = Point.distanceBetween(a, b);</span><br><span class="line">  <span class="keyword">assert</span>(distance &lt; <span class="number">2.9</span> &amp;&amp; distance &gt; <span class="number">2.8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>在 <code>Dart</code> 中，通常使用一个字母来代表泛型参数，例如 <code>E</code>、<code>T</code>、<code>S</code>、<code>K</code> 和 <code>V</code> 等。</p>
<p>在 <code>Dart</code> 中，类型是可选的，我们可以选择不使用泛型。有些情况下我们可能需要使用类型来表明意图，不管是使用泛型还是具体类型。例如，如果我们希望一个 <code>List</code> 只包含字符串对象，那么我们可以使用泛型的方式定义 <code>List&lt;String&gt;</code>:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = <span class="keyword">new</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">names.addAll([<span class="string">&#x27;Seth&#x27;</span>, <span class="string">&#x27;Kathy&#x27;</span>, <span class="string">&#x27;Lars&#x27;</span>]);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">names.add(<span class="number">42</span>); <span class="comment">// Fails in checked mode (succeeds in production mode).</span></span><br></pre></td></tr></table></figure>


<p>另外一个使用泛型的原因是减少重复的代码。泛型可以在多种类型之间定义同一个实现，同时还可以继续使用检查模式和静态分析工具提供的代码分析功能。例如，我们创建一个保存缓存对象的接口：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectCache</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span> getByKey(<span class="built_in">String</span> key);</span><br><span class="line">  setByKey(<span class="built_in">String</span> key, <span class="built_in">Object</span> value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随着需求的变化，我们不得不重新定义一个新的缓存类来缓存 <code>String</code> 对象：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StringCache</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> getByKey(<span class="built_in">String</span> key);</span><br><span class="line">  setByKey(<span class="built_in">String</span> key, <span class="built_in">String</span> value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用泛型则可以避免上述重复的代码，我们只需要定一个泛型接口：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  T getByKey(<span class="built_in">String</span> key);</span><br><span class="line">  setByKey(<span class="built_in">String</span> key, T value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>T</code> 是一个备用类型。这是一个类型占位符，在我们调用该接口的时候需要指定具体类型。</p>
<h3 id="在构造函数中使用泛型"><a href="#在构造函数中使用泛型" class="headerlink" title="在构造函数中使用泛型"></a>在构造函数中使用泛型</h3><p>在调用构造函数的时候， 在类名字后面使用尖括号(<code>&lt; &gt;</code>)来指定 泛型类型：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = <span class="keyword">new</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">names.addAll([<span class="string">&#x27;Seth&#x27;</span>, <span class="string">&#x27;Kathy&#x27;</span>, <span class="string">&#x27;Lars&#x27;</span>]);</span><br><span class="line"><span class="keyword">var</span> nameSet = <span class="keyword">new</span> <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt;.from(names);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Dart</code> 中的泛型类型是固化的，在运行时有也可以判断具体的类型。这与 <code>Java</code> 是不同的。<code>Java</code> 中的泛型信息是编译时的，泛型信息在运行时是不存在的。在 <code>Java</code> 中我们可以判断一个对象是否为 <code>List</code>， 但是我们无法判断一个对象是否为 <code>List&lt;String&gt;</code>。</p>
</blockquote>
<h3 id="限制泛型类型"><a href="#限制泛型类型" class="headerlink" title="限制泛型类型"></a>限制泛型类型</h3><p>在声明泛型时，我们可以通过使用 <code>extends</code> 关键字来限制泛型的类型：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SomeBaseClass</span>&gt; </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Extender</span> <span class="keyword">extends</span> <span class="title">SomeBaseClass</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// It&#x27;s OK to use SomeBaseClass or any of its subclasses inside &lt;&gt;.</span></span><br><span class="line">  <span class="keyword">var</span> someBaseClassFoo = <span class="keyword">new</span> Foo&lt;SomeBaseClass&gt;();</span><br><span class="line">  <span class="keyword">var</span> extenderFoo = <span class="keyword">new</span> Foo&lt;Extender&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// It&#x27;s also OK to use no &lt;&gt; at all.</span></span><br><span class="line">  <span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Specifying any non-SomeBaseClass type results in a warning and, in</span></span><br><span class="line">  <span class="comment">// checked mode, a runtime error.</span></span><br><span class="line">  <span class="comment">// var objectFoo = new Foo&lt;Object&gt;();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>在方法中使用泛型的示例如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T first&lt;T&gt;(<span class="built_in">List</span>&lt;T&gt; ts) &#123;</span><br><span class="line">  <span class="comment">// ...Do some initial work or error checking, then...</span></span><br><span class="line">  T tmp ?= ts[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// ...Do some additional checking or processing...</span></span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>first (&lt;T&gt;)</code> 泛型方法可以在如下地方使用参数 <code>T</code> ：</p>
<ul>
<li>方法的返回值类型 (<code>T</code>)</li>
<li>参数的类型 (<code>List&lt;T&gt;</code>)</li>
<li>局部变量的类型 (<code>T tmp</code>)</li>
</ul>
<h2 id="库和可见性"><a href="#库和可见性" class="headerlink" title="库和可见性"></a>库和可见性</h2><p>在 <code>Dart</code> 中，使用 <code>import</code> 和 <code>library</code> 指令可以帮助我们创建模块化的可分享的代码。库不仅仅提供访问接口，还是一个私有单元：以下划线 (<code>_</code>) 开头的标识符只有在库内部可见。</p>
<blockquote>
<p>事实上，每个 <code>Dart app</code> 都是一个库， 即使没有使用 <code>library</code> 命令也是一个库。</p>
</blockquote>
<p>库可以使用 <code>Dart package</code> 工具部署。参考 <a target="_blank" rel="noopener" href="https://www.dartlang.org/tools/pub">Pub Package 和 Asset Manager</a> 来获取关于 <code>pub</code>（<code>Dart</code> 的包管理工具） 的更多信息。</p>
<h3 id="使用库"><a href="#使用库" class="headerlink" title="使用库"></a>使用库</h3><p>在 <code>Dart</code> 中，使用 <code>import</code> 来指定一个库：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:html&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><code>import</code> 必须参数为库的 <code>URI</code>。 对于内置的库，<code>URI</code> 使用特殊的 <code>dart:scheme</code>。对于其他的库，我们可以使用文件系统路径或者 <code>package:scheme</code>（<code>package:scheme</code> 指定的库通过包管理器来提供，例如 <code>pub</code> 工具）：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:io&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:mylib/mylib.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:utils/utils.dart&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="指定库前缀"><a href="#指定库前缀" class="headerlink" title="指定库前缀"></a>指定库前缀</h3><p>如果我们导入的两个库有冲突的标识符，我们可以使用库的前缀来区分。例如，如果 <code>library1</code> 和 <code>library2</code> 都有一个名字为 <code>Element</code> 的类，我们可以这样使用：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lib1/lib1.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lib2/lib2.dart&#x27;</span> <span class="keyword">as</span> lib2;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">Element</span> element1 = <span class="keyword">new</span> <span class="built_in">Element</span>();           <span class="comment">// Uses Element from lib1.</span></span><br><span class="line">lib2.<span class="built_in">Element</span> element2 = <span class="keyword">new</span> lib2.<span class="built_in">Element</span>(); <span class="comment">// Uses Element from lib2.</span></span><br></pre></td></tr></table></figure>

<h3 id="导入库的一部分"><a href="#导入库的一部分" class="headerlink" title="导入库的一部分"></a>导入库的一部分</h3><p>如果我们只使用库的一部分功能，则可以选择导入需要的内容：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Import only foo.</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lib1/lib1.dart&#x27;</span> <span class="keyword">show</span> foo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Import all names EXCEPT foo.</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:lib2/lib2.dart&#x27;</span> <span class="keyword">hide</span> foo;</span><br></pre></td></tr></table></figure>

<h3 id="延迟加载库"><a href="#延迟加载库" class="headerlink" title="延迟加载库"></a>延迟加载库</h3><p>下面是一些使用延迟加载库的场景：</p>
<ul>
<li>减少 <code>APP</code> 的启动时间</li>
<li>执行 <code>A/B</code> 测试，例如尝试各种算法的不同实现</li>
<li>加载很少使用的功能，例如可选的屏幕和对话框</li>
</ul>
<p>要延迟加载一个库，需要先使用 <code>deferred as</code> 来导入：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:deferred/hello.dart&#x27;</span> <span class="keyword">deferred</span> <span class="keyword">as</span> hello;</span><br></pre></td></tr></table></figure>

<p>当需要使用的时候，使用库标识符调用 <code>loadLibrary()</code> 方法来加载库：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">greet() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> hello.loadLibrary();</span><br><span class="line">  hello.printGreeting();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在上述代码中，使用 <code>await</code> 关键字暂停代码执行一直到库加载完成。</p>
</blockquote>
<p>在一个库上你可以多次调用 <code>loadLibrary()</code> 函数。 但是该库只是载入一次。使用延迟加载库的时候，需要注意如下问题：</p>
<ul>
<li>延迟加载库的常量在导入的时候是不可用的。 只有当库加载完毕的时候，库中常量才可以使用</li>
<li>在导入文件的时候无法使用延迟库中的类型。 如果你需要使用类型，则考虑把接口类型移动到另外一个库中， 让两个库都分别导入这个接口库</li>
<li><code>Dart</code> 隐式的把 <code>loadLibrary()</code> 方法导入到使用 <code>deferred as</code> 的命名空间中。<code>loadLibrary()</code> 方法返回一个 <code>Future</code> 对象</li>
</ul>
<h2 id="异步支持"><a href="#异步支持" class="headerlink" title="异步支持"></a>异步支持</h2><p><code>Dart</code> 有一些语言特性来支持异步编程。最常见的特性是 <code>async</code> 方法和 <code>await</code> 表达式。</p>
<p><code>Dart</code> 库中有很多返回 <code>Future</code> 或者 <code>Stream</code> 对象的方法。这些方法是异步的：这些函数在设置完基本的操作后就返回了，而无需等待操作执行完成。例如读取一个文件，在打开文件后就返回了。</p>
<p>有两种方式可以使用 <code>Future</code> 对象中的数据：</p>
<ul>
<li>使用 <code>async</code> 和 <code>await</code></li>
<li>使用 <code>Future API</code></li>
</ul>
<p>同样的，从 <code>Stream</code> 中获取数据也有两种方式：</p>
<ul>
<li>使用 <code>async</code> 和一个异步 <code>for</code> 循环 (<code>await for</code>)</li>
<li>使用 <code>Stream API</code></li>
</ul>
<p>使用 <code>async</code> 和 <code>await</code> 的代码是异步的：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> lookUpVersion()</span><br></pre></td></tr></table></figure>


<p>要使用 <code>await</code>，其方法必须带有 <code>async</code> 关键字：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">checkVersion() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> version = <span class="keyword">await</span> lookUpVersion();</span><br><span class="line">  <span class="keyword">if</span> (version == expectedVersion) &#123;</span><br><span class="line">    <span class="comment">// Do something.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Do something else.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>try</code>、<code>catch</code> 和 <code>finally</code> 来处理使用 <code>await</code> 的异常：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  server = <span class="keyword">await</span> HttpServer.bind(InternetAddress.LOOPBACK_IP_V4, <span class="number">4044</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// React to inability to bind to the port...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="声明异步方法"><a href="#声明异步方法" class="headerlink" title="声明异步方法"></a>声明异步方法</h3><p>一个异步方法是方法体被标记为 <code>async</code> 的方法。虽然异步方法的执行可能需要一些时间，但是异步方法在调用之后就立刻返回了————在方法体还没执行之前就返回了：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">checkVersion() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lookUpVersion() <span class="keyword">async</span> =&gt; <span class="comment">/* ... */</span>;</span><br></pre></td></tr></table></figure>

<p>在一个方法上添加 <code>async</code> 关键字，则这个方法返回值为 <code>Future</code>。例如，下面是一个返回字符串的同步方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> lookUpVersionSync() =&gt; <span class="string">&#x27;1.0.0&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果使用 <code>async</code> 关键字，则该方法返回一个 <code>Future</code>，并且认为该函数是一个耗时的操作：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">String</span>&gt; lookUpVersion() <span class="keyword">async</span> =&gt; <span class="string">&#x27;1.0.0&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>注意，方法体并不需要使用 <code>Future API</code>。 <code>Dart</code> 会自动在需要的时候创建 <code>Future</code> 对象。</p>
<h3 id="使用-await-表达式"><a href="#使用-await-表达式" class="headerlink" title="使用 await 表达式"></a>使用 await 表达式</h3><p>在<code>Dart</code> 中，<code>await</code> 表达式具有如下的形式：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> expression</span><br></pre></td></tr></table></figure>

<p>在一个异步方法内可以使用多次 <code>await</code> 表达式。例如，下面的示例使用了三次 <code>await</code> 表达式来执行相关的功能：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> entrypoint = <span class="keyword">await</span> findEntrypoint();</span><br><span class="line"><span class="keyword">var</span> exitCode = <span class="keyword">await</span> runExecutable(entrypoint, args);</span><br><span class="line"><span class="keyword">await</span> flushThenExit(exitCode);</span><br></pre></td></tr></table></figure>

<p>在 <code>await expression</code> 中， <code>expression</code> 的返回值通常是一个 <code>Future</code>；如果返回的值不是 <code>Future</code>，则 <code>Dart</code> 会自动把该值放到 <code>Future</code> 中返回。</p>
<p><code>Future</code> 对象代表返回一个对象的 <code>promise</code>。 <code>await expression</code> 执行的结果为这个返回的对象。<code>await expression</code> 会阻塞住，直到需要的对象返回为止。</p>
<h3 id="异步-for-循环"><a href="#异步-for-循环" class="headerlink" title="异步 for 循环"></a>异步 for 循环</h3><p>在 <code>Dart</code> 中，异步 <code>for</code> 循环具有如下的形式：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">for</span> (variable declaration <span class="keyword">in</span> expression) &#123;</span><br><span class="line">  <span class="comment">// Executes each time the stream emits a value.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面 <code>expression</code> 返回的值必须是 <code>Stream</code> 类型的。 执行流程如下：</p>
<ol>
<li>等待直到 <code>Stream</code> 返回一个数据</li>
<li>使用 <code>Stream</code> 返回的参数执行 <code>for</code> 循环代码</li>
<li>重复执行 1 和 2 直到 <code>Stream</code> 数据返回完毕</li>
</ol>
<p>使用 <code>break</code> 或者 <code>return</code> 语句可以停止接收 <code>Stream</code> 的数据，这样就跳出了 <code>for</code> 循环并且从 <code>Stream</code> 上取消注册了。</p>
<p>在 <code>main()</code> 方法中使用异步 for 循环的示例如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main() <span class="keyword">async</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">for</span> (<span class="keyword">var</span> request <span class="keyword">in</span> requestServer) &#123;</span><br><span class="line">    handleRequest(request);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果爱 <code>main()</code> 方法中使用了 <code>await</code>，那么 <code>main()</code> 方法也必须使用 <code>async</code>。</p>
</blockquote>
<p>异步编程的更多信息，请参考 <a target="_blank" rel="noopener" href="https://www.dartlang.org/guides/libraries/library-tour#dartasync---asynchronous-programming">dart:async</a>。</p>
<h2 id="Callable-classes"><a href="#Callable-classes" class="headerlink" title="Callable classes"></a>Callable classes</h2><p>如果 <code>Dart</code> 类实现了 <code>call()</code> 方法则可以把类当做方法来调用：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WannabeFunction</span> </span>&#123;</span><br><span class="line">  call(<span class="built_in">String</span> a, <span class="built_in">String</span> b, <span class="built_in">String</span> c) =&gt; <span class="string">&#x27;<span class="subst">$a</span> <span class="subst">$b</span> <span class="subst">$c</span>!&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> wf = <span class="keyword">new</span> WannabeFunction();</span><br><span class="line">  <span class="keyword">var</span> out = wf(<span class="string">&quot;Hi&quot;</span>,<span class="string">&quot;there,&quot;</span>,<span class="string">&quot;gang&quot;</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$out</span>&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于更多 <code>Callable classes</code> 的信息，请参考 <a target="_blank" rel="noopener" href="https://www.dartlang.org/articles/language/emulating-functions">Emulating Functions in Dart</a>。</p>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>所有的 <code>Dart</code> 代码在协程中运行而不是线程。每个协程都有自己的堆内存，并且确保每个协程的状态都不能被其他协程访问。</p>
<h3 id="Typedefs"><a href="#Typedefs" class="headerlink" title="Typedefs"></a>Typedefs</h3><p>在 <code>Dart</code> 语言中，方法也是对象。使用 <code>typedef</code> 或者 <code>function-type alias</code> 的方式为方法类型命名，然后可以使用命名的方法。当把方法类型赋值给一个变量的时候，<code>typedef</code> 保留类型信息。</p>
<p>下面的代码没有使用 <code>typedef</code>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortedCollection</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Function</span> compare;</span><br><span class="line"></span><br><span class="line">  SortedCollection(<span class="built_in">int</span> f(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b)) &#123;</span><br><span class="line">    compare = f;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Initial, broken implementation.</span></span><br><span class="line"> <span class="built_in">int</span> sort(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b) =&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  SortedCollection coll = <span class="keyword">new</span> SortedCollection(sort);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 我们只知道 compare 是一个 Function 类型，</span></span><br><span class="line">  <span class="comment">// 但是不知道具体是何种 Function 类型？</span></span><br><span class="line">  <span class="keyword">assert</span>(coll.compare <span class="keyword">is</span> <span class="built_in">Function</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当把 <code>f</code> 赋值给 <code>compare</code> 的时候，类型信息会丢失（<code>f(Object a, Object b)</code> 类型变为 <code>int</code>）。</p>
<p>如果我们 <code>typedef</code>，则可以保留这些信息：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">int</span> Compare(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortedCollection</span> </span>&#123;</span><br><span class="line">  Compare compare;</span><br><span class="line"></span><br><span class="line">  SortedCollection(<span class="keyword">this</span>.compare);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Initial, broken implementation.</span></span><br><span class="line"> <span class="built_in">int</span> sort(<span class="built_in">Object</span> a, <span class="built_in">Object</span> b) =&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  SortedCollection coll = <span class="keyword">new</span> SortedCollection(sort);</span><br><span class="line">  <span class="keyword">assert</span>(coll.compare <span class="keyword">is</span> <span class="built_in">Function</span>);</span><br><span class="line">  <span class="keyword">assert</span>(coll.compare <span class="keyword">is</span> Compare);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>typedef</code> 只是别名，<code>Dart</code> 还提供了一种判断任意 <code>function</code> 的类型的方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">int</span> Compare(<span class="built_in">int</span> a, <span class="built_in">int</span> b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> sort(<span class="built_in">int</span> a, <span class="built_in">int</span> b) =&gt; a - b;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(sort <span class="keyword">is</span> Compare); <span class="comment">// True!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h3><p>我们可以通过使用 <code>Metadata</code>（元数据）为代码添加额外的信息。元数据注解是以 <code>@</code> 开头，后面紧跟一个编译时常量或者调用一个常量构造函数实现的：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown"><span class="emphasis">_Deprecated: Use [turnOn] instead._</span></span></span></span><br><span class="line">  <span class="meta">@deprecated</span></span><br><span class="line">  <span class="keyword">void</span> activate() &#123;</span><br><span class="line">    turnOn();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Turns the TV&#x27;s power on.</span></span></span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;on!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以定义自己的元数据注解。下面的示例定义了一个带有两个参数的 <code>@todo</code> 注解：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span> todo;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">todo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> who;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> what;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> todo(<span class="keyword">this</span>.who, <span class="keyword">this</span>.what);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>@todo</code> 注解的示例：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;todo.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@todo</span>(<span class="string">&#x27;seth&#x27;</span>, <span class="string">&#x27;make this do something&#x27;</span>)</span><br><span class="line"><span class="keyword">void</span> doSomething() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;do something&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>元数据可以在 <code>library</code>、<code>class</code>、<code>typedef</code>、<code>type parameter</code>、<code>constructor</code>、<code>factory</code>、<code>function</code>、<code>field</code>、<code>parameter</code> 和 <code>variable</code> 声明之前使用，也可以在 <code>import</code> 或者 <code>export</code> 指令之前使用。使用反射可以在运行时获取元数据信息。</p>
<blockquote>
<p>有三个注解所有的 <code>Dart</code> 代码都可以使用： <code>@deprecated</code>、 <code>@override</code> 和 <code>@proxy</code>。<code> @override</code> 用于表示该方法是复写的父类方法，<code>@proxy</code> 用于表示忽略警告，<code>@deprecated</code> 用以表示该方法或者字段时废弃的。</p>
</blockquote>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>在 <code>Dart</code> 中支持单行、多行以及文档注释。</p>
<p>单行注释以 <code>//</code> 开始。 <code>//</code> 后面的一行内容为 <code>Dart</code> 代码注释。</p>
<p>多行注释以 <code>/*</code> 开始， <code>*/</code> 结尾。 多行注释可以嵌套。</p>
<p>文档注释可以使用 <code>///</code> 开始， 也可以使用 <code>/**</code> 开始 并以 <code>*/</code> 结束。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/index.html/tags/Dart-%E8%AF%AD%E6%B3%95%E9%A2%84%E8%A7%88/" rel="tag"># Dart 语法预览</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/index.html/2018/android-studio-plugin.html" rel="prev" title="Android Studio 插件">
                  <i class="fa fa-chevron-left"></i> Android Studio 插件
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/index.html/2019/dart-language-libraries.html" rel="next" title="Flutter 开发（01）：Dart 语言常用库索引">
                  Flutter 开发（01）：Dart 语言常用库索引 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">肥肥鱼</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/index.html/js/comments.js"></script><script src="/index.html/js/utils.js"></script><script src="/index.html/js/motion.js"></script><script src="/index.html/js/schemes/muse.js"></script><script src="/index.html/js/next-boot.js"></script>

  
<script src="/index.html/js/third-party/search/local-search.js"></script>




  





</body>
</html>
