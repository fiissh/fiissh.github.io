<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/index.html/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/index.html/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/index.html/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/index.html/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="9KsIJJsvbiRMsjTEbN5fANhynVSesariRWUHacVYOD4">
  <meta name="baidu-site-verification" content="95yTtcGSv8">

<link rel="stylesheet" href="/index.html/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"fiissh.tech","root":"/index.html/","images":"/index.html/images","scheme":"Mist","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/index.html/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/index.html/js/config.js"></script>
<meta name="description" content="前面文章介绍的 path_provider.dart 库和 shared_preferences.dart 库的实际上是依赖于设备的具体环境的。比如说在 shared_preferences.dart 库在存储数据时，在 Android 设备上使用的是 SharedPreference 相关的功能，而在 iOS 上则是使用了 NSUserDefaults 的相关功能。换句话说，这些代码都是平台相关">
<meta property="og:type" content="article">
<meta property="og:title" content="Flutter 开发（07）：编写平台相关的代码">
<meta property="og:url" content="https://fiissh.tech/index.html/2019/flutter-platform-specific.html">
<meta property="og:site_name" content="肥言肥语">
<meta property="og:description" content="前面文章介绍的 path_provider.dart 库和 shared_preferences.dart 库的实际上是依赖于设备的具体环境的。比如说在 shared_preferences.dart 库在存储数据时，在 Android 设备上使用的是 SharedPreference 相关的功能，而在 iOS 上则是使用了 NSUserDefaults 的相关功能。换句话说，这些代码都是平台相关">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fiissh.tech/images/flutter-platform-channel.png">
<meta property="og:image" content="https://fiissh.tech/images/binary-messenger.jpg">
<meta property="og:image" content="https://fiissh.tech/images/flutter-codec.jpg">
<meta property="article:published_time" content="2019-03-01T02:33:14.000Z">
<meta property="article:modified_time" content="2019-03-01T02:33:14.000Z">
<meta property="article:author" content="肥肥鱼">
<meta property="article:tag" content="MethodChannel">
<meta property="article:tag" content="EventChannel">
<meta property="article:tag" content="BasicMessageChannel">
<meta property="article:tag" content="Flutter 平台相关">
<meta property="article:tag" content="Platform">
<meta property="article:tag" content="Handler">
<meta property="article:tag" content="codec">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fiissh.tech/images/flutter-platform-channel.png">


<link rel="canonical" href="https://fiissh.tech/index.html/2019/flutter-platform-specific.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://fiissh.tech/index.html/2019/flutter-platform-specific.html","path":"/2019/flutter-platform-specific.html","title":"Flutter 开发（07）：编写平台相关的代码"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Flutter 开发（07）：编写平台相关的代码 | 肥言肥语</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-65174745-4"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-65174745-4","only_pageview":false}</script>
  <script src="/index.html/js/third-party/analytics/google-analytics.js"></script>

  <script src="/index.html/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?2ed36102ffe08627252774ba00c82600"></script>



  <noscript>
    <link rel="stylesheet" href="/index.html/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/index.html/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">肥言肥语</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">肥肥鱼胡说八道的地方</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/index.html/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-archives"><a href="/index.html/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B3%E5%8F%B0%E9%80%9A%E9%81%93%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">平台通道类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#name"><span class="nav-number">1.1.</span> <span class="nav-text">name</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BinaryMessenger"><span class="nav-number">1.2.</span> <span class="nav-text">BinaryMessenger</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#codec"><span class="nav-number">1.3.</span> <span class="nav-text">codec</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MessageCodec"><span class="nav-number">1.3.1.</span> <span class="nav-text">MessageCodec</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#BinaryCodec"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">BinaryCodec</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#StringCodec"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">StringCodec</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JSONMessageCodec"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">JSONMessageCodec</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#StandardMessageCodec"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">StandardMessageCodec</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MethodCodec"><span class="nav-number">1.3.2.</span> <span class="nav-text">MethodCodec</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#JSONMethodCodec"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">JSONMethodCodec</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#StandardMethodCodec"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">StandardMethodCodec</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-number">1.4.</span> <span class="nav-text">消息处理器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#path-provider"><span class="nav-number">2.</span> <span class="nav-text">path_provider</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#getTemporaryDirectory-%E5%92%8C-getApplicationDocumentsDirectory-%E6%96%B9%E6%B3%95"><span class="nav-number">2.1.</span> <span class="nav-text">getTemporaryDirectory() 和 getApplicationDocumentsDirectory() 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getExternalStorageDirectory"><span class="nav-number">2.2.</span> <span class="nav-text">getExternalStorageDirectory()</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="肥肥鱼"
      src="/index.html/images/homercat.png">
  <p class="site-author-name" itemprop="name">肥肥鱼</p>
  <div class="site-description" itemprop="description">fiissh.zhao，肥肥鱼，Android SDK 开发</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/index.html/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/index.html/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/index.html/tags/">
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/fiissh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fiissh" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fiissh.zhao@gmail.com" title="E-Mail → mailto:fiissh.zhao@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fiissh.tech/index.html/2019/flutter-platform-specific.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/index.html/images/homercat.png">
      <meta itemprop="name" content="肥肥鱼">
      <meta itemprop="description" content="fiissh.zhao，肥肥鱼，Android SDK 开发">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肥言肥语">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Flutter 开发（07）：编写平台相关的代码
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-03-01 10:33:14" itemprop="dateCreated datePublished" datetime="2019-03-01T10:33:14+08:00">2019-03-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/index.html/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>前面文章介绍的 <code>path_provider.dart</code> 库和 <code>shared_preferences.dart</code> 库的实际上是依赖于设备的具体环境的。比如说在 <code>shared_preferences.dart</code> 库在存储数据时，在 <code>Android</code> 设备上使用的是 <code>SharedPreference</code> 相关的功能，而在 <code>iOS</code> 上则是使用了 <code>NSUserDefaults</code> 的相关功能。换句话说，这些代码都是平台相关的。</p>
<p>本文主要介绍 <code>Flutter</code> 中平台相关的代码的开发，其目的是快速了解 <code>Android</code> 和 <code>iOS</code> 原生代码与 <code>Flutter</code> 之间的通信。</p>
<p>本文将以 <code>Flutter</code> 的官方 <a target="_blank" rel="noopener" href="https://github.com/flutter/plugins/tree/master/packages/path_provider">path_provider/path_provider.dart</a> 库作为示例。</p>
<p>平台通道的作用是在 <code>Flutter</code> 和设备之间传递消息，如下所示：</p>
<p><img src="/images/flutter-platform-channel.png" alt="flutter-platform-channel"></p>
<p><code>Flutter</code> 中平台特定的 <code>API</code> 支持并不依赖于代码生成，而是依赖于灵活的消息传递方式：</p>
<ul>
<li>应用程序的 <code>Flutter</code> 部分通过平台通道（<code>Platform Channel</code>）将消息发送到该应用程序的设备平台（<code>Android</code> 或 <code>iOS</code>）</li>
<li>设备平台通过对平台通道的监听接收到消息之后，调用设备平台上对应的 <code>API</code>（使用设备平台原生开发语言），然后将响应数据发送回应用程序的 <code>Flutter</code> 部分</li>
</ul>
<p>本文中有大量的内容参考自阿里咸鱼技术团队的 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/43163159">深入理解 Flutter Platform Channel</a> 一文。该文章对 <code>Flutter</code> 的平台通道有非常详细的讲解。</p>
<p>再次表达对咸鱼团队的感谢以及对肥肥作为伸手党的不齿。</p>
<span id="more"></span>
<h2 id="平台通道类型"><a href="#平台通道类型" class="headerlink" title="平台通道类型"></a>平台通道类型</h2><p><code>Flutter</code> 中定义了三种不同类型的平台通道，他们的代码实现在 <code>platform_channel.dart</code> 文件中：</p>
<ul>
<li><code>BasicMessageChannel</code>：用于传递字符串和半结构化的消息</li>
<li><code>MethodChannel</code> 和 <code>OptionalMethodChannel</code>：用于传递方法调用</li>
<li><code>EventChannel</code>：用于传递数据流</li>
</ul>
<p>上述三种类型的平台通道相互独立，都有着各自的用途。从源码的角度来说，每个平台通道都有三个非常重要的成员变量：</p>
<ul>
<li><code>name</code>： <code>String</code> 类型，表示平台通道的名称，也是通道的唯一标识符</li>
<li><code>BinaryMessenger</code>： <code>BinaryMessenger</code> 类型，用于表示消息，是接收和发送消息的具体实现</li>
<li><code>codec</code>： <code>MessageCodec</code> 或者 <code>MethodCodec</code> 类型，是消息的编解码器</li>
</ul>
<h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><p><code>name</code> 属性是平台通道的唯一标识符。一个 <code>Flutter</code> 应用中可能会存在多个平台通道，每一个平台通道在创建时必须指定一个位移的 <code>name</code> 属性（<code>Flutter</code> 使用该属性来区分每一个通道）。</p>
<p>当有消息从 <code>Flutter</code> 端发送到设备平台时，会根据其传递过来的 <code>name</code> 属性找到该通道对应的 <code>Handler</code>（消息处理器）。</p>
<h3 id="BinaryMessenger"><a href="#BinaryMessenger" class="headerlink" title="BinaryMessenger"></a>BinaryMessenger</h3><p>上述三种类型的平台通道都是通过 <code>BinaryMessenger</code> 达到与 <code>Flutter</code> 通信的目的的：</p>
<p><img src="/images/binary-messenger.jpg" alt="binary-messenger"></p>
<p><code>BinaryMessenger</code> 使用的消息数据格式为二进制格式的数据。当我们初始化一个通道并向钙通道注册消息处理器（<code>Handler</code>）时，实际上会生成一个与之对应的 <code>BinaryMessageHandler</code>，并以通道的唯一标示符（<code>name</code>）作为 <code>key</code> 存储到 <code>Map&lt;String, _MessageHandler&gt; _handlers</code> （定义在 <code>platform_messages.dart/BinaryMessages</code> 中）对象中。当我们需要使用 <code>BinaryMessenger</code> 发送消息时，会根据 <code>name</code> 属性查找对应的 <code>BinaryMessageHandler</code>，然后完成消息的发送。</p>
<blockquote>
<p><code>BinaryMessages</code> 在 <code>Android</code> 端是一个接口，其具体实现是 <code>FlutterNativeView</code>。在 <code>iOS</code> 端是一个协议，其名称为 <code>FlutterBinaryMessenger</code>，<code>FlutterViewController</code> 遵循了它。</p>
</blockquote>
<p>在 <code>Flutter</code> 中，<code>BinaryMessenger</code> 并不知道平台通道的存在。事实上，<code>BinaryMessenger</code> 只和 <code>BinaryMessengerHandler</code> 直接通信（<code>name</code> 属性与 <code>BinaryMessengerHandler</code> 一一对象）。</p>
<p>由于平台通道从 <code>BinaryMessengerHandler</code> 接收到的消息是二进制格式的，需要使用 <code>codec</code> 将消息解码为可识别的数据并传递给 <code>Handler</code> 进行处理。</p>
<p>当 <code>Handler</code> 处理完消息之后，会通过回调方法返回 <code>result</code>，并将 <code>result</code> 通过 <code>codec</code> 编码为二进制数据，最终通过 <code>BinaryMessenger</code> 发送回 <code>Flutter</code>。</p>
<h3 id="codec"><a href="#codec" class="headerlink" title="codec"></a>codec</h3><p><code>Flutter</code> 中定义了两种类型的 <code>codec</code>：</p>
<ul>
<li><code>MessageCodec</code>：用于二进制格式的数据与基础数据之间的编解码</li>
<li><code>MethodCodec</code>：用于二进制格式的数据与方法调用以及返回结果之间的编解码</li>
</ul>
<p><img src="/images/flutter-codec.jpg" alt="flutter-codec"></p>
<h4 id="MessageCodec"><a href="#MessageCodec" class="headerlink" title="MessageCodec"></a>MessageCodec</h4><p><code>MessageCodec</code> 用于二进制格式的数据与基础数据之间的编解码，其主要目的是将消息处理为消息处理器（<code>Handler</code>）能够识别的数据。通道 <code>BasicMessageChannel</code> 使用的编解码器类型就是 <code>MessageCodec</code>。<code>MessageCodec</code> 的代码定义如下（<code>message_codec.dart/MessageCodec</code>）：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageCodec</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">Encodes the specified [message] in binary.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">Returns null if the message is null.</span></span></span><br><span class="line">  ByteData encodeMessage(T message);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Decodes the specified [message] from binary.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">Returns null if the message is null.</span></span></span><br><span class="line">  T decodeMessage(ByteData message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>ByteData encodeMessage</code> 接口用于编码数据，<code>T decodeMessage</code> 用于解码数据。</p>
<blockquote>
<p>在 <code>Android</code> 中，<code>MessageCodec</code> 是一个接口，其中定义了两个方法 <code>encodeMessage</code> 和 <code>decodeMessage</code>。其中，<code>encodeMessage</code> 接收一个特定的数据类型，并将其编码为二进制数据 <code>ByteBuffer</code>。<code>decodeMessage</code> 则是接收二进制数据 <code>ByteBuffer</code>，并将其解码为特定的数据类型。在 <code>iOS</code> 中的名称是 <code>FlutterMessageCodec</code>，是一个协议类型，定义了两个方法 <code>encode</code> 和 <code>decode</code>。其中，<code>encode</code> 接收一个类型为 <code>id</code> 的消息，并将其编码为 <code>NSData</code> 类型。<code>decode</code> 则是接收 <code>NSData</code> 类型的信息，并将其解码为 <code>id</code> 类型的数据。</p>
</blockquote>
<p>在 <code>Flutter</code> 中，<code>MessageCodec</code> 有如下四种类型的定义（<code>message_codecs.dart</code>）：</p>
<ul>
<li><code>BinaryCodec</code>： 二进制数据的编解码</li>
<li><code>StringCodec</code>： <code>String</code> 类型和二进制数据之间的编解码（<code>UTF-8</code>）</li>
<li><code>JSONMessageCodec</code>： <code>JSON</code> 格式的基础数据类型与二进制数据之间的编解码</li>
<li><code>StandardMessageCodec</code>： <code>BasicMessageChannel</code> 的默认编解码器</li>
</ul>
<p><code>Flutter</code> 的 <code>BasicMessageChannel</code> 通道使用 <code>StandardMessageCodec</code>编解码器，支持简单的类似于 <code>JSON</code> 的高效二进制序列数据，例如 <code>bool</code>、<code>num</code>、<code>String</code>、<code>List</code>、<code>Map</code> 以及 <code>byte buffer</code> 等（详细信息请移步 <a target="_blank" rel="noopener" href="https://docs.flutter.io/flutter/services/StandardMessageCodec-class.html">StandardMessageCodec class</a>）。当我们发送和接收消息时，这些值在消息中的序列化和反序列化操作都将自动进行。</p>
<h5 id="BinaryCodec"><a href="#BinaryCodec" class="headerlink" title="BinaryCodec"></a>BinaryCodec</h5><p><code>BinaryCodec</code> 是二进制类型数据的编解码器：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryCodec</span> <span class="keyword">implements</span> <span class="title">MessageCodec</span>&lt;<span class="title">ByteData</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">Creates a [MessageCodec] with unencoded binary messages represented using</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">[ByteData].</span></span></span><br><span class="line">  <span class="keyword">const</span> BinaryCodec();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ByteData decodeMessage(ByteData message) =&gt; message;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ByteData encodeMessage(ByteData message) =&gt; message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看出，无论是编码还是解码，<code>BinaryCodec</code> 对 <code>message</code> 没有做任何的处理（实际上，无论编解码操作，<code>BinaryCodec</code> 接收的都是 <code>ByteData</code> 类型的数据）。在 <code>Android</code> 上，<code>ByteData</code> 类型的数据表示为 <code>java.nio.ByteBuffer</code>，而在 <code>iOS</code> 上则表示为 <code>NSData</code>。</p>
<h5 id="StringCodec"><a href="#StringCodec" class="headerlink" title="StringCodec"></a>StringCodec</h5><p><code>StringCodec</code> 用于 <code>UTF-8</code> 类型的字符串数据和二进制数据之间的编解码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringCodec</span> <span class="keyword">implements</span> <span class="title">MessageCodec</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">Creates a [MessageCodec] with UTF-8 encoded String messages.</span></span></span><br><span class="line">  <span class="keyword">const</span> StringCodec();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> decodeMessage(ByteData message) &#123;</span><br><span class="line">    <span class="keyword">if</span> (message == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> utf8.decoder.convert(message.buffer.asUint8List(message.offsetInBytes, message.lengthInBytes));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ByteData encodeMessage(<span class="built_in">String</span> message) &#123;</span><br><span class="line">    <span class="keyword">if</span> (message == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> Uint8List encoded = utf8.encoder.convert(message);</span><br><span class="line">    <span class="keyword">return</span> encoded.buffer.asByteData();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>String</code> 类型的数据 <code>message</code> 在 <code>Android</code> 上的表示为 <code>java.util.String</code>，而在 <code>iOS</code> 上则表示为 <code>NSString</code>。</p>
<p>数据类型的转换使用了 <code>dart.convert</code> 库中的 <code>Utf8Codec</code>。</p>
<h5 id="JSONMessageCodec"><a href="#JSONMessageCodec" class="headerlink" title="JSONMessageCodec"></a>JSONMessageCodec</h5><p><code>JSONMessageCodec</code> 用于 <code>UTF-8</code> 的 <code>JSON</code> 型消息与二进制数据之间的编解码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JSONMessageCodec</span> <span class="keyword">implements</span> <span class="title">MessageCodec</span>&lt;<span class="title">dynamic</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// The codec serializes messages as defined by the JSON codec of the</span></span><br><span class="line">  <span class="comment">// dart:convert package. The format used must match the Android and</span></span><br><span class="line">  <span class="comment">// iOS counterparts.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Creates a [MessageCodec] with UTF-8 encoded JSON messages.</span></span></span><br><span class="line">  <span class="keyword">const</span> JSONMessageCodec();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ByteData encodeMessage(<span class="built_in">dynamic</span> message) &#123;</span><br><span class="line">    <span class="keyword">if</span> (message == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const</span> StringCodec().encodeMessage(json.encode(message));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">dynamic</span> decodeMessage(ByteData message) &#123;</span><br><span class="line">    <span class="keyword">if</span> (message == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> message;</span><br><span class="line">    <span class="keyword">return</span> json.decode(<span class="keyword">const</span> StringCodec().decodeMessage(message));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该解码器所支持的基础数据类型有如下几种：</p>
<ul>
<li><code>null</code></li>
<li><code>bool</code></li>
<li><code>num</code></li>
<li><code>String</code></li>
<li><code>List</code></li>
<li><code>Map</code></li>
</ul>
<p>在 <code>Android</code> 上，<code>dynamic message</code> 的数据表示为 <code>JSON</code> 对象（<code>org.json</code> 包），而在 <code>iOS</code> 上则表示为 <code>NSJSONSerialization</code>。</p>
<p><code>JSON</code> 类型的数据转换为二进制数据使用了 <code>StringCodec().encodeMessage(json.encode(message))</code>，该过程实际上是先将 <code>json</code> 对象转换为 <code>String</code>，然后再通过 <code>StringCodec().encodeMessage</code> 方法将 <code>String</code> 数据转换为 <code>ByteData</code>。相反的，首先，通过使用 <code>StringCodec().decodeMessage(message)</code> 方法将二进制数据转换为 <code>String</code>，然后可以通过使用 <code>json.decode</code> 方法将 <code>String</code> 数据转换为 <code>JSON</code> 对象。</p>
<h5 id="StandardMessageCodec"><a href="#StandardMessageCodec" class="headerlink" title="StandardMessageCodec"></a>StandardMessageCodec</h5><p><code>StandardMessageCodec</code> 用于基本数据类型与二进制数据的编解码。</p>
<p>下表显示了 <code>StandardMessageCodec</code> 中需要转换的基础数据类型在 <code>Android</code> 和 <code>iOS</code> 中对应的关系：</p>
<table>
<thead>
<tr>
<th>Flutter</th>
<th>Android</th>
<th>iOS</th>
</tr>
</thead>
<tbody><tr>
<td>null</td>
<td>null</td>
<td>nil (NSNull when nested)</td>
</tr>
<tr>
<td>bool</td>
<td>ava.lang.Boolean</td>
<td>NSNumber numberWithBool:</td>
</tr>
<tr>
<td>int</td>
<td>java.lang.Integer</td>
<td>NSNumber numberWithInt:</td>
</tr>
<tr>
<td>int, if 32 bits not enough</td>
<td>java.lang.Long</td>
<td>NSNumber numberWithLong:</td>
</tr>
<tr>
<td>int, if 64 bits not enough</td>
<td>java.math.BigInteger</td>
<td>FlutterStandardBigInteger</td>
</tr>
<tr>
<td>double</td>
<td>java.lang.Double</td>
<td>NSNumber numberWithDouble:</td>
</tr>
<tr>
<td>String</td>
<td>java.lang.String</td>
<td>NSString</td>
</tr>
<tr>
<td>Uint8List</td>
<td>byte[]</td>
<td>FlutterStandardTypedData typedDataWithBytes:</td>
</tr>
<tr>
<td>Int32List</td>
<td>int[]</td>
<td>FlutterStandardTypedData typedDataWithInt32:</td>
</tr>
<tr>
<td>Int64List</td>
<td>long[]</td>
<td>FlutterStandardTypedData typedDataWithInt64:</td>
</tr>
<tr>
<td>Float64List</td>
<td>double[]</td>
<td>FlutterStandardTypedData typedDataWithFloat64:</td>
</tr>
<tr>
<td>List</td>
<td>java.util.ArrayList</td>
<td>NSArray</td>
</tr>
<tr>
<td>Map</td>
<td>java.util.HashMap</td>
<td>NSDictionary</td>
</tr>
</tbody></table>
<p><code>StandardMessageCodec</code> 中对基础数据类型的编码操作是在 <code>writeValue</code> 方法中完成的，而解码操作则是在 <code>readValue</code> 方法中完成。对基础数据类型和二进制数据相互转换感兴趣的小伙伴可以深入学习这两个方法。本文对此不再做介绍。</p>
<h4 id="MethodCodec"><a href="#MethodCodec" class="headerlink" title="MethodCodec"></a>MethodCodec</h4><p><code>MethodCodec</code> 用于二进制数据与方法调用和返回结果之间的编解码。<code>MethodChannel</code> 和 <code>EventChannel</code> 两个通道类型所使用的编解码器就是 <code>MethodCodec</code>。<code>MethodCodec</code> 的代码定义如下（<code>message_codec/MethodCodec</code>）：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodCodec</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">Encodes the specified [methodCall] into binary.</span></span></span><br><span class="line">  ByteData encodeMethodCall(MethodCall methodCall);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Decodes the specified [methodCall] from binary.</span></span></span><br><span class="line">  MethodCall decodeMethodCall(ByteData methodCall);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Decodes the specified result [envelope] from binary.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">Throws [PlatformException], if [envelope] represents an error, otherwise</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">returns the enveloped result.</span></span></span><br><span class="line">  <span class="built_in">dynamic</span> decodeEnvelope(ByteData envelope);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Encodes a successful [result] into a binary envelope.</span></span></span><br><span class="line">  ByteData encodeSuccessEnvelope(<span class="built_in">dynamic</span> result);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Encodes an error result into a binary envelope.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">The specified error [code], human-readable error [message], and error</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">[details] correspond to the fields of [PlatformException].</span></span></span><br><span class="line">  ByteData encodeErrorEnvelope(&#123;<span class="meta">@required</span> <span class="built_in">String</span> code, <span class="built_in">String</span> message, <span class="built_in">dynamic</span> details&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MethodCodec</code> 中各个方法的说明如下：</p>
<ul>
<li><code>ByteData encodeMethodCall</code>：编码方法调用</li>
<li><code>MethodCall decodeMethodCall</code>：解码方法调用</li>
<li><code>dynamic decodeEnvelope</code>：将方法调用的二进制数据解码</li>
<li><code>ByteData encodeSuccessEnvelope</code>：方法调用成功时，将 <code>result</code> 编码为二进制数据</li>
<li><code>ByteData encodeErrorEnvelope</code>：方法调用失败时，将 <code>code</code>、<code>message</code> 和 <code>details</code> 编码为二进制数据</li>
</ul>
<p>与 <code>MessageCodec</code> 所不同的是，<code>MethodCodec</code> 用于方法调用（方法对象）的编解码。一个方法对象代表一次从 <code>Flutter</code> 发起的一次方法调用。每个方法调用有两个成员变量（以 <code>MethodChannel</code> 的 <code>invokeMethod</code> 方法为例）：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">dynamic</span>&gt; invokeMethod(<span class="built_in">String</span> method, [<span class="built_in">dynamic</span> arguments]) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">assert</span>(method != <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">dynamic</span> result = <span class="keyword">await</span> BinaryMessages.send(</span><br><span class="line">    name,</span><br><span class="line">    codec.encodeMethodCall(MethodCall(method, arguments)),</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> MissingPluginException(<span class="string">&#x27;No implementation found for method <span class="subst">$method</span> on channel <span class="subst">$name</span>&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> codec.decodeEnvelope(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>method</code> 表示需要调用的方法名称，通用类型（<code>Android</code> 中的 <code>Object</code> 和 <code>iOS</code> 中的 <code>id</code>） <code>arguments</code> 表示需要调用的方法参数。</p>
<p>相对于 <code>MessageCodec</code>，<code>MethodCodec</code> 编解码器多了针对于调用结果的处理接口。当方法调用成功是，使用 <code>encodeSuccessEnvelope</code> 将 <code>result</code> 编码为二进制数据，而当方法调用失败时，则使用 <code>encodeErrorEnvelope</code> 将 <code>code</code>、<code>message</code> 和 <code>details</code> 编码为二进制数据。</p>
<p>在 <code>Flutter</code> 中，<code>MethodCodec</code> 有如下两种类型的定义（<code>message_codecs.dart</code>）：</p>
<ul>
<li><code>JSONMethodCodec</code>：编解码 <code>JSON</code> 类型的方法调用，实际上依赖于 <code>JSONMessageCodec</code></li>
<li><code>StandardMethodCodec</code>：<code>MethodCodec</code> 的默认实现，二进制类型的方法调用编解码器，实际上依赖于 <code>StandardMessageCodec</code></li>
</ul>
<h5 id="JSONMethodCodec"><a href="#JSONMethodCodec" class="headerlink" title="JSONMethodCodec"></a>JSONMethodCodec</h5><p><code>JSONMethodCodec</code> 用于 <code>UTF-8</code> 的 <code>JSON</code> 类型的方法调用与二进制数据之间的转换：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JSONMethodCodec</span> <span class="keyword">implements</span> <span class="title">MethodCodec</span> </span>&#123;</span><br><span class="line">  <span class="comment">// The codec serializes method calls, and result envelopes as outlined below.</span></span><br><span class="line">  <span class="comment">// This format must match the Android and iOS counterparts.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// * Individual values are serialized as defined by the JSON codec of the</span></span><br><span class="line">  <span class="comment">//   dart:convert package.</span></span><br><span class="line">  <span class="comment">// * Method calls are serialized as two-element maps, with the method name</span></span><br><span class="line">  <span class="comment">//   keyed by &#x27;method&#x27; and the arguments keyed by &#x27;args&#x27;.</span></span><br><span class="line">  <span class="comment">// * Reply envelopes are serialized as either:</span></span><br><span class="line">  <span class="comment">//   * one-element lists containing the successful result as its single</span></span><br><span class="line">  <span class="comment">//     element, or</span></span><br><span class="line">  <span class="comment">//   * three-element lists containing, in order, an error code String, an</span></span><br><span class="line">  <span class="comment">//     error message String, and an error details value.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Creates a [MethodCodec] with UTF-8 encoded JSON method calls and result</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">envelopes.</span></span></span><br><span class="line">  <span class="keyword">const</span> JSONMethodCodec();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ByteData encodeMethodCall(MethodCall call) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const</span> JSONMessageCodec().encodeMessage(&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt;&#123;</span><br><span class="line">      <span class="string">&#x27;method&#x27;</span>: call.method,</span><br><span class="line">      <span class="string">&#x27;args&#x27;</span>: call.arguments,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  MethodCall decodeMethodCall(ByteData methodCall) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">dynamic</span> decoded = <span class="keyword">const</span> JSONMessageCodec().decodeMessage(methodCall);</span><br><span class="line">    <span class="keyword">if</span> (decoded <span class="keyword">is</span>! <span class="built_in">Map</span>)</span><br><span class="line">      <span class="keyword">throw</span> FormatException(<span class="string">&#x27;Expected method call Map, got <span class="subst">$decoded</span>&#x27;</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">dynamic</span> method = decoded[<span class="string">&#x27;method&#x27;</span>];</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">dynamic</span> arguments = decoded[<span class="string">&#x27;args&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span> (method <span class="keyword">is</span> <span class="built_in">String</span>)</span><br><span class="line">      <span class="keyword">return</span> MethodCall(method, arguments);</span><br><span class="line">    <span class="keyword">throw</span> FormatException(<span class="string">&#x27;Invalid method call: <span class="subst">$decoded</span>&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">dynamic</span> decodeEnvelope(ByteData envelope) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">dynamic</span> decoded = <span class="keyword">const</span> JSONMessageCodec().decodeMessage(envelope);</span><br><span class="line">    <span class="keyword">if</span> (decoded <span class="keyword">is</span>! <span class="built_in">List</span>)</span><br><span class="line">      <span class="keyword">throw</span> FormatException(<span class="string">&#x27;Expected envelope List, got <span class="subst">$decoded</span>&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (decoded.length == <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> decoded[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (decoded.length == <span class="number">3</span></span><br><span class="line">        &amp;&amp; decoded[<span class="number">0</span>] <span class="keyword">is</span> <span class="built_in">String</span></span><br><span class="line">        &amp;&amp; (decoded[<span class="number">1</span>] == <span class="keyword">null</span> || decoded[<span class="number">1</span>] <span class="keyword">is</span> <span class="built_in">String</span>))</span><br><span class="line">      <span class="keyword">throw</span> PlatformException(</span><br><span class="line">        code: decoded[<span class="number">0</span>],</span><br><span class="line">        message: decoded[<span class="number">1</span>],</span><br><span class="line">        details: decoded[<span class="number">2</span>],</span><br><span class="line">      );</span><br><span class="line">    <span class="keyword">throw</span> FormatException(<span class="string">&#x27;Invalid envelope: <span class="subst">$decoded</span>&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ByteData encodeSuccessEnvelope(<span class="built_in">dynamic</span> result) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const</span> JSONMessageCodec().encodeMessage(&lt;<span class="built_in">dynamic</span>&gt;[result]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ByteData encodeErrorEnvelope(&#123;<span class="meta">@required</span> <span class="built_in">String</span> code, <span class="built_in">String</span> message, <span class="built_in">dynamic</span> details&#125;) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(code != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const</span> JSONMessageCodec().encodeMessage(&lt;<span class="built_in">dynamic</span>&gt;[code, message, details]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中可以看出，<code>JSONMethodCodec</code> 实际上是依赖 <code>JSONMessageCodec</code> 实现的。当使用 <code>JSONMethodCodec</code> 编码方法调用时，会先将方法调用转化为 <code>&#123;&quot;method&quot;:method,&quot;args&quot;:args&#125;</code>，然后通过 <code>JSONMessageCodec().encodeMessage</code> 完成调用。而 <code>JSONMethodCodec</code> 在编码调用结果 <code>result</code> 时，会先通过 <code>JSONMessageCodec().decodeMessage(envelope)</code> 将其转换为一个数组，如果调用成功，则通过 <code>JSONMessageCodec().encodeMessage(&lt;dynamic&gt;[result])</code> 将 <code>result</code> 编码为二进制数据，如果失败，则通过 <code>JSONMessageCodec().encodeMessage(&lt;dynamic&gt;[code, message, details])</code> 将 <code>code</code>、<code>message</code> 和 <code>details</code> 编码为二进制数据。该过程是在 <code>MethodChannel</code> 的 <code>_handleAsMethodCall</code> 完成的：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;ByteData&gt; _handleAsMethodCall(ByteData message, Future&lt;<span class="built_in">dynamic</span>&gt; handler(MethodCall call)) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> MethodCall call = codec.decodeMethodCall(message);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> codec.encodeSuccessEnvelope(<span class="keyword">await</span> handler(call));</span><br><span class="line">  &#125; <span class="keyword">on</span> PlatformException <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> codec.encodeErrorEnvelope(</span><br><span class="line">      code: e.code,</span><br><span class="line">      message: e.message,</span><br><span class="line">      details: e.details,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">on</span> MissingPluginException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> codec.encodeErrorEnvelope(code: <span class="string">&#x27;error&#x27;</span>, message: e.toString(), details: <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="StandardMethodCodec"><a href="#StandardMethodCodec" class="headerlink" title="StandardMethodCodec"></a>StandardMethodCodec</h5><p><code>StandardMethodCodec</code> 是 <code>MethodCodec</code> 的默认实现，主要用于基础数据类型与二进制数据之间的编解码。<code>StandardMethodCodec</code> 的实现依赖于 <code>StandardMessageCodec</code>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StandardMethodCodec</span> <span class="keyword">implements</span> <span class="title">MethodCodec</span> </span>&#123;</span><br><span class="line">  <span class="comment">// The codec method calls, and result envelopes as outlined below. This format</span></span><br><span class="line">  <span class="comment">// must match the Android and iOS counterparts.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// * Individual values are encoded using [StandardMessageCodec].</span></span><br><span class="line">  <span class="comment">// * Method calls are encoded using the concatenation of the encoding</span></span><br><span class="line">  <span class="comment">//   of the method name String and the arguments value.</span></span><br><span class="line">  <span class="comment">// * Reply envelopes are encoded using first a single byte to distinguish the</span></span><br><span class="line">  <span class="comment">//   success case (0) from the error case (1). Then follows:</span></span><br><span class="line">  <span class="comment">//   * In the success case, the encoding of the result value.</span></span><br><span class="line">  <span class="comment">//   * In the error case, the concatenation of the encoding of the error code</span></span><br><span class="line">  <span class="comment">//     string, the error message string, and the error details value.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Creates a [MethodCodec] using the Flutter standard binary encoding.</span></span></span><br><span class="line">  <span class="keyword">const</span> StandardMethodCodec([<span class="keyword">this</span>.messageCodec = <span class="keyword">const</span> StandardMessageCodec()]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">The message codec that this method codec uses for encoding values.</span></span></span><br><span class="line">  <span class="keyword">final</span> StandardMessageCodec messageCodec;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ByteData encodeMethodCall(MethodCall call) &#123;</span><br><span class="line">    <span class="keyword">final</span> WriteBuffer buffer = WriteBuffer();</span><br><span class="line">    messageCodec.writeValue(buffer, call.method);</span><br><span class="line">    messageCodec.writeValue(buffer, call.arguments);</span><br><span class="line">    <span class="keyword">return</span> buffer.done();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  MethodCall decodeMethodCall(ByteData methodCall) &#123;</span><br><span class="line">    <span class="keyword">final</span> ReadBuffer buffer = ReadBuffer(methodCall);</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">dynamic</span> method = messageCodec.readValue(buffer);</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">dynamic</span> arguments = messageCodec.readValue(buffer);</span><br><span class="line">    <span class="keyword">if</span> (method <span class="keyword">is</span> <span class="built_in">String</span> &amp;&amp; !buffer.hasRemaining)</span><br><span class="line">      <span class="keyword">return</span> MethodCall(method, arguments);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">const</span> FormatException(<span class="string">&#x27;Invalid method call&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ByteData encodeSuccessEnvelope(<span class="built_in">dynamic</span> result) &#123;</span><br><span class="line">    <span class="keyword">final</span> WriteBuffer buffer = WriteBuffer();</span><br><span class="line">    buffer.putUint8(<span class="number">0</span>);</span><br><span class="line">    messageCodec.writeValue(buffer, result);</span><br><span class="line">    <span class="keyword">return</span> buffer.done();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  ByteData encodeErrorEnvelope(&#123;<span class="meta">@required</span> <span class="built_in">String</span> code, <span class="built_in">String</span> message, <span class="built_in">dynamic</span> details&#125;) &#123;</span><br><span class="line">    <span class="keyword">final</span> WriteBuffer buffer = WriteBuffer();</span><br><span class="line">    buffer.putUint8(<span class="number">1</span>);</span><br><span class="line">    messageCodec.writeValue(buffer, code);</span><br><span class="line">    messageCodec.writeValue(buffer, message);</span><br><span class="line">    messageCodec.writeValue(buffer, details);</span><br><span class="line">    <span class="keyword">return</span> buffer.done();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">dynamic</span> decodeEnvelope(ByteData envelope) &#123;</span><br><span class="line">    <span class="comment">// First byte is zero in success case, and non-zero otherwise.</span></span><br><span class="line">    <span class="keyword">if</span> (envelope.lengthInBytes == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">const</span> FormatException(<span class="string">&#x27;Expected envelope, got nothing&#x27;</span>);</span><br><span class="line">    <span class="keyword">final</span> ReadBuffer buffer = ReadBuffer(envelope);</span><br><span class="line">    <span class="keyword">if</span> (buffer.getUint8() == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> messageCodec.readValue(buffer);</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">dynamic</span> errorCode = messageCodec.readValue(buffer);</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">dynamic</span> errorMessage = messageCodec.readValue(buffer);</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">dynamic</span> errorDetails = messageCodec.readValue(buffer);</span><br><span class="line">    <span class="keyword">if</span> (errorCode <span class="keyword">is</span> <span class="built_in">String</span> &amp;&amp; (errorMessage == <span class="keyword">null</span> || errorMessage <span class="keyword">is</span> <span class="built_in">String</span>) &amp;&amp; !buffer.hasRemaining)</span><br><span class="line">      <span class="keyword">throw</span> PlatformException(code: errorCode, message: errorMessage, details: errorDetails);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">const</span> FormatException(<span class="string">&#x27;Invalid envelope&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用 <code>StandardMethodCodec</code> 编码方法调用时，会先通过 <code>StandardMessageCodec</code> 的 <code>writeValue</code> 将 <code>call.method</code> 和 <code>call.arguments</code> 写入 <code>buffer</code>。在解码方法调用时，会通过 <code>readValue</code> 将写入的二进制数据取出。</p>
<p>在编码调用结果时，如果调用成功，则会先向 <code>buffer</code> 中写入数据 0（表示调用成功），然后再写入编码后的 <code>result</code>。如果调用失败，则先向 <code>buffer</code> 中写入 1（表示调用失败），然后再写入 编码后的 <code>code</code>、<code>message</code> 和 <code>details</code>。该过程也是在 <code>MethodChannel</code> 的 <code>_handleAsMethodCall</code> 方法中实现的。</p>
<h3 id="消息处理器"><a href="#消息处理器" class="headerlink" title="消息处理器"></a>消息处理器</h3><p>当我们接收到二进制消息，并通过 <code>codec</code> 对象将消息处理为消息处理器能够是别的数据之后，消息处理器才开始工作：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Future&lt;ByteData&gt; send(<span class="built_in">String</span> channel, ByteData message) &#123;</span><br><span class="line">  <span class="keyword">final</span> _MessageHandler handler = _mockHandlers[channel];</span><br><span class="line">  <span class="keyword">if</span> (handler != <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> handler(message);</span><br><span class="line">  <span class="keyword">return</span> _sendPlatformMessage(channel, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以通道类型一一对应的，<code>Flutter</code> 中定义了三种消息处理器：</p>
<ul>
<li><code>MessageHandler</code>： 用于处理字符串或者半结构化的消息类型，对应 <code>BasicMessageChannel</code></li>
<li><code>MethodHandler</code>： 用于处理方法的调用，对应 <code>MethodChannel</code></li>
<li><code>StreamHandler</code>： 用于处理事件流，对应 <code>EventChannel</code></li>
</ul>
<h2 id="path-provider"><a href="#path-provider" class="headerlink" title="path_provider"></a>path_provider</h2><p>为了学习方便，肥肥基于官方 <a target="_blank" rel="noopener" href="https://github.com/flutter/plugins/tree/master/packages/path_provider">path_provider/path_provider.dart</a> 项目重新在 <code>Github</code> 进行了部署： <a target="_blank" rel="noopener" href="https://github.com/fiissh/path_provider">fiissh/path_provider</a>。需要的小伙伴可以自行 <code>clone</code>。</p>
<p>在 <code>Android Studio</code>（请确保环境已经正确配置） 中打开项目，我们首先来看一下 <code>lib/path_provider.dart</code> 文件。该文件中定义了三个方法：</p>
<ul>
<li><code>Future&lt;Directory&gt; getTemporaryDirectory()</code></li>
<li><code>Future&lt;Directory&gt; getApplicationDocumentsDirectory()</code></li>
<li><code>Future&lt;Directory&gt; getExternalStorageDirectory()</code></li>
</ul>
<p>以及在文件开头的位置定义了一个编译时常量 <code>_channel</code>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MethodChannel _channel = MethodChannel(<span class="string">&#x27;plugins.flutter.io/path_provider&#x27;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>path_provider</code> 主要使用了三种平台通道类型中的 <code>MethodChannel</code> 通道。<code>plugins.flutter.io/path_provider</code> 作为 <code>MethodChannel</code> 构造参数，在其初始化时将会作为该通道的唯一标识。</p>
</blockquote>
<h3 id="getTemporaryDirectory-和-getApplicationDocumentsDirectory-方法"><a href="#getTemporaryDirectory-和-getApplicationDocumentsDirectory-方法" class="headerlink" title="getTemporaryDirectory() 和 getApplicationDocumentsDirectory() 方法"></a>getTemporaryDirectory() 和 getApplicationDocumentsDirectory() 方法</h3><p>实际上两个方法的实现机制是一样的。我们只分析 <code>getApplicationDocumentsDirectory()</code> 方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Directory&gt; getApplicationDocumentsDirectory() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="comment">// TODO(amirh): remove this on when the invokeMethod update makes it to stable Flutter.</span></span><br><span class="line">  <span class="comment">// https://github.com/flutter/flutter/issues/26431</span></span><br><span class="line">  <span class="comment">// ignore: strong_mode_implicit_dynamic_method</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> path = <span class="keyword">await</span> _channel.invokeMethod(<span class="string">&#x27;getApplicationDocumentsDirectory&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Directory(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法的定义非常简单，最关键的代码只有一行：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="built_in">String</span> path = <span class="keyword">await</span> _channel.invokeMethod(<span class="string">&#x27;getApplicationDocumentsDirectory&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>其作用是通过 <code>_channel</code> 通道的 <code>invokeMethod</code> 方法调用 <code>Android</code> 和 <code>iOS</code> 平台上的 <code>getApplicationDocumentsDirectory</code> 方法，并在调用之后返回 <code>String</code> 类型的返回值 <code>path</code>。</p>
<p>现在我们比较明确的一点是，<code>getApplicationDocumentsDirectory()</code> 方法调用之后会通过 <code>MethodChannel</code> 平台通道调用 <code>Android</code> 或 <code>iOS</code> 上的 <code>getApplicationDocumentsDirectory</code> 方法。</p>
<p><code>Android</code> 或者 <code>iOS</code> 设备是如何知道 <code>Flutter</code> 的具体调用意图的呢？</p>
<p>我们进入到 <code>path_provider</code> 项目的 <code>Android</code> 部分（项目右键-<code>Flutter</code>-<code>Open Android module in Android Studio</code>）可以看到，在 <code>io.flutter.plugins.pathprovider</code> 包下有一个 <code>PathProviderPlugin.java</code> 类。该类继承自 <code>MethodCallHandler</code> 并实现了 <code>onMethodCall</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMethodCall</span><span class="params">(MethodCall call, Result result)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (call.method) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;getTemporaryDirectory&quot;</span>:</span><br><span class="line">      result.success(getPathProviderTemporaryDirectory());</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;getApplicationDocumentsDirectory&quot;</span>:</span><br><span class="line">      result.success(getPathProviderApplicationDocumentsDirectory());</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;getStorageDirectory&quot;</span>:</span><br><span class="line">      result.success(getPathProviderStorageDirectory());</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      result.notImplemented();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 <code>IntelliJ IDEA</code> 时，使用项目右键-<code>Flutter</code>-<code>Open Android module in Android Studio</code> 的方式可能会出现无法打开的情况。此时建议使用 <code>Android Studio</code>。</p>
</blockquote>
<p><code>onMethodCall</code> 方法接收来自 <code>Flutter</code> 端传递过来的 <code>call</code> 和 <code>result</code> 两个参数。其中，<code>call</code> 对象存储了我们需要调用的方法名称（比如，<code>Flutter</code> 层需要调用的方法为 <code>getApplicationDocumentsDirectory</code>，通过 <code>call.method</code> 属性实现与 <code>Android</code> 端方法的对应）。<code>result</code> 对象则负责将 <code>Android</code> 端方法调用的结果传递回 <code>Flutter</code> 层。</p>
<p>静态方法 <code>registerWith</code> 则用于创建 <code>MethodChannel</code> 对象以及初始化 <code>PathProviderPlugin</code> 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerWith</span><span class="params">(Registrar registrar)</span> </span>&#123;</span><br><span class="line">  MethodChannel channel = <span class="keyword">new</span> MethodChannel(registrar.messenger(), <span class="string">&quot;plugins.flutter.io/path_provider&quot;</span>);</span><br><span class="line">  PathProviderPlugin instance = <span class="keyword">new</span> PathProviderPlugin(registrar);</span><br><span class="line">  channel.setMethodCallHandler(instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过在 <code>Android</code> 端初始化一个 <code>MethodChannel</code> 对象，并设置与 <code>Flutter</code> 端一样的平台通道唯一标识（<code>plugins.flutter.io/path_provider</code>），可以实现 <code>Flutter</code> 端和设备端的平台通道的映射。<code>PathProviderPlugin</code> 作为消息处理器的具体实现（<code>MethodCallHandler</code>），通过 <code>channel.setMethodCallHandler(instance)</code> 实现了平台通道与消息处理器的对应关系。</p>
<p>在实现了平台通道与消息处理器之间的对应关系之后，来自 <code>Flutter</code> 层的调用又是如何准确的知道消息处理器的位置呢？<code>path_provider</code> 的示例项目的 <code>Android</code> 部分给了我们答案（<code>io.flutter.plugins</code> 包）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneratedPluginRegistrant</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerWith</span><span class="params">(PluginRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (alreadyRegisteredWith(registry)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PathProviderPlugin.registerWith(registry.registrarFor(<span class="string">&quot;io.flutter.plugins.pathprovider.PathProviderPlugin&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">alreadyRegisteredWith</span><span class="params">(PluginRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String key = GeneratedPluginRegistrant.class.getCanonicalName();</span><br><span class="line">    <span class="keyword">if</span> (registry.hasPlugin(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    registry.registrarFor(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>io.flutter.plugins.pathprovider.PathProviderPlugin</code> 是我们的消息处理器的绝对路径。该过程将消息处理器的对决路径注册到 <code>Flutter</code> 在设备端的引擎中，然后通过 <code>Flutter</code> 端和设备端设置的通道唯一标识将平台通道、消息处理器实现一一对应的关系。</p>
<p>静态方法 <code>registerWith</code> 在 <code>Flutter</code> 应用项目的唯一一个 <code>Activity</code>（<code>Android</code> 端）中被调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">FlutterActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    GeneratedPluginRegistrant.registerWith(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getExternalStorageDirectory"><a href="#getExternalStorageDirectory" class="headerlink" title="getExternalStorageDirectory()"></a>getExternalStorageDirectory()</h3><p>在实现原理上，<code>getExternalStorageDirectory()</code> 与其他另外两个方法并没有实际的区别。<code>getExternalStorageDirectory()</code> 比较特殊的地方在于，通过在 <code>Flutter</code> 端使用 <code>Platform.isIOS</code> 方法判断设备是否是 <code>iOS</code>，以此达到判断平台的目的。这也就意味着，<code>iOS</code> 设备上使用 <code>Flutter</code> 调用 <code>getExternalStorageDirectory()</code> 方法将会抛出一个异常：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Directory&gt; getExternalStorageDirectory() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (Platform.isIOS)</span><br><span class="line">    <span class="keyword">throw</span> UnsupportedError(<span class="string">&quot;Functionality not available on iOS&quot;</span>);</span><br><span class="line">  <span class="comment">// TODO(amirh): remove this on when the invokeMethod update makes it to stable Flutter.</span></span><br><span class="line">  <span class="comment">// https://github.com/flutter/flutter/issues/26431</span></span><br><span class="line">  <span class="comment">// ignore: strong_mode_implicit_dynamic_method</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> path = <span class="keyword">await</span> _channel.invokeMethod(<span class="string">&#x27;getStorageDirectory&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Directory(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Platform</code> 类（<code>platform.dart</code> 文件，<code>dart.io</code> 库）定义了大量的当前设备环境相关的信息，其中包括判断当前设备类型、获取设备操作系统相关信息等。关于 <code>Platform</code> 类的详细信息，请移步 <code>Flutter</code> 官方文档 <a target="_blank" rel="noopener" href="https://docs.flutter.io/flutter/dart-io/Platform-class.html">Platform class</a>。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/index.html/tags/MethodChannel/" rel="tag"># MethodChannel</a>
              <a href="/index.html/tags/EventChannel/" rel="tag"># EventChannel</a>
              <a href="/index.html/tags/BasicMessageChannel/" rel="tag"># BasicMessageChannel</a>
              <a href="/index.html/tags/Flutter-%E5%B9%B3%E5%8F%B0%E7%9B%B8%E5%85%B3/" rel="tag"># Flutter 平台相关</a>
              <a href="/index.html/tags/Platform/" rel="tag"># Platform</a>
              <a href="/index.html/tags/Handler/" rel="tag"># Handler</a>
              <a href="/index.html/tags/codec/" rel="tag"># codec</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/index.html/2019/flutter-sharedpreference-by-shared-preference.html" rel="prev" title="Flutter 开发（06）：Flutter 中 SharedPreference">
                  <i class="fa fa-chevron-left"></i> Flutter 开发（06）：Flutter 中 SharedPreference
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/index.html/2019/flutter-plugin-file-path-provider.html" rel="next" title="Flutter 开发（08）：Flutter 插件开发（flutter_file_path_provide）">
                  Flutter 开发（08）：Flutter 插件开发（flutter_file_path_provide） <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">肥肥鱼</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/index.html/js/comments.js"></script><script src="/index.html/js/utils.js"></script><script src="/index.html/js/motion.js"></script><script src="/index.html/js/schemes/muse.js"></script><script src="/index.html/js/next-boot.js"></script>

  
<script src="/index.html/js/third-party/search/local-search.js"></script>




  





</body>
</html>
